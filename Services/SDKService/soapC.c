/* soapC.c
   Generated by gSOAP 2.8.16 from rcx.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.16 2014-03-06 03:09:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_ns3__char:
		return soap_in_ns3__char(soap, NULL, NULL, "ns3:char");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns4__FieldCode:
		return soap_in_ns4__FieldCode(soap, NULL, NULL, "ns4:FieldCode");
	case SOAP_TYPE_ns4__UpdateCategory:
		return soap_in_ns4__UpdateCategory(soap, NULL, NULL, "ns4:UpdateCategory");
	case SOAP_TYPE_ns4__G8Action:
		return soap_in_ns4__G8Action(soap, NULL, NULL, "ns4:G8Action");
	case SOAP_TYPE_ns4__DataFormatEnum:
		return soap_in_ns4__DataFormatEnum(soap, NULL, NULL, "ns4:DataFormatEnum");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns5__ArrayOfbase64Binary:
		return soap_in_ns5__ArrayOfbase64Binary(soap, NULL, NULL, "ns5:ArrayOfbase64Binary");
	case SOAP_TYPE_ns4__ServerStatusInfo:
		return soap_in_ns4__ServerStatusInfo(soap, NULL, NULL, "ns4:ServerStatusInfo");
	case SOAP_TYPE_ns4__ArrayOfServerStatusInfo:
		return soap_in_ns4__ArrayOfServerStatusInfo(soap, NULL, NULL, "ns4:ArrayOfServerStatusInfo");
	case SOAP_TYPE_ns4__ArrayOfFieldPair:
		return soap_in_ns4__ArrayOfFieldPair(soap, NULL, NULL, "ns4:ArrayOfFieldPair");
	case SOAP_TYPE_ns4__FieldPair:
		return soap_in_ns4__FieldPair(soap, NULL, NULL, "ns4:FieldPair");
	case SOAP_TYPE_ns5__ArrayOfstring:
		return soap_in_ns5__ArrayOfstring(soap, NULL, NULL, "ns5:ArrayOfstring");
	case SOAP_TYPE_ns4__ArrayOfServerInfo:
		return soap_in_ns4__ArrayOfServerInfo(soap, NULL, NULL, "ns4:ArrayOfServerInfo");
	case SOAP_TYPE_ns4__InterfaceAddress:
		return soap_in_ns4__InterfaceAddress(soap, NULL, NULL, "ns4:InterfaceAddress");
	case SOAP_TYPE_ns4__ArrayOfInterfaceAddress:
		return soap_in_ns4__ArrayOfInterfaceAddress(soap, NULL, NULL, "ns4:ArrayOfInterfaceAddress");
	case SOAP_TYPE_ns4__UpdateServerStatusRequest:
		return soap_in_ns4__UpdateServerStatusRequest(soap, NULL, NULL, "ns4:UpdateServerStatusRequest");
	case SOAP_TYPE_ns4__UpdateInfoRequest:
		return soap_in_ns4__UpdateInfoRequest(soap, NULL, NULL, "ns4:UpdateInfoRequest");
	case SOAP_TYPE_ns4__UpdateDataServerVMRequest:
		return soap_in_ns4__UpdateDataServerVMRequest(soap, NULL, NULL, "ns4:UpdateDataServerVMRequest");
	case SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest:
		return soap_in_ns4__HandleServerPhysicalInfoRequest(soap, NULL, NULL, "ns4:HandleServerPhysicalInfoRequest");
	case SOAP_TYPE_ns4__ServerInfo:
		return soap_in_ns4__ServerInfo(soap, NULL, NULL, "ns4:ServerInfo");
	case SOAP_TYPE_ns4__SDKUpdateIpMacRequest:
		return soap_in_ns4__SDKUpdateIpMacRequest(soap, NULL, NULL, "ns4:SDKUpdateIpMacRequest");
	case SOAP_TYPE_ns4__SDKPostRequest:
		return soap_in_ns4__SDKPostRequest(soap, NULL, NULL, "ns4:SDKPostRequest");
	case SOAP_TYPE_ns4__RemoveDataServerVMRequest:
		return soap_in_ns4__RemoveDataServerVMRequest(soap, NULL, NULL, "ns4:RemoveDataServerVMRequest");
	case SOAP_TYPE_ns4__OpenIncidentByG8Request:
		return soap_in_ns4__OpenIncidentByG8Request(soap, NULL, NULL, "ns4:OpenIncidentByG8Request");
	case SOAP_TYPE_ns4__OpenIncidentByDCRequest:
		return soap_in_ns4__OpenIncidentByDCRequest(soap, NULL, NULL, "ns4:OpenIncidentByDCRequest");
	case SOAP_TYPE_ns4__OpenIncidentByCSRequest:
		return soap_in_ns4__OpenIncidentByCSRequest(soap, NULL, NULL, "ns4:OpenIncidentByCSRequest");
	case SOAP_TYPE_ns4__GetHostInfoByIPRequest:
		return soap_in_ns4__GetHostInfoByIPRequest(soap, NULL, NULL, "ns4:GetHostInfoByIPRequest");
	case SOAP_TYPE_ns4__GetItemValueListRequest:
		return soap_in_ns4__GetItemValueListRequest(soap, NULL, NULL, "ns4:GetItemValueListRequest");
	case SOAP_TYPE_ns4__InsertMeasuredDataRequest:
		return soap_in_ns4__InsertMeasuredDataRequest(soap, NULL, NULL, "ns4:InsertMeasuredDataRequest");
	case SOAP_TYPE_ns4__InsertDataServerVMRequest:
		return soap_in_ns4__InsertDataServerVMRequest(soap, NULL, NULL, "ns4:InsertDataServerVMRequest");
	case SOAP_TYPE_ns4__GetHostsInfoRequest:
		return soap_in_ns4__GetHostsInfoRequest(soap, NULL, NULL, "ns4:GetHostsInfoRequest");
	case SOAP_TYPE_ns4__HandleServerVMInfoRequest:
		return soap_in_ns4__HandleServerVMInfoRequest(soap, NULL, NULL, "ns4:HandleServerVMInfoRequest");
	case SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest:
		return soap_in_ns4__GetSnSInfoTechnicalOwnerRequest(soap, NULL, NULL, "ns4:GetSnSInfoTechnicalOwnerRequest");
	case SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest:
		return soap_in_ns4__GetServerNameBySerialNumberRequest(soap, NULL, NULL, "ns4:GetServerNameBySerialNumberRequest");
	case SOAP_TYPE_ns4__GetSO6InfoServerRequest:
		return soap_in_ns4__GetSO6InfoServerRequest(soap, NULL, NULL, "ns4:GetSO6InfoServerRequest");
	case SOAP_TYPE_ns4__GetSDKServerInfoListRequest:
		return soap_in_ns4__GetSDKServerInfoListRequest(soap, NULL, NULL, "ns4:GetSDKServerInfoListRequest");
	case SOAP_TYPE_ns4__GetProductInfoByIPRequest:
		return soap_in_ns4__GetProductInfoByIPRequest(soap, NULL, NULL, "ns4:GetProductInfoByIPRequest");
	case SOAP_TYPE_ns4__GetODAServerInfoListRequest:
		return soap_in_ns4__GetODAServerInfoListRequest(soap, NULL, NULL, "ns4:GetODAServerInfoListRequest");
	case SOAP_TYPE_ns4__GetODAHostInfoListRequest:
		return soap_in_ns4__GetODAHostInfoListRequest(soap, NULL, NULL, "ns4:GetODAHostInfoListRequest");
	case SOAP_TYPE_ns4__GetListAllServerRequest:
		return soap_in_ns4__GetListAllServerRequest(soap, NULL, NULL, "ns4:GetListAllServerRequest");
	case SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest:
		return soap_in_ns4__GetIRDTechnicalOwnerInfoRequest(soap, NULL, NULL, "ns4:GetIRDTechnicalOwnerInfoRequest");
	case SOAP_TYPE_ns4__GetIRDServerVMInfoRequest:
		return soap_in_ns4__GetIRDServerVMInfoRequest(soap, NULL, NULL, "ns4:GetIRDServerVMInfoRequest");
	case SOAP_TYPE_ns4__GetCCUByProductCodeRequest:
		return soap_in_ns4__GetCCUByProductCodeRequest(soap, NULL, NULL, "ns4:GetCCUByProductCodeRequest");
	case SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest:
		return soap_in_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, NULL, NULL, "ns4:CMDBv2_SDKUpdateIpMacRequest");
	case SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest:
		return soap_in_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, NULL, NULL, "ns4:CMDBV2_HandleServerVMInfoRequest");
	case SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest:
		return soap_in_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, NULL, NULL, "ns4:CMDBV2_GetServerDetailRequest");
	case SOAP_TYPE_ns4__GetGSOCCURequest:
		return soap_in_ns4__GetGSOCCURequest(soap, NULL, NULL, "ns4:GetGSOCCURequest");
	case SOAP_TYPE_ns4__SDKResponse:
		return soap_in_ns4__SDKResponse(soap, NULL, NULL, "ns4:SDKResponse");
	case SOAP_TYPE_ns4__SDKRequest:
		return soap_in_ns4__SDKRequest(soap, NULL, NULL, "ns4:SDKRequest");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__CallResponse:
		return soap_in_PointerTo_ns1__CallResponse(soap, NULL, NULL, "ns1:CallResponse");
	case SOAP_TYPE_PointerTo_ns1__Call:
		return soap_in_PointerTo_ns1__Call(soap, NULL, NULL, "ns1:Call");
	case SOAP_TYPE_PointerTons5__ArrayOfbase64Binary:
		return soap_in_PointerTons5__ArrayOfbase64Binary(soap, NULL, NULL, "ns5:ArrayOfbase64Binary");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons4__ServerStatusInfo:
		return soap_in_PointerTons4__ServerStatusInfo(soap, NULL, NULL, "ns4:ServerStatusInfo");
	case SOAP_TYPE_PointerTons4__ArrayOfServerStatusInfo:
		return soap_in_PointerTons4__ArrayOfServerStatusInfo(soap, NULL, NULL, "ns4:ArrayOfServerStatusInfo");
	case SOAP_TYPE_PointerTons4__FieldCode:
		return soap_in_PointerTons4__FieldCode(soap, NULL, NULL, "ns4:FieldCode");
	case SOAP_TYPE_PointerTons4__ArrayOfFieldPair:
		return soap_in_PointerTons4__ArrayOfFieldPair(soap, NULL, NULL, "ns4:ArrayOfFieldPair");
	case SOAP_TYPE_PointerTons4__FieldPair:
		return soap_in_PointerTons4__FieldPair(soap, NULL, NULL, "ns4:FieldPair");
	case SOAP_TYPE_PointerTons4__UpdateCategory:
		return soap_in_PointerTons4__UpdateCategory(soap, NULL, NULL, "ns4:UpdateCategory");
	case SOAP_TYPE_PointerTons4__G8Action:
		return soap_in_PointerTons4__G8Action(soap, NULL, NULL, "ns4:G8Action");
	case SOAP_TYPE_PointerTons5__ArrayOfstring:
		return soap_in_PointerTons5__ArrayOfstring(soap, NULL, NULL, "ns5:ArrayOfstring");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerTons4__ArrayOfServerInfo:
		return soap_in_PointerTons4__ArrayOfServerInfo(soap, NULL, NULL, "ns4:ArrayOfServerInfo");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTounsignedShort:
		return soap_in_PointerTounsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_PointerTons4__InterfaceAddress:
		return soap_in_PointerTons4__InterfaceAddress(soap, NULL, NULL, "ns4:InterfaceAddress");
	case SOAP_TYPE_PointerTons4__ArrayOfInterfaceAddress:
		return soap_in_PointerTons4__ArrayOfInterfaceAddress(soap, NULL, NULL, "ns4:ArrayOfInterfaceAddress");
	case SOAP_TYPE_PointerTons4__UpdateServerStatusRequest:
		return soap_in_PointerTons4__UpdateServerStatusRequest(soap, NULL, NULL, "ns4:UpdateServerStatusRequest");
	case SOAP_TYPE_PointerTons4__UpdateInfoRequest:
		return soap_in_PointerTons4__UpdateInfoRequest(soap, NULL, NULL, "ns4:UpdateInfoRequest");
	case SOAP_TYPE_PointerTons4__UpdateDataServerVMRequest:
		return soap_in_PointerTons4__UpdateDataServerVMRequest(soap, NULL, NULL, "ns4:UpdateDataServerVMRequest");
	case SOAP_TYPE_PointerTons4__HandleServerPhysicalInfoRequest:
		return soap_in_PointerTons4__HandleServerPhysicalInfoRequest(soap, NULL, NULL, "ns4:HandleServerPhysicalInfoRequest");
	case SOAP_TYPE_PointerTons4__ServerInfo:
		return soap_in_PointerTons4__ServerInfo(soap, NULL, NULL, "ns4:ServerInfo");
	case SOAP_TYPE_PointerTons4__SDKUpdateIpMacRequest:
		return soap_in_PointerTons4__SDKUpdateIpMacRequest(soap, NULL, NULL, "ns4:SDKUpdateIpMacRequest");
	case SOAP_TYPE_PointerTons4__SDKPostRequest:
		return soap_in_PointerTons4__SDKPostRequest(soap, NULL, NULL, "ns4:SDKPostRequest");
	case SOAP_TYPE_PointerTons4__RemoveDataServerVMRequest:
		return soap_in_PointerTons4__RemoveDataServerVMRequest(soap, NULL, NULL, "ns4:RemoveDataServerVMRequest");
	case SOAP_TYPE_PointerTons4__OpenIncidentByG8Request:
		return soap_in_PointerTons4__OpenIncidentByG8Request(soap, NULL, NULL, "ns4:OpenIncidentByG8Request");
	case SOAP_TYPE_PointerTons4__OpenIncidentByDCRequest:
		return soap_in_PointerTons4__OpenIncidentByDCRequest(soap, NULL, NULL, "ns4:OpenIncidentByDCRequest");
	case SOAP_TYPE_PointerTons4__OpenIncidentByCSRequest:
		return soap_in_PointerTons4__OpenIncidentByCSRequest(soap, NULL, NULL, "ns4:OpenIncidentByCSRequest");
	case SOAP_TYPE_PointerTons4__GetHostInfoByIPRequest:
		return soap_in_PointerTons4__GetHostInfoByIPRequest(soap, NULL, NULL, "ns4:GetHostInfoByIPRequest");
	case SOAP_TYPE_PointerTons4__GetItemValueListRequest:
		return soap_in_PointerTons4__GetItemValueListRequest(soap, NULL, NULL, "ns4:GetItemValueListRequest");
	case SOAP_TYPE_PointerTons4__InsertMeasuredDataRequest:
		return soap_in_PointerTons4__InsertMeasuredDataRequest(soap, NULL, NULL, "ns4:InsertMeasuredDataRequest");
	case SOAP_TYPE_PointerTons4__InsertDataServerVMRequest:
		return soap_in_PointerTons4__InsertDataServerVMRequest(soap, NULL, NULL, "ns4:InsertDataServerVMRequest");
	case SOAP_TYPE_PointerTons4__GetHostsInfoRequest:
		return soap_in_PointerTons4__GetHostsInfoRequest(soap, NULL, NULL, "ns4:GetHostsInfoRequest");
	case SOAP_TYPE_PointerTons4__HandleServerVMInfoRequest:
		return soap_in_PointerTons4__HandleServerVMInfoRequest(soap, NULL, NULL, "ns4:HandleServerVMInfoRequest");
	case SOAP_TYPE_PointerTons4__GetSnSInfoTechnicalOwnerRequest:
		return soap_in_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, NULL, NULL, "ns4:GetSnSInfoTechnicalOwnerRequest");
	case SOAP_TYPE_PointerTons4__GetServerNameBySerialNumberRequest:
		return soap_in_PointerTons4__GetServerNameBySerialNumberRequest(soap, NULL, NULL, "ns4:GetServerNameBySerialNumberRequest");
	case SOAP_TYPE_PointerTons4__GetSO6InfoServerRequest:
		return soap_in_PointerTons4__GetSO6InfoServerRequest(soap, NULL, NULL, "ns4:GetSO6InfoServerRequest");
	case SOAP_TYPE_PointerTons4__GetSDKServerInfoListRequest:
		return soap_in_PointerTons4__GetSDKServerInfoListRequest(soap, NULL, NULL, "ns4:GetSDKServerInfoListRequest");
	case SOAP_TYPE_PointerTons4__GetProductInfoByIPRequest:
		return soap_in_PointerTons4__GetProductInfoByIPRequest(soap, NULL, NULL, "ns4:GetProductInfoByIPRequest");
	case SOAP_TYPE_PointerTons4__GetODAServerInfoListRequest:
		return soap_in_PointerTons4__GetODAServerInfoListRequest(soap, NULL, NULL, "ns4:GetODAServerInfoListRequest");
	case SOAP_TYPE_PointerTons4__GetODAHostInfoListRequest:
		return soap_in_PointerTons4__GetODAHostInfoListRequest(soap, NULL, NULL, "ns4:GetODAHostInfoListRequest");
	case SOAP_TYPE_PointerTons4__GetListAllServerRequest:
		return soap_in_PointerTons4__GetListAllServerRequest(soap, NULL, NULL, "ns4:GetListAllServerRequest");
	case SOAP_TYPE_PointerTons4__GetIRDTechnicalOwnerInfoRequest:
		return soap_in_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, NULL, NULL, "ns4:GetIRDTechnicalOwnerInfoRequest");
	case SOAP_TYPE_PointerTons4__GetIRDServerVMInfoRequest:
		return soap_in_PointerTons4__GetIRDServerVMInfoRequest(soap, NULL, NULL, "ns4:GetIRDServerVMInfoRequest");
	case SOAP_TYPE_PointerTons4__GetCCUByProductCodeRequest:
		return soap_in_PointerTons4__GetCCUByProductCodeRequest(soap, NULL, NULL, "ns4:GetCCUByProductCodeRequest");
	case SOAP_TYPE_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest:
		return soap_in_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, NULL, NULL, "ns4:CMDBv2_SDKUpdateIpMacRequest");
	case SOAP_TYPE_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest:
		return soap_in_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, NULL, NULL, "ns4:CMDBV2_HandleServerVMInfoRequest");
	case SOAP_TYPE_PointerTons4__CMDBV2_USCOREGetServerDetailRequest:
		return soap_in_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, NULL, NULL, "ns4:CMDBV2_GetServerDetailRequest");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTons4__GetGSOCCURequest:
		return soap_in_PointerTons4__GetGSOCCURequest(soap, NULL, NULL, "ns4:GetGSOCCURequest");
	case SOAP_TYPE_PointerTons4__DataFormatEnum:
		return soap_in_PointerTons4__DataFormatEnum(soap, NULL, NULL, "ns4:DataFormatEnum");
	case SOAP_TYPE_PointerTons4__SDKResponse:
		return soap_in_PointerTons4__SDKResponse(soap, NULL, NULL, "ns4:SDKResponse");
	case SOAP_TYPE_PointerTons4__SDKRequest:
		return soap_in_PointerTons4__SDKRequest(soap, NULL, NULL, "ns4:SDKRequest");
	case SOAP_TYPE_ns3__guid:
	{	char **s;
		s = soap_in_ns3__guid(soap, NULL, NULL, "ns3:guid");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns3__duration:
	{	char **s;
		s = soap_in_ns3__duration(soap, NULL, NULL, "ns3:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__duration:
	{	char **s;
		s = soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__IDREF:
	{	char **s;
		s = soap_in_xsd__IDREF(soap, NULL, NULL, "xsd:IDREF");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__ID:
	{	char **s;
		s = soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:char"))
		{	*type = SOAP_TYPE_ns3__char;
			return soap_in_ns3__char(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FieldCode"))
		{	*type = SOAP_TYPE_ns4__FieldCode;
			return soap_in_ns4__FieldCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UpdateCategory"))
		{	*type = SOAP_TYPE_ns4__UpdateCategory;
			return soap_in_ns4__UpdateCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:G8Action"))
		{	*type = SOAP_TYPE_ns4__G8Action;
			return soap_in_ns4__G8Action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:DataFormatEnum"))
		{	*type = SOAP_TYPE_ns4__DataFormatEnum;
			return soap_in_ns4__DataFormatEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfbase64Binary"))
		{	*type = SOAP_TYPE_ns5__ArrayOfbase64Binary;
			return soap_in_ns5__ArrayOfbase64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ServerStatusInfo"))
		{	*type = SOAP_TYPE_ns4__ServerStatusInfo;
			return soap_in_ns4__ServerStatusInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfServerStatusInfo"))
		{	*type = SOAP_TYPE_ns4__ArrayOfServerStatusInfo;
			return soap_in_ns4__ArrayOfServerStatusInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfFieldPair"))
		{	*type = SOAP_TYPE_ns4__ArrayOfFieldPair;
			return soap_in_ns4__ArrayOfFieldPair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:FieldPair"))
		{	*type = SOAP_TYPE_ns4__FieldPair;
			return soap_in_ns4__FieldPair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfstring"))
		{	*type = SOAP_TYPE_ns5__ArrayOfstring;
			return soap_in_ns5__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfServerInfo"))
		{	*type = SOAP_TYPE_ns4__ArrayOfServerInfo;
			return soap_in_ns4__ArrayOfServerInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InterfaceAddress"))
		{	*type = SOAP_TYPE_ns4__InterfaceAddress;
			return soap_in_ns4__InterfaceAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfInterfaceAddress"))
		{	*type = SOAP_TYPE_ns4__ArrayOfInterfaceAddress;
			return soap_in_ns4__ArrayOfInterfaceAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UpdateServerStatusRequest"))
		{	*type = SOAP_TYPE_ns4__UpdateServerStatusRequest;
			return soap_in_ns4__UpdateServerStatusRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UpdateInfoRequest"))
		{	*type = SOAP_TYPE_ns4__UpdateInfoRequest;
			return soap_in_ns4__UpdateInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UpdateDataServerVMRequest"))
		{	*type = SOAP_TYPE_ns4__UpdateDataServerVMRequest;
			return soap_in_ns4__UpdateDataServerVMRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:HandleServerPhysicalInfoRequest"))
		{	*type = SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest;
			return soap_in_ns4__HandleServerPhysicalInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ServerInfo"))
		{	*type = SOAP_TYPE_ns4__ServerInfo;
			return soap_in_ns4__ServerInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SDKUpdateIpMacRequest"))
		{	*type = SOAP_TYPE_ns4__SDKUpdateIpMacRequest;
			return soap_in_ns4__SDKUpdateIpMacRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SDKPostRequest"))
		{	*type = SOAP_TYPE_ns4__SDKPostRequest;
			return soap_in_ns4__SDKPostRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:RemoveDataServerVMRequest"))
		{	*type = SOAP_TYPE_ns4__RemoveDataServerVMRequest;
			return soap_in_ns4__RemoveDataServerVMRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OpenIncidentByG8Request"))
		{	*type = SOAP_TYPE_ns4__OpenIncidentByG8Request;
			return soap_in_ns4__OpenIncidentByG8Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OpenIncidentByDCRequest"))
		{	*type = SOAP_TYPE_ns4__OpenIncidentByDCRequest;
			return soap_in_ns4__OpenIncidentByDCRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:OpenIncidentByCSRequest"))
		{	*type = SOAP_TYPE_ns4__OpenIncidentByCSRequest;
			return soap_in_ns4__OpenIncidentByCSRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetHostInfoByIPRequest"))
		{	*type = SOAP_TYPE_ns4__GetHostInfoByIPRequest;
			return soap_in_ns4__GetHostInfoByIPRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetItemValueListRequest"))
		{	*type = SOAP_TYPE_ns4__GetItemValueListRequest;
			return soap_in_ns4__GetItemValueListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InsertMeasuredDataRequest"))
		{	*type = SOAP_TYPE_ns4__InsertMeasuredDataRequest;
			return soap_in_ns4__InsertMeasuredDataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:InsertDataServerVMRequest"))
		{	*type = SOAP_TYPE_ns4__InsertDataServerVMRequest;
			return soap_in_ns4__InsertDataServerVMRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetHostsInfoRequest"))
		{	*type = SOAP_TYPE_ns4__GetHostsInfoRequest;
			return soap_in_ns4__GetHostsInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:HandleServerVMInfoRequest"))
		{	*type = SOAP_TYPE_ns4__HandleServerVMInfoRequest;
			return soap_in_ns4__HandleServerVMInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetSnSInfoTechnicalOwnerRequest"))
		{	*type = SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest;
			return soap_in_ns4__GetSnSInfoTechnicalOwnerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetServerNameBySerialNumberRequest"))
		{	*type = SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest;
			return soap_in_ns4__GetServerNameBySerialNumberRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetSO6InfoServerRequest"))
		{	*type = SOAP_TYPE_ns4__GetSO6InfoServerRequest;
			return soap_in_ns4__GetSO6InfoServerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetSDKServerInfoListRequest"))
		{	*type = SOAP_TYPE_ns4__GetSDKServerInfoListRequest;
			return soap_in_ns4__GetSDKServerInfoListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetProductInfoByIPRequest"))
		{	*type = SOAP_TYPE_ns4__GetProductInfoByIPRequest;
			return soap_in_ns4__GetProductInfoByIPRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetODAServerInfoListRequest"))
		{	*type = SOAP_TYPE_ns4__GetODAServerInfoListRequest;
			return soap_in_ns4__GetODAServerInfoListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetODAHostInfoListRequest"))
		{	*type = SOAP_TYPE_ns4__GetODAHostInfoListRequest;
			return soap_in_ns4__GetODAHostInfoListRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetListAllServerRequest"))
		{	*type = SOAP_TYPE_ns4__GetListAllServerRequest;
			return soap_in_ns4__GetListAllServerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetIRDTechnicalOwnerInfoRequest"))
		{	*type = SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest;
			return soap_in_ns4__GetIRDTechnicalOwnerInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetIRDServerVMInfoRequest"))
		{	*type = SOAP_TYPE_ns4__GetIRDServerVMInfoRequest;
			return soap_in_ns4__GetIRDServerVMInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetCCUByProductCodeRequest"))
		{	*type = SOAP_TYPE_ns4__GetCCUByProductCodeRequest;
			return soap_in_ns4__GetCCUByProductCodeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CMDBv2_SDKUpdateIpMacRequest"))
		{	*type = SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest;
			return soap_in_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CMDBV2_HandleServerVMInfoRequest"))
		{	*type = SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest;
			return soap_in_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:CMDBV2_GetServerDetailRequest"))
		{	*type = SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest;
			return soap_in_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:GetGSOCCURequest"))
		{	*type = SOAP_TYPE_ns4__GetGSOCCURequest;
			return soap_in_ns4__GetGSOCCURequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SDKResponse"))
		{	*type = SOAP_TYPE_ns4__SDKResponse;
			return soap_in_ns4__SDKResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SDKRequest"))
		{	*type = SOAP_TYPE_ns4__SDKRequest;
			return soap_in_ns4__SDKRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:guid"))
		{	char **s;
			*type = SOAP_TYPE_ns3__guid;
			s = soap_in_ns3__guid(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns3:duration"))
		{	char **s;
			*type = SOAP_TYPE_ns3__duration;
			s = soap_in_ns3__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	char **s;
			*type = SOAP_TYPE_xsd__duration;
			s = soap_in_xsd__duration(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	char **s;
			*type = SOAP_TYPE_xsd__IDREF;
			s = soap_in_xsd__IDREF(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	char **s;
			*type = SOAP_TYPE_xsd__ID;
			s = soap_in_xsd__ID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CallResponse"))
		{	*type = SOAP_TYPE__ns1__CallResponse;
			return soap_in__ns1__CallResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Call"))
		{	*type = SOAP_TYPE__ns1__Call;
			return soap_in__ns1__Call(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_ns3__char:
		return soap_out_ns3__char(soap, tag, id, (const int *)ptr, "ns3:char");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_ns4__FieldCode:
		return soap_out_ns4__FieldCode(soap, tag, id, (const enum ns4__FieldCode *)ptr, "ns4:FieldCode");
	case SOAP_TYPE_ns4__UpdateCategory:
		return soap_out_ns4__UpdateCategory(soap, tag, id, (const enum ns4__UpdateCategory *)ptr, "ns4:UpdateCategory");
	case SOAP_TYPE_ns4__G8Action:
		return soap_out_ns4__G8Action(soap, tag, id, (const enum ns4__G8Action *)ptr, "ns4:G8Action");
	case SOAP_TYPE_ns4__DataFormatEnum:
		return soap_out_ns4__DataFormatEnum(soap, tag, id, (const enum ns4__DataFormatEnum *)ptr, "ns4:DataFormatEnum");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns5__ArrayOfbase64Binary:
		return soap_out_ns5__ArrayOfbase64Binary(soap, tag, id, (const struct ns5__ArrayOfbase64Binary *)ptr, "ns5:ArrayOfbase64Binary");
	case SOAP_TYPE_ns4__ServerStatusInfo:
		return soap_out_ns4__ServerStatusInfo(soap, tag, id, (const struct ns4__ServerStatusInfo *)ptr, "ns4:ServerStatusInfo");
	case SOAP_TYPE_ns4__ArrayOfServerStatusInfo:
		return soap_out_ns4__ArrayOfServerStatusInfo(soap, tag, id, (const struct ns4__ArrayOfServerStatusInfo *)ptr, "ns4:ArrayOfServerStatusInfo");
	case SOAP_TYPE_ns4__ArrayOfFieldPair:
		return soap_out_ns4__ArrayOfFieldPair(soap, tag, id, (const struct ns4__ArrayOfFieldPair *)ptr, "ns4:ArrayOfFieldPair");
	case SOAP_TYPE_ns4__FieldPair:
		return soap_out_ns4__FieldPair(soap, tag, id, (const struct ns4__FieldPair *)ptr, "ns4:FieldPair");
	case SOAP_TYPE_ns5__ArrayOfstring:
		return soap_out_ns5__ArrayOfstring(soap, tag, id, (const struct ns5__ArrayOfstring *)ptr, "ns5:ArrayOfstring");
	case SOAP_TYPE_ns4__ArrayOfServerInfo:
		return soap_out_ns4__ArrayOfServerInfo(soap, tag, id, (const struct ns4__ArrayOfServerInfo *)ptr, "ns4:ArrayOfServerInfo");
	case SOAP_TYPE_ns4__InterfaceAddress:
		return soap_out_ns4__InterfaceAddress(soap, tag, id, (const struct ns4__InterfaceAddress *)ptr, "ns4:InterfaceAddress");
	case SOAP_TYPE_ns4__ArrayOfInterfaceAddress:
		return soap_out_ns4__ArrayOfInterfaceAddress(soap, tag, id, (const struct ns4__ArrayOfInterfaceAddress *)ptr, "ns4:ArrayOfInterfaceAddress");
	case SOAP_TYPE_ns4__UpdateServerStatusRequest:
		return soap_out_ns4__UpdateServerStatusRequest(soap, tag, id, (const struct ns4__UpdateServerStatusRequest *)ptr, "ns4:UpdateServerStatusRequest");
	case SOAP_TYPE_ns4__UpdateInfoRequest:
		return soap_out_ns4__UpdateInfoRequest(soap, tag, id, (const struct ns4__UpdateInfoRequest *)ptr, "ns4:UpdateInfoRequest");
	case SOAP_TYPE_ns4__UpdateDataServerVMRequest:
		return soap_out_ns4__UpdateDataServerVMRequest(soap, tag, id, (const struct ns4__UpdateDataServerVMRequest *)ptr, "ns4:UpdateDataServerVMRequest");
	case SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest:
		return soap_out_ns4__HandleServerPhysicalInfoRequest(soap, tag, id, (const struct ns4__HandleServerPhysicalInfoRequest *)ptr, "ns4:HandleServerPhysicalInfoRequest");
	case SOAP_TYPE_ns4__ServerInfo:
		return soap_out_ns4__ServerInfo(soap, tag, id, (const struct ns4__ServerInfo *)ptr, "ns4:ServerInfo");
	case SOAP_TYPE_ns4__SDKUpdateIpMacRequest:
		return soap_out_ns4__SDKUpdateIpMacRequest(soap, tag, id, (const struct ns4__SDKUpdateIpMacRequest *)ptr, "ns4:SDKUpdateIpMacRequest");
	case SOAP_TYPE_ns4__SDKPostRequest:
		return soap_out_ns4__SDKPostRequest(soap, tag, id, (const struct ns4__SDKPostRequest *)ptr, "ns4:SDKPostRequest");
	case SOAP_TYPE_ns4__RemoveDataServerVMRequest:
		return soap_out_ns4__RemoveDataServerVMRequest(soap, tag, id, (const struct ns4__RemoveDataServerVMRequest *)ptr, "ns4:RemoveDataServerVMRequest");
	case SOAP_TYPE_ns4__OpenIncidentByG8Request:
		return soap_out_ns4__OpenIncidentByG8Request(soap, tag, id, (const struct ns4__OpenIncidentByG8Request *)ptr, "ns4:OpenIncidentByG8Request");
	case SOAP_TYPE_ns4__OpenIncidentByDCRequest:
		return soap_out_ns4__OpenIncidentByDCRequest(soap, tag, id, (const struct ns4__OpenIncidentByDCRequest *)ptr, "ns4:OpenIncidentByDCRequest");
	case SOAP_TYPE_ns4__OpenIncidentByCSRequest:
		return soap_out_ns4__OpenIncidentByCSRequest(soap, tag, id, (const struct ns4__OpenIncidentByCSRequest *)ptr, "ns4:OpenIncidentByCSRequest");
	case SOAP_TYPE_ns4__GetHostInfoByIPRequest:
		return soap_out_ns4__GetHostInfoByIPRequest(soap, tag, id, (const struct ns4__GetHostInfoByIPRequest *)ptr, "ns4:GetHostInfoByIPRequest");
	case SOAP_TYPE_ns4__GetItemValueListRequest:
		return soap_out_ns4__GetItemValueListRequest(soap, tag, id, (const struct ns4__GetItemValueListRequest *)ptr, "ns4:GetItemValueListRequest");
	case SOAP_TYPE_ns4__InsertMeasuredDataRequest:
		return soap_out_ns4__InsertMeasuredDataRequest(soap, tag, id, (const struct ns4__InsertMeasuredDataRequest *)ptr, "ns4:InsertMeasuredDataRequest");
	case SOAP_TYPE_ns4__InsertDataServerVMRequest:
		return soap_out_ns4__InsertDataServerVMRequest(soap, tag, id, (const struct ns4__InsertDataServerVMRequest *)ptr, "ns4:InsertDataServerVMRequest");
	case SOAP_TYPE_ns4__GetHostsInfoRequest:
		return soap_out_ns4__GetHostsInfoRequest(soap, tag, id, (const struct ns4__GetHostsInfoRequest *)ptr, "ns4:GetHostsInfoRequest");
	case SOAP_TYPE_ns4__HandleServerVMInfoRequest:
		return soap_out_ns4__HandleServerVMInfoRequest(soap, tag, id, (const struct ns4__HandleServerVMInfoRequest *)ptr, "ns4:HandleServerVMInfoRequest");
	case SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest:
		return soap_out_ns4__GetSnSInfoTechnicalOwnerRequest(soap, tag, id, (const struct ns4__GetSnSInfoTechnicalOwnerRequest *)ptr, "ns4:GetSnSInfoTechnicalOwnerRequest");
	case SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest:
		return soap_out_ns4__GetServerNameBySerialNumberRequest(soap, tag, id, (const struct ns4__GetServerNameBySerialNumberRequest *)ptr, "ns4:GetServerNameBySerialNumberRequest");
	case SOAP_TYPE_ns4__GetSO6InfoServerRequest:
		return soap_out_ns4__GetSO6InfoServerRequest(soap, tag, id, (const struct ns4__GetSO6InfoServerRequest *)ptr, "ns4:GetSO6InfoServerRequest");
	case SOAP_TYPE_ns4__GetSDKServerInfoListRequest:
		return soap_out_ns4__GetSDKServerInfoListRequest(soap, tag, id, (const struct ns4__GetSDKServerInfoListRequest *)ptr, "ns4:GetSDKServerInfoListRequest");
	case SOAP_TYPE_ns4__GetProductInfoByIPRequest:
		return soap_out_ns4__GetProductInfoByIPRequest(soap, tag, id, (const struct ns4__GetProductInfoByIPRequest *)ptr, "ns4:GetProductInfoByIPRequest");
	case SOAP_TYPE_ns4__GetODAServerInfoListRequest:
		return soap_out_ns4__GetODAServerInfoListRequest(soap, tag, id, (const struct ns4__GetODAServerInfoListRequest *)ptr, "ns4:GetODAServerInfoListRequest");
	case SOAP_TYPE_ns4__GetODAHostInfoListRequest:
		return soap_out_ns4__GetODAHostInfoListRequest(soap, tag, id, (const struct ns4__GetODAHostInfoListRequest *)ptr, "ns4:GetODAHostInfoListRequest");
	case SOAP_TYPE_ns4__GetListAllServerRequest:
		return soap_out_ns4__GetListAllServerRequest(soap, tag, id, (const struct ns4__GetListAllServerRequest *)ptr, "ns4:GetListAllServerRequest");
	case SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest:
		return soap_out_ns4__GetIRDTechnicalOwnerInfoRequest(soap, tag, id, (const struct ns4__GetIRDTechnicalOwnerInfoRequest *)ptr, "ns4:GetIRDTechnicalOwnerInfoRequest");
	case SOAP_TYPE_ns4__GetIRDServerVMInfoRequest:
		return soap_out_ns4__GetIRDServerVMInfoRequest(soap, tag, id, (const struct ns4__GetIRDServerVMInfoRequest *)ptr, "ns4:GetIRDServerVMInfoRequest");
	case SOAP_TYPE_ns4__GetCCUByProductCodeRequest:
		return soap_out_ns4__GetCCUByProductCodeRequest(soap, tag, id, (const struct ns4__GetCCUByProductCodeRequest *)ptr, "ns4:GetCCUByProductCodeRequest");
	case SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest:
		return soap_out_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag, id, (const struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *)ptr, "ns4:CMDBv2_SDKUpdateIpMacRequest");
	case SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest:
		return soap_out_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag, id, (const struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *)ptr, "ns4:CMDBV2_HandleServerVMInfoRequest");
	case SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest:
		return soap_out_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, tag, id, (const struct ns4__CMDBV2_USCOREGetServerDetailRequest *)ptr, "ns4:CMDBV2_GetServerDetailRequest");
	case SOAP_TYPE_ns4__GetGSOCCURequest:
		return soap_out_ns4__GetGSOCCURequest(soap, tag, id, (const struct ns4__GetGSOCCURequest *)ptr, "ns4:GetGSOCCURequest");
	case SOAP_TYPE_ns4__SDKResponse:
		return soap_out_ns4__SDKResponse(soap, tag, id, (const struct ns4__SDKResponse *)ptr, "ns4:SDKResponse");
	case SOAP_TYPE__ns1__CallResponse:
		return soap_out__ns1__CallResponse(soap, "ns1:CallResponse", id, (const struct _ns1__CallResponse *)ptr, NULL);
	case SOAP_TYPE_ns4__SDKRequest:
		return soap_out_ns4__SDKRequest(soap, tag, id, (const struct ns4__SDKRequest *)ptr, "ns4:SDKRequest");
	case SOAP_TYPE__ns1__Call:
		return soap_out__ns1__Call(soap, "ns1:Call", id, (const struct _ns1__Call *)ptr, NULL);
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__CallResponse:
		return soap_out_PointerTo_ns1__CallResponse(soap, tag, id, (struct _ns1__CallResponse *const*)ptr, "ns1:CallResponse");
	case SOAP_TYPE_PointerTo_ns1__Call:
		return soap_out_PointerTo_ns1__Call(soap, tag, id, (struct _ns1__Call *const*)ptr, "ns1:Call");
	case SOAP_TYPE_PointerTons5__ArrayOfbase64Binary:
		return soap_out_PointerTons5__ArrayOfbase64Binary(soap, tag, id, (struct ns5__ArrayOfbase64Binary *const*)ptr, "ns5:ArrayOfbase64Binary");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (struct xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons4__ServerStatusInfo:
		return soap_out_PointerTons4__ServerStatusInfo(soap, tag, id, (struct ns4__ServerStatusInfo *const*)ptr, "ns4:ServerStatusInfo");
	case SOAP_TYPE_PointerTons4__ArrayOfServerStatusInfo:
		return soap_out_PointerTons4__ArrayOfServerStatusInfo(soap, tag, id, (struct ns4__ArrayOfServerStatusInfo *const*)ptr, "ns4:ArrayOfServerStatusInfo");
	case SOAP_TYPE_PointerTons4__FieldCode:
		return soap_out_PointerTons4__FieldCode(soap, tag, id, (enum ns4__FieldCode *const*)ptr, "ns4:FieldCode");
	case SOAP_TYPE_PointerTons4__ArrayOfFieldPair:
		return soap_out_PointerTons4__ArrayOfFieldPair(soap, tag, id, (struct ns4__ArrayOfFieldPair *const*)ptr, "ns4:ArrayOfFieldPair");
	case SOAP_TYPE_PointerTons4__FieldPair:
		return soap_out_PointerTons4__FieldPair(soap, tag, id, (struct ns4__FieldPair *const*)ptr, "ns4:FieldPair");
	case SOAP_TYPE_PointerTons4__UpdateCategory:
		return soap_out_PointerTons4__UpdateCategory(soap, tag, id, (enum ns4__UpdateCategory *const*)ptr, "ns4:UpdateCategory");
	case SOAP_TYPE_PointerTons4__G8Action:
		return soap_out_PointerTons4__G8Action(soap, tag, id, (enum ns4__G8Action *const*)ptr, "ns4:G8Action");
	case SOAP_TYPE_PointerTons5__ArrayOfstring:
		return soap_out_PointerTons5__ArrayOfstring(soap, tag, id, (struct ns5__ArrayOfstring *const*)ptr, "ns5:ArrayOfstring");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTons4__ArrayOfServerInfo:
		return soap_out_PointerTons4__ArrayOfServerInfo(soap, tag, id, (struct ns4__ArrayOfServerInfo *const*)ptr, "ns4:ArrayOfServerInfo");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTounsignedShort:
		return soap_out_PointerTounsignedShort(soap, tag, id, (unsigned short *const*)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_PointerTons4__InterfaceAddress:
		return soap_out_PointerTons4__InterfaceAddress(soap, tag, id, (struct ns4__InterfaceAddress *const*)ptr, "ns4:InterfaceAddress");
	case SOAP_TYPE_PointerTons4__ArrayOfInterfaceAddress:
		return soap_out_PointerTons4__ArrayOfInterfaceAddress(soap, tag, id, (struct ns4__ArrayOfInterfaceAddress *const*)ptr, "ns4:ArrayOfInterfaceAddress");
	case SOAP_TYPE_PointerTons4__UpdateServerStatusRequest:
		return soap_out_PointerTons4__UpdateServerStatusRequest(soap, tag, id, (struct ns4__UpdateServerStatusRequest *const*)ptr, "ns4:UpdateServerStatusRequest");
	case SOAP_TYPE_PointerTons4__UpdateInfoRequest:
		return soap_out_PointerTons4__UpdateInfoRequest(soap, tag, id, (struct ns4__UpdateInfoRequest *const*)ptr, "ns4:UpdateInfoRequest");
	case SOAP_TYPE_PointerTons4__UpdateDataServerVMRequest:
		return soap_out_PointerTons4__UpdateDataServerVMRequest(soap, tag, id, (struct ns4__UpdateDataServerVMRequest *const*)ptr, "ns4:UpdateDataServerVMRequest");
	case SOAP_TYPE_PointerTons4__HandleServerPhysicalInfoRequest:
		return soap_out_PointerTons4__HandleServerPhysicalInfoRequest(soap, tag, id, (struct ns4__HandleServerPhysicalInfoRequest *const*)ptr, "ns4:HandleServerPhysicalInfoRequest");
	case SOAP_TYPE_PointerTons4__ServerInfo:
		return soap_out_PointerTons4__ServerInfo(soap, tag, id, (struct ns4__ServerInfo *const*)ptr, "ns4:ServerInfo");
	case SOAP_TYPE_PointerTons4__SDKUpdateIpMacRequest:
		return soap_out_PointerTons4__SDKUpdateIpMacRequest(soap, tag, id, (struct ns4__SDKUpdateIpMacRequest *const*)ptr, "ns4:SDKUpdateIpMacRequest");
	case SOAP_TYPE_PointerTons4__SDKPostRequest:
		return soap_out_PointerTons4__SDKPostRequest(soap, tag, id, (struct ns4__SDKPostRequest *const*)ptr, "ns4:SDKPostRequest");
	case SOAP_TYPE_PointerTons4__RemoveDataServerVMRequest:
		return soap_out_PointerTons4__RemoveDataServerVMRequest(soap, tag, id, (struct ns4__RemoveDataServerVMRequest *const*)ptr, "ns4:RemoveDataServerVMRequest");
	case SOAP_TYPE_PointerTons4__OpenIncidentByG8Request:
		return soap_out_PointerTons4__OpenIncidentByG8Request(soap, tag, id, (struct ns4__OpenIncidentByG8Request *const*)ptr, "ns4:OpenIncidentByG8Request");
	case SOAP_TYPE_PointerTons4__OpenIncidentByDCRequest:
		return soap_out_PointerTons4__OpenIncidentByDCRequest(soap, tag, id, (struct ns4__OpenIncidentByDCRequest *const*)ptr, "ns4:OpenIncidentByDCRequest");
	case SOAP_TYPE_PointerTons4__OpenIncidentByCSRequest:
		return soap_out_PointerTons4__OpenIncidentByCSRequest(soap, tag, id, (struct ns4__OpenIncidentByCSRequest *const*)ptr, "ns4:OpenIncidentByCSRequest");
	case SOAP_TYPE_PointerTons4__GetHostInfoByIPRequest:
		return soap_out_PointerTons4__GetHostInfoByIPRequest(soap, tag, id, (struct ns4__GetHostInfoByIPRequest *const*)ptr, "ns4:GetHostInfoByIPRequest");
	case SOAP_TYPE_PointerTons4__GetItemValueListRequest:
		return soap_out_PointerTons4__GetItemValueListRequest(soap, tag, id, (struct ns4__GetItemValueListRequest *const*)ptr, "ns4:GetItemValueListRequest");
	case SOAP_TYPE_PointerTons4__InsertMeasuredDataRequest:
		return soap_out_PointerTons4__InsertMeasuredDataRequest(soap, tag, id, (struct ns4__InsertMeasuredDataRequest *const*)ptr, "ns4:InsertMeasuredDataRequest");
	case SOAP_TYPE_PointerTons4__InsertDataServerVMRequest:
		return soap_out_PointerTons4__InsertDataServerVMRequest(soap, tag, id, (struct ns4__InsertDataServerVMRequest *const*)ptr, "ns4:InsertDataServerVMRequest");
	case SOAP_TYPE_PointerTons4__GetHostsInfoRequest:
		return soap_out_PointerTons4__GetHostsInfoRequest(soap, tag, id, (struct ns4__GetHostsInfoRequest *const*)ptr, "ns4:GetHostsInfoRequest");
	case SOAP_TYPE_PointerTons4__HandleServerVMInfoRequest:
		return soap_out_PointerTons4__HandleServerVMInfoRequest(soap, tag, id, (struct ns4__HandleServerVMInfoRequest *const*)ptr, "ns4:HandleServerVMInfoRequest");
	case SOAP_TYPE_PointerTons4__GetSnSInfoTechnicalOwnerRequest:
		return soap_out_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, tag, id, (struct ns4__GetSnSInfoTechnicalOwnerRequest *const*)ptr, "ns4:GetSnSInfoTechnicalOwnerRequest");
	case SOAP_TYPE_PointerTons4__GetServerNameBySerialNumberRequest:
		return soap_out_PointerTons4__GetServerNameBySerialNumberRequest(soap, tag, id, (struct ns4__GetServerNameBySerialNumberRequest *const*)ptr, "ns4:GetServerNameBySerialNumberRequest");
	case SOAP_TYPE_PointerTons4__GetSO6InfoServerRequest:
		return soap_out_PointerTons4__GetSO6InfoServerRequest(soap, tag, id, (struct ns4__GetSO6InfoServerRequest *const*)ptr, "ns4:GetSO6InfoServerRequest");
	case SOAP_TYPE_PointerTons4__GetSDKServerInfoListRequest:
		return soap_out_PointerTons4__GetSDKServerInfoListRequest(soap, tag, id, (struct ns4__GetSDKServerInfoListRequest *const*)ptr, "ns4:GetSDKServerInfoListRequest");
	case SOAP_TYPE_PointerTons4__GetProductInfoByIPRequest:
		return soap_out_PointerTons4__GetProductInfoByIPRequest(soap, tag, id, (struct ns4__GetProductInfoByIPRequest *const*)ptr, "ns4:GetProductInfoByIPRequest");
	case SOAP_TYPE_PointerTons4__GetODAServerInfoListRequest:
		return soap_out_PointerTons4__GetODAServerInfoListRequest(soap, tag, id, (struct ns4__GetODAServerInfoListRequest *const*)ptr, "ns4:GetODAServerInfoListRequest");
	case SOAP_TYPE_PointerTons4__GetODAHostInfoListRequest:
		return soap_out_PointerTons4__GetODAHostInfoListRequest(soap, tag, id, (struct ns4__GetODAHostInfoListRequest *const*)ptr, "ns4:GetODAHostInfoListRequest");
	case SOAP_TYPE_PointerTons4__GetListAllServerRequest:
		return soap_out_PointerTons4__GetListAllServerRequest(soap, tag, id, (struct ns4__GetListAllServerRequest *const*)ptr, "ns4:GetListAllServerRequest");
	case SOAP_TYPE_PointerTons4__GetIRDTechnicalOwnerInfoRequest:
		return soap_out_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, tag, id, (struct ns4__GetIRDTechnicalOwnerInfoRequest *const*)ptr, "ns4:GetIRDTechnicalOwnerInfoRequest");
	case SOAP_TYPE_PointerTons4__GetIRDServerVMInfoRequest:
		return soap_out_PointerTons4__GetIRDServerVMInfoRequest(soap, tag, id, (struct ns4__GetIRDServerVMInfoRequest *const*)ptr, "ns4:GetIRDServerVMInfoRequest");
	case SOAP_TYPE_PointerTons4__GetCCUByProductCodeRequest:
		return soap_out_PointerTons4__GetCCUByProductCodeRequest(soap, tag, id, (struct ns4__GetCCUByProductCodeRequest *const*)ptr, "ns4:GetCCUByProductCodeRequest");
	case SOAP_TYPE_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest:
		return soap_out_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag, id, (struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *const*)ptr, "ns4:CMDBv2_SDKUpdateIpMacRequest");
	case SOAP_TYPE_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest:
		return soap_out_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag, id, (struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *const*)ptr, "ns4:CMDBV2_HandleServerVMInfoRequest");
	case SOAP_TYPE_PointerTons4__CMDBV2_USCOREGetServerDetailRequest:
		return soap_out_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, tag, id, (struct ns4__CMDBV2_USCOREGetServerDetailRequest *const*)ptr, "ns4:CMDBV2_GetServerDetailRequest");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTons4__GetGSOCCURequest:
		return soap_out_PointerTons4__GetGSOCCURequest(soap, tag, id, (struct ns4__GetGSOCCURequest *const*)ptr, "ns4:GetGSOCCURequest");
	case SOAP_TYPE_PointerTons4__DataFormatEnum:
		return soap_out_PointerTons4__DataFormatEnum(soap, tag, id, (enum ns4__DataFormatEnum *const*)ptr, "ns4:DataFormatEnum");
	case SOAP_TYPE_PointerTons4__SDKResponse:
		return soap_out_PointerTons4__SDKResponse(soap, tag, id, (struct ns4__SDKResponse *const*)ptr, "ns4:SDKResponse");
	case SOAP_TYPE_PointerTons4__SDKRequest:
		return soap_out_PointerTons4__SDKRequest(soap, tag, id, (struct ns4__SDKRequest *const*)ptr, "ns4:SDKRequest");
	case SOAP_TYPE_ns3__guid:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:guid");
	case SOAP_TYPE_ns3__duration:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "ns3:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:duration");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__IDREF:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:ID");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__Call:
		soap_serialize___ns1__Call(soap, (const struct __ns1__Call *)ptr);
		break;
	case SOAP_TYPE_ns5__ArrayOfbase64Binary:
		soap_serialize_ns5__ArrayOfbase64Binary(soap, (const struct ns5__ArrayOfbase64Binary *)ptr);
		break;
	case SOAP_TYPE_ns4__ServerStatusInfo:
		soap_serialize_ns4__ServerStatusInfo(soap, (const struct ns4__ServerStatusInfo *)ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfServerStatusInfo:
		soap_serialize_ns4__ArrayOfServerStatusInfo(soap, (const struct ns4__ArrayOfServerStatusInfo *)ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfFieldPair:
		soap_serialize_ns4__ArrayOfFieldPair(soap, (const struct ns4__ArrayOfFieldPair *)ptr);
		break;
	case SOAP_TYPE_ns4__FieldPair:
		soap_serialize_ns4__FieldPair(soap, (const struct ns4__FieldPair *)ptr);
		break;
	case SOAP_TYPE_ns5__ArrayOfstring:
		soap_serialize_ns5__ArrayOfstring(soap, (const struct ns5__ArrayOfstring *)ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfServerInfo:
		soap_serialize_ns4__ArrayOfServerInfo(soap, (const struct ns4__ArrayOfServerInfo *)ptr);
		break;
	case SOAP_TYPE_ns4__InterfaceAddress:
		soap_serialize_ns4__InterfaceAddress(soap, (const struct ns4__InterfaceAddress *)ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfInterfaceAddress:
		soap_serialize_ns4__ArrayOfInterfaceAddress(soap, (const struct ns4__ArrayOfInterfaceAddress *)ptr);
		break;
	case SOAP_TYPE_ns4__UpdateServerStatusRequest:
		soap_serialize_ns4__UpdateServerStatusRequest(soap, (const struct ns4__UpdateServerStatusRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__UpdateInfoRequest:
		soap_serialize_ns4__UpdateInfoRequest(soap, (const struct ns4__UpdateInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__UpdateDataServerVMRequest:
		soap_serialize_ns4__UpdateDataServerVMRequest(soap, (const struct ns4__UpdateDataServerVMRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest:
		soap_serialize_ns4__HandleServerPhysicalInfoRequest(soap, (const struct ns4__HandleServerPhysicalInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__ServerInfo:
		soap_serialize_ns4__ServerInfo(soap, (const struct ns4__ServerInfo *)ptr);
		break;
	case SOAP_TYPE_ns4__SDKUpdateIpMacRequest:
		soap_serialize_ns4__SDKUpdateIpMacRequest(soap, (const struct ns4__SDKUpdateIpMacRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__SDKPostRequest:
		soap_serialize_ns4__SDKPostRequest(soap, (const struct ns4__SDKPostRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__RemoveDataServerVMRequest:
		soap_serialize_ns4__RemoveDataServerVMRequest(soap, (const struct ns4__RemoveDataServerVMRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__OpenIncidentByG8Request:
		soap_serialize_ns4__OpenIncidentByG8Request(soap, (const struct ns4__OpenIncidentByG8Request *)ptr);
		break;
	case SOAP_TYPE_ns4__OpenIncidentByDCRequest:
		soap_serialize_ns4__OpenIncidentByDCRequest(soap, (const struct ns4__OpenIncidentByDCRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__OpenIncidentByCSRequest:
		soap_serialize_ns4__OpenIncidentByCSRequest(soap, (const struct ns4__OpenIncidentByCSRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetHostInfoByIPRequest:
		soap_serialize_ns4__GetHostInfoByIPRequest(soap, (const struct ns4__GetHostInfoByIPRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetItemValueListRequest:
		soap_serialize_ns4__GetItemValueListRequest(soap, (const struct ns4__GetItemValueListRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__InsertMeasuredDataRequest:
		soap_serialize_ns4__InsertMeasuredDataRequest(soap, (const struct ns4__InsertMeasuredDataRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__InsertDataServerVMRequest:
		soap_serialize_ns4__InsertDataServerVMRequest(soap, (const struct ns4__InsertDataServerVMRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetHostsInfoRequest:
		soap_serialize_ns4__GetHostsInfoRequest(soap, (const struct ns4__GetHostsInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__HandleServerVMInfoRequest:
		soap_serialize_ns4__HandleServerVMInfoRequest(soap, (const struct ns4__HandleServerVMInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest:
		soap_serialize_ns4__GetSnSInfoTechnicalOwnerRequest(soap, (const struct ns4__GetSnSInfoTechnicalOwnerRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest:
		soap_serialize_ns4__GetServerNameBySerialNumberRequest(soap, (const struct ns4__GetServerNameBySerialNumberRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetSO6InfoServerRequest:
		soap_serialize_ns4__GetSO6InfoServerRequest(soap, (const struct ns4__GetSO6InfoServerRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetSDKServerInfoListRequest:
		soap_serialize_ns4__GetSDKServerInfoListRequest(soap, (const struct ns4__GetSDKServerInfoListRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetProductInfoByIPRequest:
		soap_serialize_ns4__GetProductInfoByIPRequest(soap, (const struct ns4__GetProductInfoByIPRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetODAServerInfoListRequest:
		soap_serialize_ns4__GetODAServerInfoListRequest(soap, (const struct ns4__GetODAServerInfoListRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetODAHostInfoListRequest:
		soap_serialize_ns4__GetODAHostInfoListRequest(soap, (const struct ns4__GetODAHostInfoListRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetListAllServerRequest:
		soap_serialize_ns4__GetListAllServerRequest(soap, (const struct ns4__GetListAllServerRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest:
		soap_serialize_ns4__GetIRDTechnicalOwnerInfoRequest(soap, (const struct ns4__GetIRDTechnicalOwnerInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetIRDServerVMInfoRequest:
		soap_serialize_ns4__GetIRDServerVMInfoRequest(soap, (const struct ns4__GetIRDServerVMInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetCCUByProductCodeRequest:
		soap_serialize_ns4__GetCCUByProductCodeRequest(soap, (const struct ns4__GetCCUByProductCodeRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest:
		soap_serialize_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, (const struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest:
		soap_serialize_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, (const struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest:
		soap_serialize_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, (const struct ns4__CMDBV2_USCOREGetServerDetailRequest *)ptr);
		break;
	case SOAP_TYPE_ns4__GetGSOCCURequest:
		soap_serialize_ns4__GetGSOCCURequest(soap, (const struct ns4__GetGSOCCURequest *)ptr);
		break;
	case SOAP_TYPE_ns4__SDKResponse:
		soap_serialize_ns4__SDKResponse(soap, (const struct ns4__SDKResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__CallResponse:
		soap_serialize__ns1__CallResponse(soap, (const struct _ns1__CallResponse *)ptr);
		break;
	case SOAP_TYPE_ns4__SDKRequest:
		soap_serialize_ns4__SDKRequest(soap, (const struct ns4__SDKRequest *)ptr);
		break;
	case SOAP_TYPE__ns1__Call:
		soap_serialize__ns1__Call(soap, (const struct _ns1__Call *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CallResponse:
		soap_serialize_PointerTo_ns1__CallResponse(soap, (struct _ns1__CallResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Call:
		soap_serialize_PointerTo_ns1__Call(soap, (struct _ns1__Call *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ArrayOfbase64Binary:
		soap_serialize_PointerTons5__ArrayOfbase64Binary(soap, (struct ns5__ArrayOfbase64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (struct xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ServerStatusInfo:
		soap_serialize_PointerTons4__ServerStatusInfo(soap, (struct ns4__ServerStatusInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfServerStatusInfo:
		soap_serialize_PointerTons4__ArrayOfServerStatusInfo(soap, (struct ns4__ArrayOfServerStatusInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FieldCode:
		soap_serialize_PointerTons4__FieldCode(soap, (enum ns4__FieldCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfFieldPair:
		soap_serialize_PointerTons4__ArrayOfFieldPair(soap, (struct ns4__ArrayOfFieldPair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__FieldPair:
		soap_serialize_PointerTons4__FieldPair(soap, (struct ns4__FieldPair *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UpdateCategory:
		soap_serialize_PointerTons4__UpdateCategory(soap, (enum ns4__UpdateCategory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__G8Action:
		soap_serialize_PointerTons4__G8Action(soap, (enum ns4__G8Action *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ArrayOfstring:
		soap_serialize_PointerTons5__ArrayOfstring(soap, (struct ns5__ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfServerInfo:
		soap_serialize_PointerTons4__ArrayOfServerInfo(soap, (struct ns4__ArrayOfServerInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedShort:
		soap_serialize_PointerTounsignedShort(soap, (unsigned short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__InterfaceAddress:
		soap_serialize_PointerTons4__InterfaceAddress(soap, (struct ns4__InterfaceAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfInterfaceAddress:
		soap_serialize_PointerTons4__ArrayOfInterfaceAddress(soap, (struct ns4__ArrayOfInterfaceAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UpdateServerStatusRequest:
		soap_serialize_PointerTons4__UpdateServerStatusRequest(soap, (struct ns4__UpdateServerStatusRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UpdateInfoRequest:
		soap_serialize_PointerTons4__UpdateInfoRequest(soap, (struct ns4__UpdateInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UpdateDataServerVMRequest:
		soap_serialize_PointerTons4__UpdateDataServerVMRequest(soap, (struct ns4__UpdateDataServerVMRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__HandleServerPhysicalInfoRequest:
		soap_serialize_PointerTons4__HandleServerPhysicalInfoRequest(soap, (struct ns4__HandleServerPhysicalInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ServerInfo:
		soap_serialize_PointerTons4__ServerInfo(soap, (struct ns4__ServerInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SDKUpdateIpMacRequest:
		soap_serialize_PointerTons4__SDKUpdateIpMacRequest(soap, (struct ns4__SDKUpdateIpMacRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SDKPostRequest:
		soap_serialize_PointerTons4__SDKPostRequest(soap, (struct ns4__SDKPostRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__RemoveDataServerVMRequest:
		soap_serialize_PointerTons4__RemoveDataServerVMRequest(soap, (struct ns4__RemoveDataServerVMRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OpenIncidentByG8Request:
		soap_serialize_PointerTons4__OpenIncidentByG8Request(soap, (struct ns4__OpenIncidentByG8Request *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OpenIncidentByDCRequest:
		soap_serialize_PointerTons4__OpenIncidentByDCRequest(soap, (struct ns4__OpenIncidentByDCRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__OpenIncidentByCSRequest:
		soap_serialize_PointerTons4__OpenIncidentByCSRequest(soap, (struct ns4__OpenIncidentByCSRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetHostInfoByIPRequest:
		soap_serialize_PointerTons4__GetHostInfoByIPRequest(soap, (struct ns4__GetHostInfoByIPRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetItemValueListRequest:
		soap_serialize_PointerTons4__GetItemValueListRequest(soap, (struct ns4__GetItemValueListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__InsertMeasuredDataRequest:
		soap_serialize_PointerTons4__InsertMeasuredDataRequest(soap, (struct ns4__InsertMeasuredDataRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__InsertDataServerVMRequest:
		soap_serialize_PointerTons4__InsertDataServerVMRequest(soap, (struct ns4__InsertDataServerVMRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetHostsInfoRequest:
		soap_serialize_PointerTons4__GetHostsInfoRequest(soap, (struct ns4__GetHostsInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__HandleServerVMInfoRequest:
		soap_serialize_PointerTons4__HandleServerVMInfoRequest(soap, (struct ns4__HandleServerVMInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetSnSInfoTechnicalOwnerRequest:
		soap_serialize_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, (struct ns4__GetSnSInfoTechnicalOwnerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetServerNameBySerialNumberRequest:
		soap_serialize_PointerTons4__GetServerNameBySerialNumberRequest(soap, (struct ns4__GetServerNameBySerialNumberRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetSO6InfoServerRequest:
		soap_serialize_PointerTons4__GetSO6InfoServerRequest(soap, (struct ns4__GetSO6InfoServerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetSDKServerInfoListRequest:
		soap_serialize_PointerTons4__GetSDKServerInfoListRequest(soap, (struct ns4__GetSDKServerInfoListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetProductInfoByIPRequest:
		soap_serialize_PointerTons4__GetProductInfoByIPRequest(soap, (struct ns4__GetProductInfoByIPRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetODAServerInfoListRequest:
		soap_serialize_PointerTons4__GetODAServerInfoListRequest(soap, (struct ns4__GetODAServerInfoListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetODAHostInfoListRequest:
		soap_serialize_PointerTons4__GetODAHostInfoListRequest(soap, (struct ns4__GetODAHostInfoListRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetListAllServerRequest:
		soap_serialize_PointerTons4__GetListAllServerRequest(soap, (struct ns4__GetListAllServerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetIRDTechnicalOwnerInfoRequest:
		soap_serialize_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, (struct ns4__GetIRDTechnicalOwnerInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetIRDServerVMInfoRequest:
		soap_serialize_PointerTons4__GetIRDServerVMInfoRequest(soap, (struct ns4__GetIRDServerVMInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetCCUByProductCodeRequest:
		soap_serialize_PointerTons4__GetCCUByProductCodeRequest(soap, (struct ns4__GetCCUByProductCodeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest:
		soap_serialize_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, (struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest:
		soap_serialize_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, (struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__CMDBV2_USCOREGetServerDetailRequest:
		soap_serialize_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, (struct ns4__CMDBV2_USCOREGetServerDetailRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__GetGSOCCURequest:
		soap_serialize_PointerTons4__GetGSOCCURequest(soap, (struct ns4__GetGSOCCURequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__DataFormatEnum:
		soap_serialize_PointerTons4__DataFormatEnum(soap, (enum ns4__DataFormatEnum *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SDKResponse:
		soap_serialize_PointerTons4__SDKResponse(soap, (struct ns4__SDKResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__SDKRequest:
		soap_serialize_PointerTons4__SDKRequest(soap, (struct ns4__SDKRequest *const*)ptr);
		break;
	case SOAP_TYPE_ns3__guid:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ns3__duration:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__IDREF:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag?tag:"xsd:byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__char(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns3__char);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns3__char(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns3__char);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__char(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__char);
	if (soap_out_ns3__char(soap, tag?tag:"ns3:char", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns3__char(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__char(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (soap_out_xsd__unsignedByte(soap, tag?tag:"xsd:unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{	unsigned short *p;
	p = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag?tag:"unsignedShort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FieldCode(struct soap *soap, enum ns4__FieldCode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__FieldCode
	*a = SOAP_DEFAULT_ns4__FieldCode;
#else
	*a = (enum ns4__FieldCode)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__FieldCode[] =
{	{ (long)ns4__FieldCode__SerialNumber, "SerialNumber" },
	{ (long)ns4__FieldCode__ServerName, "ServerName" },
	{ (long)ns4__FieldCode__PublicIP, "PublicIP" },
	{ (long)ns4__FieldCode__PublicMAC, "PublicMAC" },
	{ (long)ns4__FieldCode__PrivateIP, "PrivateIP" },
	{ (long)ns4__FieldCode__PrivateMAC, "PrivateMAC" },
	{ (long)ns4__FieldCode__VirtualIP, "VirtualIP" },
	{ (long)ns4__FieldCode__VirtualMAC, "VirtualMAC" },
	{ (long)ns4__FieldCode__OSVersion, "OSVersion" },
	{ (long)ns4__FieldCode__SoftwareList, "SoftwareList" },
	{ (long)ns4__FieldCode__ServerStatus, "ServerStatus" },
	{ (long)ns4__FieldCode__ServerKey, "ServerKey" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__FieldCode2s(struct soap *soap, enum ns4__FieldCode n)
{	const char *s = soap_code_str(soap_codes_ns4__FieldCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FieldCode(struct soap *soap, const char *tag, int id, const enum ns4__FieldCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FieldCode), type) || soap_send(soap, soap_ns4__FieldCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__FieldCode(struct soap *soap, const char *s, enum ns4__FieldCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__FieldCode, s);
	if (map)
		*a = (enum ns4__FieldCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__FieldCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__FieldCode * SOAP_FMAC4 soap_in_ns4__FieldCode(struct soap *soap, const char *tag, enum ns4__FieldCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__FieldCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FieldCode, sizeof(enum ns4__FieldCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__FieldCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__FieldCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FieldCode, 0, sizeof(enum ns4__FieldCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FieldCode(struct soap *soap, const enum ns4__FieldCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__FieldCode);
	if (soap_out_ns4__FieldCode(soap, tag?tag:"ns4:FieldCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__FieldCode * SOAP_FMAC4 soap_get_ns4__FieldCode(struct soap *soap, enum ns4__FieldCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FieldCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UpdateCategory(struct soap *soap, enum ns4__UpdateCategory *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__UpdateCategory
	*a = SOAP_DEFAULT_ns4__UpdateCategory;
#else
	*a = (enum ns4__UpdateCategory)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__UpdateCategory[] =
{	{ (long)ns4__UpdateCategory__CMDB, "CMDB" },
	{ (long)ns4__UpdateCategory__SERVER_USCOREUSED_USCORESTATUS, "SERVER_USED_STATUS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__UpdateCategory2s(struct soap *soap, enum ns4__UpdateCategory n)
{	const char *s = soap_code_str(soap_codes_ns4__UpdateCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UpdateCategory(struct soap *soap, const char *tag, int id, const enum ns4__UpdateCategory *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UpdateCategory), type) || soap_send(soap, soap_ns4__UpdateCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__UpdateCategory(struct soap *soap, const char *s, enum ns4__UpdateCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__UpdateCategory, s);
	if (map)
		*a = (enum ns4__UpdateCategory)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__UpdateCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__UpdateCategory * SOAP_FMAC4 soap_in_ns4__UpdateCategory(struct soap *soap, const char *tag, enum ns4__UpdateCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__UpdateCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UpdateCategory, sizeof(enum ns4__UpdateCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__UpdateCategory(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__UpdateCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UpdateCategory, 0, sizeof(enum ns4__UpdateCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UpdateCategory(struct soap *soap, const enum ns4__UpdateCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UpdateCategory);
	if (soap_out_ns4__UpdateCategory(soap, tag?tag:"ns4:UpdateCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__UpdateCategory * SOAP_FMAC4 soap_get_ns4__UpdateCategory(struct soap *soap, enum ns4__UpdateCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UpdateCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__G8Action(struct soap *soap, enum ns4__G8Action *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__G8Action
	*a = SOAP_DEFAULT_ns4__G8Action;
#else
	*a = (enum ns4__G8Action)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__G8Action[] =
{	{ (long)ns4__G8Action__WORK, "WORK" },
	{ (long)ns4__G8Action__OPEN, "OPEN" },
	{ (long)ns4__G8Action__UPDATE, "UPDATE" },
	{ (long)ns4__G8Action__REOPEN, "REOPEN" },
	{ (long)ns4__G8Action__BUSY, "BUSY" },
	{ (long)ns4__G8Action__REJECT, "REJECT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__G8Action2s(struct soap *soap, enum ns4__G8Action n)
{	const char *s = soap_code_str(soap_codes_ns4__G8Action, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__G8Action(struct soap *soap, const char *tag, int id, const enum ns4__G8Action *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__G8Action), type) || soap_send(soap, soap_ns4__G8Action2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__G8Action(struct soap *soap, const char *s, enum ns4__G8Action *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__G8Action, s);
	if (map)
		*a = (enum ns4__G8Action)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__G8Action)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__G8Action * SOAP_FMAC4 soap_in_ns4__G8Action(struct soap *soap, const char *tag, enum ns4__G8Action *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__G8Action *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__G8Action, sizeof(enum ns4__G8Action), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__G8Action(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__G8Action *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__G8Action, 0, sizeof(enum ns4__G8Action), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__G8Action(struct soap *soap, const enum ns4__G8Action *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__G8Action);
	if (soap_out_ns4__G8Action(soap, tag?tag:"ns4:G8Action", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__G8Action * SOAP_FMAC4 soap_get_ns4__G8Action(struct soap *soap, enum ns4__G8Action *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__G8Action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__DataFormatEnum(struct soap *soap, enum ns4__DataFormatEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns4__DataFormatEnum
	*a = SOAP_DEFAULT_ns4__DataFormatEnum;
#else
	*a = (enum ns4__DataFormatEnum)0;
#endif
}

static const struct soap_code_map soap_codes_ns4__DataFormatEnum[] =
{	{ (long)ns4__DataFormatEnum__XML_, "XML" },
	{ (long)ns4__DataFormatEnum__JSON, "JSON" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__DataFormatEnum2s(struct soap *soap, enum ns4__DataFormatEnum n)
{	const char *s = soap_code_str(soap_codes_ns4__DataFormatEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__DataFormatEnum(struct soap *soap, const char *tag, int id, const enum ns4__DataFormatEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__DataFormatEnum), type) || soap_send(soap, soap_ns4__DataFormatEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__DataFormatEnum(struct soap *soap, const char *s, enum ns4__DataFormatEnum *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__DataFormatEnum, s);
	if (map)
		*a = (enum ns4__DataFormatEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__DataFormatEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__DataFormatEnum * SOAP_FMAC4 soap_in_ns4__DataFormatEnum(struct soap *soap, const char *tag, enum ns4__DataFormatEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__DataFormatEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__DataFormatEnum, sizeof(enum ns4__DataFormatEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns4__DataFormatEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__DataFormatEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__DataFormatEnum, 0, sizeof(enum ns4__DataFormatEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__DataFormatEnum(struct soap *soap, const enum ns4__DataFormatEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__DataFormatEnum);
	if (soap_out_ns4__DataFormatEnum(soap, tag?tag:"ns4:DataFormatEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__DataFormatEnum * SOAP_FMAC4 soap_get_ns4__DataFormatEnum(struct soap *soap, enum ns4__DataFormatEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__DataFormatEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Call(struct soap *soap, struct __ns1__Call *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Call = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Call(struct soap *soap, const struct __ns1__Call *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Call(soap, &a->ns1__Call);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Call(struct soap *soap, const char *tag, int id, const struct __ns1__Call *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__Call(soap, "ns1:Call", -1, &a->ns1__Call, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Call * SOAP_FMAC4 soap_in___ns1__Call(struct soap *soap, const char *tag, struct __ns1__Call *a, const char *type)
{
	size_t soap_flag_ns1__Call = 1;
	short soap_flag;
	a = (struct __ns1__Call *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Call, sizeof(struct __ns1__Call), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Call(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Call && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Call(soap, "ns1:Call", &a->ns1__Call, ""))
				{	soap_flag_ns1__Call--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Call(struct soap *soap, const struct __ns1__Call *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Call(soap, tag?tag:"-ns1:Call", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Call * SOAP_FMAC4 soap_get___ns1__Call(struct soap *soap, struct __ns1__Call *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Call(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ArrayOfbase64Binary(struct soap *soap, struct ns5__ArrayOfbase64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizebase64Binary = 0;
	a->base64Binary = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__ArrayOfbase64Binary(struct soap *soap, const struct ns5__ArrayOfbase64Binary *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->base64Binary)
	{	int i;
		for (i = 0; i < a->__sizebase64Binary; i++)
		{
			soap_embedded(soap, a->base64Binary + i, SOAP_TYPE_xsd__base64Binary);
			soap_serialize_xsd__base64Binary(soap, a->base64Binary + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ArrayOfbase64Binary(struct soap *soap, const char *tag, int id, const struct ns5__ArrayOfbase64Binary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ArrayOfbase64Binary), type))
		return soap->error;
	if (a->base64Binary)
	{	int i;
		for (i = 0; i < a->__sizebase64Binary; i++)
			if (soap_out_xsd__base64Binary(soap, "ns5:base64Binary", -1, a->base64Binary + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__ArrayOfbase64Binary * SOAP_FMAC4 soap_in_ns5__ArrayOfbase64Binary(struct soap *soap, const char *tag, struct ns5__ArrayOfbase64Binary *a, const char *type)
{
	struct soap_blist *soap_blist_base64Binary = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__ArrayOfbase64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ArrayOfbase64Binary, sizeof(struct ns5__ArrayOfbase64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__ArrayOfbase64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:base64Binary", 1, NULL))
			{	if (a->base64Binary == NULL)
				{	if (soap_blist_base64Binary == NULL)
						soap_blist_base64Binary = soap_new_block(soap);
					a->base64Binary = (struct xsd__base64Binary *)soap_push_block(soap, soap_blist_base64Binary, sizeof(struct xsd__base64Binary));
					if (a->base64Binary == NULL)
						return NULL;
					soap_default_xsd__base64Binary(soap, a->base64Binary);
				}
				soap_revert(soap);
				if (soap_in_xsd__base64Binary(soap, "ns5:base64Binary", a->base64Binary, "xsd:base64Binary"))
				{	a->__sizebase64Binary++;
					a->base64Binary = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->base64Binary)
			soap_pop_block(soap, soap_blist_base64Binary);
		if (a->__sizebase64Binary)
			a->base64Binary = (struct xsd__base64Binary *)soap_save_block(soap, soap_blist_base64Binary, NULL, 1);
		else
		{	a->base64Binary = NULL;
			if (soap_blist_base64Binary)
				soap_end_block(soap, soap_blist_base64Binary);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__ArrayOfbase64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ArrayOfbase64Binary, 0, sizeof(struct ns5__ArrayOfbase64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ArrayOfbase64Binary(struct soap *soap, const struct ns5__ArrayOfbase64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__ArrayOfbase64Binary);
	if (soap_out_ns5__ArrayOfbase64Binary(soap, tag?tag:"ns5:ArrayOfbase64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ArrayOfbase64Binary * SOAP_FMAC4 soap_get_ns5__ArrayOfbase64Binary(struct soap *soap, struct ns5__ArrayOfbase64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ArrayOfbase64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ServerStatusInfo(struct soap *soap, struct ns4__ServerStatusInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ServerKey);
	soap_default_string(soap, &a->ServerStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ServerStatusInfo(struct soap *soap, const struct ns4__ServerStatusInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ServerKey);
	soap_serialize_string(soap, &a->ServerStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ServerStatusInfo(struct soap *soap, const char *tag, int id, const struct ns4__ServerStatusInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ServerStatusInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:ServerKey", -1, &a->ServerKey, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ServerStatus", -1, &a->ServerStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ServerStatusInfo * SOAP_FMAC4 soap_in_ns4__ServerStatusInfo(struct soap *soap, const char *tag, struct ns4__ServerStatusInfo *a, const char *type)
{
	size_t soap_flag_ServerKey = 1;
	size_t soap_flag_ServerStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ServerStatusInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ServerStatusInfo, sizeof(struct ns4__ServerStatusInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ServerStatusInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ServerKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ServerKey", &a->ServerKey, "xsd:string"))
				{	soap_flag_ServerKey--;
					continue;
				}
			if (soap_flag_ServerStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ServerStatus", &a->ServerStatus, "xsd:string"))
				{	soap_flag_ServerStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ServerStatusInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ServerStatusInfo, 0, sizeof(struct ns4__ServerStatusInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ServerStatusInfo(struct soap *soap, const struct ns4__ServerStatusInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ServerStatusInfo);
	if (soap_out_ns4__ServerStatusInfo(soap, tag?tag:"ns4:ServerStatusInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ServerStatusInfo * SOAP_FMAC4 soap_get_ns4__ServerStatusInfo(struct soap *soap, struct ns4__ServerStatusInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ServerStatusInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ArrayOfServerStatusInfo(struct soap *soap, struct ns4__ArrayOfServerStatusInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeServerStatusInfo = 0;
	a->ServerStatusInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ArrayOfServerStatusInfo(struct soap *soap, const struct ns4__ArrayOfServerStatusInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ServerStatusInfo)
	{	int i;
		for (i = 0; i < a->__sizeServerStatusInfo; i++)
		{
			soap_embedded(soap, a->ServerStatusInfo + i, SOAP_TYPE_ns4__ServerStatusInfo);
			soap_serialize_ns4__ServerStatusInfo(soap, a->ServerStatusInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfServerStatusInfo(struct soap *soap, const char *tag, int id, const struct ns4__ArrayOfServerStatusInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfServerStatusInfo), type))
		return soap->error;
	if (a->ServerStatusInfo)
	{	int i;
		for (i = 0; i < a->__sizeServerStatusInfo; i++)
			if (soap_out_ns4__ServerStatusInfo(soap, "ns4:ServerStatusInfo", -1, a->ServerStatusInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ArrayOfServerStatusInfo * SOAP_FMAC4 soap_in_ns4__ArrayOfServerStatusInfo(struct soap *soap, const char *tag, struct ns4__ArrayOfServerStatusInfo *a, const char *type)
{
	struct soap_blist *soap_blist_ServerStatusInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ArrayOfServerStatusInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfServerStatusInfo, sizeof(struct ns4__ArrayOfServerStatusInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ArrayOfServerStatusInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ServerStatusInfo", 1, NULL))
			{	if (a->ServerStatusInfo == NULL)
				{	if (soap_blist_ServerStatusInfo == NULL)
						soap_blist_ServerStatusInfo = soap_new_block(soap);
					a->ServerStatusInfo = (struct ns4__ServerStatusInfo *)soap_push_block(soap, soap_blist_ServerStatusInfo, sizeof(struct ns4__ServerStatusInfo));
					if (a->ServerStatusInfo == NULL)
						return NULL;
					soap_default_ns4__ServerStatusInfo(soap, a->ServerStatusInfo);
				}
				soap_revert(soap);
				if (soap_in_ns4__ServerStatusInfo(soap, "ns4:ServerStatusInfo", a->ServerStatusInfo, "ns4:ServerStatusInfo"))
				{	a->__sizeServerStatusInfo++;
					a->ServerStatusInfo = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ServerStatusInfo)
			soap_pop_block(soap, soap_blist_ServerStatusInfo);
		if (a->__sizeServerStatusInfo)
			a->ServerStatusInfo = (struct ns4__ServerStatusInfo *)soap_save_block(soap, soap_blist_ServerStatusInfo, NULL, 1);
		else
		{	a->ServerStatusInfo = NULL;
			if (soap_blist_ServerStatusInfo)
				soap_end_block(soap, soap_blist_ServerStatusInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfServerStatusInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfServerStatusInfo, 0, sizeof(struct ns4__ArrayOfServerStatusInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ArrayOfServerStatusInfo(struct soap *soap, const struct ns4__ArrayOfServerStatusInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfServerStatusInfo);
	if (soap_out_ns4__ArrayOfServerStatusInfo(soap, tag?tag:"ns4:ArrayOfServerStatusInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfServerStatusInfo * SOAP_FMAC4 soap_get_ns4__ArrayOfServerStatusInfo(struct soap *soap, struct ns4__ArrayOfServerStatusInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfServerStatusInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ArrayOfFieldPair(struct soap *soap, struct ns4__ArrayOfFieldPair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeFieldPair = 0;
	a->FieldPair = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ArrayOfFieldPair(struct soap *soap, const struct ns4__ArrayOfFieldPair *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->FieldPair)
	{	int i;
		for (i = 0; i < a->__sizeFieldPair; i++)
		{
			soap_embedded(soap, a->FieldPair + i, SOAP_TYPE_ns4__FieldPair);
			soap_serialize_ns4__FieldPair(soap, a->FieldPair + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfFieldPair(struct soap *soap, const char *tag, int id, const struct ns4__ArrayOfFieldPair *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfFieldPair), type))
		return soap->error;
	if (a->FieldPair)
	{	int i;
		for (i = 0; i < a->__sizeFieldPair; i++)
			if (soap_out_ns4__FieldPair(soap, "ns4:FieldPair", -1, a->FieldPair + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ArrayOfFieldPair * SOAP_FMAC4 soap_in_ns4__ArrayOfFieldPair(struct soap *soap, const char *tag, struct ns4__ArrayOfFieldPair *a, const char *type)
{
	struct soap_blist *soap_blist_FieldPair = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ArrayOfFieldPair *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfFieldPair, sizeof(struct ns4__ArrayOfFieldPair), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ArrayOfFieldPair(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:FieldPair", 1, NULL))
			{	if (a->FieldPair == NULL)
				{	if (soap_blist_FieldPair == NULL)
						soap_blist_FieldPair = soap_new_block(soap);
					a->FieldPair = (struct ns4__FieldPair *)soap_push_block(soap, soap_blist_FieldPair, sizeof(struct ns4__FieldPair));
					if (a->FieldPair == NULL)
						return NULL;
					soap_default_ns4__FieldPair(soap, a->FieldPair);
				}
				soap_revert(soap);
				if (soap_in_ns4__FieldPair(soap, "ns4:FieldPair", a->FieldPair, "ns4:FieldPair"))
				{	a->__sizeFieldPair++;
					a->FieldPair = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->FieldPair)
			soap_pop_block(soap, soap_blist_FieldPair);
		if (a->__sizeFieldPair)
			a->FieldPair = (struct ns4__FieldPair *)soap_save_block(soap, soap_blist_FieldPair, NULL, 1);
		else
		{	a->FieldPair = NULL;
			if (soap_blist_FieldPair)
				soap_end_block(soap, soap_blist_FieldPair);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfFieldPair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfFieldPair, 0, sizeof(struct ns4__ArrayOfFieldPair), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ArrayOfFieldPair(struct soap *soap, const struct ns4__ArrayOfFieldPair *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfFieldPair);
	if (soap_out_ns4__ArrayOfFieldPair(soap, tag?tag:"ns4:ArrayOfFieldPair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfFieldPair * SOAP_FMAC4 soap_get_ns4__ArrayOfFieldPair(struct soap *soap, struct ns4__ArrayOfFieldPair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfFieldPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FieldPair(struct soap *soap, struct ns4__FieldPair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Code = NULL;
	soap_default_string(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FieldPair(struct soap *soap, const struct ns4__FieldPair *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__FieldCode(soap, &a->Code);
	soap_serialize_string(soap, &a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FieldPair(struct soap *soap, const char *tag, int id, const struct ns4__FieldPair *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FieldPair), type))
		return soap->error;
	if (soap_out_PointerTons4__FieldCode(soap, "ns4:Code", -1, &a->Code, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Value", -1, &a->Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FieldPair * SOAP_FMAC4 soap_in_ns4__FieldPair(struct soap *soap, const char *tag, struct ns4__FieldPair *a, const char *type)
{
	size_t soap_flag_Code = 1;
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FieldPair *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FieldPair, sizeof(struct ns4__FieldPair), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FieldPair(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FieldCode(soap, "ns4:Code", &a->Code, "ns4:FieldCode"))
				{	soap_flag_Code--;
					continue;
				}
			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Value", &a->Value, "xsd:string"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FieldPair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FieldPair, 0, sizeof(struct ns4__FieldPair), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FieldPair(struct soap *soap, const struct ns4__FieldPair *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__FieldPair);
	if (soap_out_ns4__FieldPair(soap, tag?tag:"ns4:FieldPair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FieldPair * SOAP_FMAC4 soap_get_ns4__FieldPair(struct soap *soap, struct ns4__FieldPair *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FieldPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ArrayOfstring(struct soap *soap, struct ns5__ArrayOfstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizestring = 0;
	a->string = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__ArrayOfstring(struct soap *soap, const struct ns5__ArrayOfstring *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->string)
	{	int i;
		for (i = 0; i < a->__sizestring; i++)
		{
			soap_serialize_string(soap, a->string + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ArrayOfstring(struct soap *soap, const char *tag, int id, const struct ns5__ArrayOfstring *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ArrayOfstring), type))
		return soap->error;
	if (a->string)
	{	int i;
		for (i = 0; i < a->__sizestring; i++)
			if (soap_out_string(soap, "ns5:string", -1, a->string + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__ArrayOfstring * SOAP_FMAC4 soap_in_ns5__ArrayOfstring(struct soap *soap, const char *tag, struct ns5__ArrayOfstring *a, const char *type)
{
	struct soap_blist *soap_blist_string = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__ArrayOfstring *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ArrayOfstring, sizeof(struct ns5__ArrayOfstring), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__ArrayOfstring(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:string", 1, NULL))
			{	if (a->string == NULL)
				{	if (soap_blist_string == NULL)
						soap_blist_string = soap_new_block(soap);
					a->string = (char **)soap_push_block(soap, soap_blist_string, sizeof(char *));
					if (a->string == NULL)
						return NULL;
					*a->string = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns5:string", a->string, "xsd:string"))
				{	a->__sizestring++;
					a->string = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->string)
			soap_pop_block(soap, soap_blist_string);
		if (a->__sizestring)
			a->string = (char **)soap_save_block(soap, soap_blist_string, NULL, 1);
		else
		{	a->string = NULL;
			if (soap_blist_string)
				soap_end_block(soap, soap_blist_string);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ArrayOfstring, 0, sizeof(struct ns5__ArrayOfstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ArrayOfstring(struct soap *soap, const struct ns5__ArrayOfstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__ArrayOfstring);
	if (soap_out_ns5__ArrayOfstring(soap, tag?tag:"ns5:ArrayOfstring", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ArrayOfstring * SOAP_FMAC4 soap_get_ns5__ArrayOfstring(struct soap *soap, struct ns5__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ArrayOfServerInfo(struct soap *soap, struct ns4__ArrayOfServerInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeServerInfo = 0;
	a->ServerInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ArrayOfServerInfo(struct soap *soap, const struct ns4__ArrayOfServerInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ServerInfo)
	{	int i;
		for (i = 0; i < a->__sizeServerInfo; i++)
		{
			soap_embedded(soap, a->ServerInfo + i, SOAP_TYPE_ns4__ServerInfo);
			soap_serialize_ns4__ServerInfo(soap, a->ServerInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfServerInfo(struct soap *soap, const char *tag, int id, const struct ns4__ArrayOfServerInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfServerInfo), type))
		return soap->error;
	if (a->ServerInfo)
	{	int i;
		for (i = 0; i < a->__sizeServerInfo; i++)
			if (soap_out_ns4__ServerInfo(soap, "ns4:ServerInfo", -1, a->ServerInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ArrayOfServerInfo * SOAP_FMAC4 soap_in_ns4__ArrayOfServerInfo(struct soap *soap, const char *tag, struct ns4__ArrayOfServerInfo *a, const char *type)
{
	struct soap_blist *soap_blist_ServerInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ArrayOfServerInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfServerInfo, sizeof(struct ns4__ArrayOfServerInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ArrayOfServerInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ServerInfo", 1, NULL))
			{	if (a->ServerInfo == NULL)
				{	if (soap_blist_ServerInfo == NULL)
						soap_blist_ServerInfo = soap_new_block(soap);
					a->ServerInfo = (struct ns4__ServerInfo *)soap_push_block(soap, soap_blist_ServerInfo, sizeof(struct ns4__ServerInfo));
					if (a->ServerInfo == NULL)
						return NULL;
					soap_default_ns4__ServerInfo(soap, a->ServerInfo);
				}
				soap_revert(soap);
				if (soap_in_ns4__ServerInfo(soap, "ns4:ServerInfo", a->ServerInfo, "ns4:ServerInfo"))
				{	a->__sizeServerInfo++;
					a->ServerInfo = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ServerInfo)
			soap_pop_block(soap, soap_blist_ServerInfo);
		if (a->__sizeServerInfo)
			a->ServerInfo = (struct ns4__ServerInfo *)soap_save_block(soap, soap_blist_ServerInfo, NULL, 1);
		else
		{	a->ServerInfo = NULL;
			if (soap_blist_ServerInfo)
				soap_end_block(soap, soap_blist_ServerInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfServerInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfServerInfo, 0, sizeof(struct ns4__ArrayOfServerInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ArrayOfServerInfo(struct soap *soap, const struct ns4__ArrayOfServerInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfServerInfo);
	if (soap_out_ns4__ArrayOfServerInfo(soap, tag?tag:"ns4:ArrayOfServerInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfServerInfo * SOAP_FMAC4 soap_get_ns4__ArrayOfServerInfo(struct soap *soap, struct ns4__ArrayOfServerInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfServerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InterfaceAddress(struct soap *soap, struct ns4__InterfaceAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IP);
	soap_default_string(soap, &a->MAC);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InterfaceAddress(struct soap *soap, const struct ns4__InterfaceAddress *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->IP);
	soap_serialize_string(soap, &a->MAC);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InterfaceAddress(struct soap *soap, const char *tag, int id, const struct ns4__InterfaceAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InterfaceAddress), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:IP", -1, &a->IP, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MAC", -1, &a->MAC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InterfaceAddress * SOAP_FMAC4 soap_in_ns4__InterfaceAddress(struct soap *soap, const char *tag, struct ns4__InterfaceAddress *a, const char *type)
{
	size_t soap_flag_IP = 1;
	size_t soap_flag_MAC = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InterfaceAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InterfaceAddress, sizeof(struct ns4__InterfaceAddress), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InterfaceAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IP", &a->IP, "xsd:string"))
				{	soap_flag_IP--;
					continue;
				}
			if (soap_flag_MAC && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MAC", &a->MAC, "xsd:string"))
				{	soap_flag_MAC--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InterfaceAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InterfaceAddress, 0, sizeof(struct ns4__InterfaceAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InterfaceAddress(struct soap *soap, const struct ns4__InterfaceAddress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InterfaceAddress);
	if (soap_out_ns4__InterfaceAddress(soap, tag?tag:"ns4:InterfaceAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InterfaceAddress * SOAP_FMAC4 soap_get_ns4__InterfaceAddress(struct soap *soap, struct ns4__InterfaceAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InterfaceAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ArrayOfInterfaceAddress(struct soap *soap, struct ns4__ArrayOfInterfaceAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInterfaceAddress = 0;
	a->InterfaceAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ArrayOfInterfaceAddress(struct soap *soap, const struct ns4__ArrayOfInterfaceAddress *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->InterfaceAddress)
	{	int i;
		for (i = 0; i < a->__sizeInterfaceAddress; i++)
		{
			soap_embedded(soap, a->InterfaceAddress + i, SOAP_TYPE_ns4__InterfaceAddress);
			soap_serialize_ns4__InterfaceAddress(soap, a->InterfaceAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfInterfaceAddress(struct soap *soap, const char *tag, int id, const struct ns4__ArrayOfInterfaceAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfInterfaceAddress), type))
		return soap->error;
	if (a->InterfaceAddress)
	{	int i;
		for (i = 0; i < a->__sizeInterfaceAddress; i++)
			if (soap_out_ns4__InterfaceAddress(soap, "ns4:InterfaceAddress", -1, a->InterfaceAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ArrayOfInterfaceAddress * SOAP_FMAC4 soap_in_ns4__ArrayOfInterfaceAddress(struct soap *soap, const char *tag, struct ns4__ArrayOfInterfaceAddress *a, const char *type)
{
	struct soap_blist *soap_blist_InterfaceAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ArrayOfInterfaceAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfInterfaceAddress, sizeof(struct ns4__ArrayOfInterfaceAddress), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ArrayOfInterfaceAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:InterfaceAddress", 1, NULL))
			{	if (a->InterfaceAddress == NULL)
				{	if (soap_blist_InterfaceAddress == NULL)
						soap_blist_InterfaceAddress = soap_new_block(soap);
					a->InterfaceAddress = (struct ns4__InterfaceAddress *)soap_push_block(soap, soap_blist_InterfaceAddress, sizeof(struct ns4__InterfaceAddress));
					if (a->InterfaceAddress == NULL)
						return NULL;
					soap_default_ns4__InterfaceAddress(soap, a->InterfaceAddress);
				}
				soap_revert(soap);
				if (soap_in_ns4__InterfaceAddress(soap, "ns4:InterfaceAddress", a->InterfaceAddress, "ns4:InterfaceAddress"))
				{	a->__sizeInterfaceAddress++;
					a->InterfaceAddress = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InterfaceAddress)
			soap_pop_block(soap, soap_blist_InterfaceAddress);
		if (a->__sizeInterfaceAddress)
			a->InterfaceAddress = (struct ns4__InterfaceAddress *)soap_save_block(soap, soap_blist_InterfaceAddress, NULL, 1);
		else
		{	a->InterfaceAddress = NULL;
			if (soap_blist_InterfaceAddress)
				soap_end_block(soap, soap_blist_InterfaceAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfInterfaceAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfInterfaceAddress, 0, sizeof(struct ns4__ArrayOfInterfaceAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ArrayOfInterfaceAddress(struct soap *soap, const struct ns4__ArrayOfInterfaceAddress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfInterfaceAddress);
	if (soap_out_ns4__ArrayOfInterfaceAddress(soap, tag?tag:"ns4:ArrayOfInterfaceAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfInterfaceAddress * SOAP_FMAC4 soap_get_ns4__ArrayOfInterfaceAddress(struct soap *soap, struct ns4__ArrayOfInterfaceAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfInterfaceAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UpdateServerStatusRequest(struct soap *soap, struct ns4__UpdateServerStatusRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ServerStatusList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UpdateServerStatusRequest(struct soap *soap, const struct ns4__UpdateServerStatusRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfServerStatusInfo(soap, &a->ServerStatusList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UpdateServerStatusRequest(struct soap *soap, const char *tag, int id, const struct ns4__UpdateServerStatusRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UpdateServerStatusRequest), type))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfServerStatusInfo(soap, "ns4:ServerStatusList", -1, &a->ServerStatusList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UpdateServerStatusRequest * SOAP_FMAC4 soap_in_ns4__UpdateServerStatusRequest(struct soap *soap, const char *tag, struct ns4__UpdateServerStatusRequest *a, const char *type)
{
	size_t soap_flag_ServerStatusList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UpdateServerStatusRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UpdateServerStatusRequest, sizeof(struct ns4__UpdateServerStatusRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UpdateServerStatusRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ServerStatusList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfServerStatusInfo(soap, "ns4:ServerStatusList", &a->ServerStatusList, "ns4:ArrayOfServerStatusInfo"))
				{	soap_flag_ServerStatusList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UpdateServerStatusRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UpdateServerStatusRequest, 0, sizeof(struct ns4__UpdateServerStatusRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UpdateServerStatusRequest(struct soap *soap, const struct ns4__UpdateServerStatusRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UpdateServerStatusRequest);
	if (soap_out_ns4__UpdateServerStatusRequest(soap, tag?tag:"ns4:UpdateServerStatusRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UpdateServerStatusRequest * SOAP_FMAC4 soap_get_ns4__UpdateServerStatusRequest(struct soap *soap, struct ns4__UpdateServerStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UpdateServerStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UpdateInfoRequest(struct soap *soap, struct ns4__UpdateInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Category = NULL;
	a->PrimaryField = NULL;
	a->UpdatedFieldList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UpdateInfoRequest(struct soap *soap, const struct ns4__UpdateInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UpdateCategory(soap, &a->Category);
	soap_serialize_PointerTons4__FieldPair(soap, &a->PrimaryField);
	soap_serialize_PointerTons4__ArrayOfFieldPair(soap, &a->UpdatedFieldList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UpdateInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__UpdateInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UpdateInfoRequest), type))
		return soap->error;
	if (soap_out_PointerTons4__UpdateCategory(soap, "ns4:Category", -1, &a->Category, ""))
		return soap->error;
	if (soap_out_PointerTons4__FieldPair(soap, "ns4:PrimaryField", -1, &a->PrimaryField, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfFieldPair(soap, "ns4:UpdatedFieldList", -1, &a->UpdatedFieldList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UpdateInfoRequest * SOAP_FMAC4 soap_in_ns4__UpdateInfoRequest(struct soap *soap, const char *tag, struct ns4__UpdateInfoRequest *a, const char *type)
{
	size_t soap_flag_Category = 1;
	size_t soap_flag_PrimaryField = 1;
	size_t soap_flag_UpdatedFieldList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UpdateInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UpdateInfoRequest, sizeof(struct ns4__UpdateInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UpdateInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Category && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateCategory(soap, "ns4:Category", &a->Category, "ns4:UpdateCategory"))
				{	soap_flag_Category--;
					continue;
				}
			if (soap_flag_PrimaryField && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FieldPair(soap, "ns4:PrimaryField", &a->PrimaryField, "ns4:FieldPair"))
				{	soap_flag_PrimaryField--;
					continue;
				}
			if (soap_flag_UpdatedFieldList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfFieldPair(soap, "ns4:UpdatedFieldList", &a->UpdatedFieldList, "ns4:ArrayOfFieldPair"))
				{	soap_flag_UpdatedFieldList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UpdateInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UpdateInfoRequest, 0, sizeof(struct ns4__UpdateInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UpdateInfoRequest(struct soap *soap, const struct ns4__UpdateInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UpdateInfoRequest);
	if (soap_out_ns4__UpdateInfoRequest(soap, tag?tag:"ns4:UpdateInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UpdateInfoRequest * SOAP_FMAC4 soap_get_ns4__UpdateInfoRequest(struct soap *soap, struct ns4__UpdateInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UpdateInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UpdateDataServerVMRequest(struct soap *soap, struct ns4__UpdateDataServerVMRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->BUCKET);
	soap_default_string(soap, &a->CPU);
	soap_default_string(soap, &a->HDD);
	soap_default_string(soap, &a->IPADDRESS);
	soap_default_string(soap, &a->MACADDRESS);
	soap_default_string(soap, &a->MEMORY);
	soap_default_string(soap, &a->OS);
	soap_default_string(soap, &a->OS_USCORESERVERNAME);
	soap_default_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_default_string(soap, &a->PHYSICAL_USCORESERVER_USCOREIP);
	soap_default_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_default_string(soap, &a->PRODUCT_USCORECODE);
	soap_default_string(soap, &a->PURPOSE_USCOREUSE);
	soap_default_string(soap, &a->SERVER_USCORENAME);
	soap_default_string(soap, &a->STATUS);
	soap_default_string(soap, &a->TECHNICAL_USCOREOWNER);
	soap_default_string(soap, &a->UUID);
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->VLAN);
	soap_default_string(soap, &a->VMW_USCORETOOL);
	soap_default_string(soap, &a->VM_USCORECENTER);
	soap_default_string(soap, &a->VM_USCOREID);
	soap_default_string(soap, &a->VM_USCOREKEY);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UpdateDataServerVMRequest(struct soap *soap, const struct ns4__UpdateDataServerVMRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->BUCKET);
	soap_serialize_string(soap, &a->CPU);
	soap_serialize_string(soap, &a->HDD);
	soap_serialize_string(soap, &a->IPADDRESS);
	soap_serialize_string(soap, &a->MACADDRESS);
	soap_serialize_string(soap, &a->MEMORY);
	soap_serialize_string(soap, &a->OS);
	soap_serialize_string(soap, &a->OS_USCORESERVERNAME);
	soap_serialize_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_serialize_string(soap, &a->PHYSICAL_USCORESERVER_USCOREIP);
	soap_serialize_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_serialize_string(soap, &a->PRODUCT_USCORECODE);
	soap_serialize_string(soap, &a->PURPOSE_USCOREUSE);
	soap_serialize_string(soap, &a->SERVER_USCORENAME);
	soap_serialize_string(soap, &a->STATUS);
	soap_serialize_string(soap, &a->TECHNICAL_USCOREOWNER);
	soap_serialize_string(soap, &a->UUID);
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->VLAN);
	soap_serialize_string(soap, &a->VMW_USCORETOOL);
	soap_serialize_string(soap, &a->VM_USCORECENTER);
	soap_serialize_string(soap, &a->VM_USCOREID);
	soap_serialize_string(soap, &a->VM_USCOREKEY);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UpdateDataServerVMRequest(struct soap *soap, const char *tag, int id, const struct ns4__UpdateDataServerVMRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UpdateDataServerVMRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:BUCKET", -1, &a->BUCKET, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CPU", -1, &a->CPU, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:HDD", -1, &a->HDD, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPADDRESS", -1, &a->IPADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MACADDRESS", -1, &a->MACADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MEMORY", -1, &a->MEMORY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS", -1, &a->OS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_SERVERNAME", -1, &a->OS_USCORESERVERNAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_CHASSIS_SN", -1, &a->PHYSICAL_USCORECHASSIS_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_SERVER_IP", -1, &a->PHYSICAL_USCORESERVER_USCOREIP, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_SERVER_SN", -1, &a->PHYSICAL_USCORESERVER_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PRODUCT_CODE", -1, &a->PRODUCT_USCORECODE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PURPOSE_USE", -1, &a->PURPOSE_USCOREUSE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SERVER_NAME", -1, &a->SERVER_USCORENAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STATUS", -1, &a->STATUS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TECHNICAL_OWNER", -1, &a->TECHNICAL_USCOREOWNER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:UUID", -1, &a->UUID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VID", -1, &a->VID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VLAN", -1, &a->VLAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMW_TOOL", -1, &a->VMW_USCORETOOL, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_CENTER", -1, &a->VM_USCORECENTER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_ID", -1, &a->VM_USCOREID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_KEY", -1, &a->VM_USCOREKEY, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UpdateDataServerVMRequest * SOAP_FMAC4 soap_in_ns4__UpdateDataServerVMRequest(struct soap *soap, const char *tag, struct ns4__UpdateDataServerVMRequest *a, const char *type)
{
	size_t soap_flag_BUCKET = 1;
	size_t soap_flag_CPU = 1;
	size_t soap_flag_HDD = 1;
	size_t soap_flag_IPADDRESS = 1;
	size_t soap_flag_MACADDRESS = 1;
	size_t soap_flag_MEMORY = 1;
	size_t soap_flag_OS = 1;
	size_t soap_flag_OS_USCORESERVERNAME = 1;
	size_t soap_flag_PHYSICAL_USCORECHASSIS_USCORESN = 1;
	size_t soap_flag_PHYSICAL_USCORESERVER_USCOREIP = 1;
	size_t soap_flag_PHYSICAL_USCORESERVER_USCORESN = 1;
	size_t soap_flag_PRODUCT_USCORECODE = 1;
	size_t soap_flag_PURPOSE_USCOREUSE = 1;
	size_t soap_flag_SERVER_USCORENAME = 1;
	size_t soap_flag_STATUS = 1;
	size_t soap_flag_TECHNICAL_USCOREOWNER = 1;
	size_t soap_flag_UUID = 1;
	size_t soap_flag_VID = 1;
	size_t soap_flag_VLAN = 1;
	size_t soap_flag_VMW_USCORETOOL = 1;
	size_t soap_flag_VM_USCORECENTER = 1;
	size_t soap_flag_VM_USCOREID = 1;
	size_t soap_flag_VM_USCOREKEY = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UpdateDataServerVMRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UpdateDataServerVMRequest, sizeof(struct ns4__UpdateDataServerVMRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UpdateDataServerVMRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BUCKET && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BUCKET", &a->BUCKET, "xsd:string"))
				{	soap_flag_BUCKET--;
					continue;
				}
			if (soap_flag_CPU && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CPU", &a->CPU, "xsd:string"))
				{	soap_flag_CPU--;
					continue;
				}
			if (soap_flag_HDD && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:HDD", &a->HDD, "xsd:string"))
				{	soap_flag_HDD--;
					continue;
				}
			if (soap_flag_IPADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPADDRESS", &a->IPADDRESS, "xsd:string"))
				{	soap_flag_IPADDRESS--;
					continue;
				}
			if (soap_flag_MACADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MACADDRESS", &a->MACADDRESS, "xsd:string"))
				{	soap_flag_MACADDRESS--;
					continue;
				}
			if (soap_flag_MEMORY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MEMORY", &a->MEMORY, "xsd:string"))
				{	soap_flag_MEMORY--;
					continue;
				}
			if (soap_flag_OS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS", &a->OS, "xsd:string"))
				{	soap_flag_OS--;
					continue;
				}
			if (soap_flag_OS_USCORESERVERNAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_SERVERNAME", &a->OS_USCORESERVERNAME, "xsd:string"))
				{	soap_flag_OS_USCORESERVERNAME--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORECHASSIS_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_CHASSIS_SN", &a->PHYSICAL_USCORECHASSIS_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORECHASSIS_USCORESN--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORESERVER_USCOREIP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_SERVER_IP", &a->PHYSICAL_USCORESERVER_USCOREIP, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORESERVER_USCOREIP--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORESERVER_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_SERVER_SN", &a->PHYSICAL_USCORESERVER_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORESERVER_USCORESN--;
					continue;
				}
			if (soap_flag_PRODUCT_USCORECODE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PRODUCT_CODE", &a->PRODUCT_USCORECODE, "xsd:string"))
				{	soap_flag_PRODUCT_USCORECODE--;
					continue;
				}
			if (soap_flag_PURPOSE_USCOREUSE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PURPOSE_USE", &a->PURPOSE_USCOREUSE, "xsd:string"))
				{	soap_flag_PURPOSE_USCOREUSE--;
					continue;
				}
			if (soap_flag_SERVER_USCORENAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SERVER_NAME", &a->SERVER_USCORENAME, "xsd:string"))
				{	soap_flag_SERVER_USCORENAME--;
					continue;
				}
			if (soap_flag_STATUS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STATUS", &a->STATUS, "xsd:string"))
				{	soap_flag_STATUS--;
					continue;
				}
			if (soap_flag_TECHNICAL_USCOREOWNER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TECHNICAL_OWNER", &a->TECHNICAL_USCOREOWNER, "xsd:string"))
				{	soap_flag_TECHNICAL_USCOREOWNER--;
					continue;
				}
			if (soap_flag_UUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UUID", &a->UUID, "xsd:string"))
				{	soap_flag_UUID--;
					continue;
				}
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_VLAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VLAN", &a->VLAN, "xsd:string"))
				{	soap_flag_VLAN--;
					continue;
				}
			if (soap_flag_VMW_USCORETOOL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMW_TOOL", &a->VMW_USCORETOOL, "xsd:string"))
				{	soap_flag_VMW_USCORETOOL--;
					continue;
				}
			if (soap_flag_VM_USCORECENTER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_CENTER", &a->VM_USCORECENTER, "xsd:string"))
				{	soap_flag_VM_USCORECENTER--;
					continue;
				}
			if (soap_flag_VM_USCOREID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_ID", &a->VM_USCOREID, "xsd:string"))
				{	soap_flag_VM_USCOREID--;
					continue;
				}
			if (soap_flag_VM_USCOREKEY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_KEY", &a->VM_USCOREKEY, "xsd:string"))
				{	soap_flag_VM_USCOREKEY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UpdateDataServerVMRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UpdateDataServerVMRequest, 0, sizeof(struct ns4__UpdateDataServerVMRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UpdateDataServerVMRequest(struct soap *soap, const struct ns4__UpdateDataServerVMRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__UpdateDataServerVMRequest);
	if (soap_out_ns4__UpdateDataServerVMRequest(soap, tag?tag:"ns4:UpdateDataServerVMRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UpdateDataServerVMRequest * SOAP_FMAC4 soap_get_ns4__UpdateDataServerVMRequest(struct soap *soap, struct ns4__UpdateDataServerVMRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UpdateDataServerVMRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HandleServerPhysicalInfoRequest(struct soap *soap, struct ns4__HandleServerPhysicalInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ASSET_USCORECODE);
	soap_default_string(soap, &a->BAY);
	soap_default_string(soap, &a->BUCKET);
	soap_default_string(soap, &a->CPU);
	soap_default_string(soap, &a->HDD_USCORESIZE);
	soap_default_string(soap, &a->IP_USCORECHASSIS);
	soap_default_string(soap, &a->IP_USCORECONSOLE);
	soap_default_string(soap, &a->OS_USCOREHDD_USCORERAID_USCORETYPE);
	soap_default_string(soap, &a->PRODUCT_USCORECODE);
	soap_default_string(soap, &a->RACK);
	soap_default_string(soap, &a->RAM);
	soap_default_string(soap, &a->SERIAL_USCORENUMBER);
	soap_default_string(soap, &a->SERVER_USCOREMODEL);
	soap_default_string(soap, &a->SITE);
	soap_default_string(soap, &a->STATUS);
	soap_default_string(soap, &a->TOTAL_USCOREMEMORY);
	soap_default_string(soap, &a->TYPE_USCORECHANGE);
	soap_default_string(soap, &a->U);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HandleServerPhysicalInfoRequest(struct soap *soap, const struct ns4__HandleServerPhysicalInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ASSET_USCORECODE);
	soap_serialize_string(soap, &a->BAY);
	soap_serialize_string(soap, &a->BUCKET);
	soap_serialize_string(soap, &a->CPU);
	soap_serialize_string(soap, &a->HDD_USCORESIZE);
	soap_serialize_string(soap, &a->IP_USCORECHASSIS);
	soap_serialize_string(soap, &a->IP_USCORECONSOLE);
	soap_serialize_string(soap, &a->OS_USCOREHDD_USCORERAID_USCORETYPE);
	soap_serialize_string(soap, &a->PRODUCT_USCORECODE);
	soap_serialize_string(soap, &a->RACK);
	soap_serialize_string(soap, &a->RAM);
	soap_serialize_string(soap, &a->SERIAL_USCORENUMBER);
	soap_serialize_string(soap, &a->SERVER_USCOREMODEL);
	soap_serialize_string(soap, &a->SITE);
	soap_serialize_string(soap, &a->STATUS);
	soap_serialize_string(soap, &a->TOTAL_USCOREMEMORY);
	soap_serialize_string(soap, &a->TYPE_USCORECHANGE);
	soap_serialize_string(soap, &a->U);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HandleServerPhysicalInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__HandleServerPhysicalInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:ASSET_CODE", -1, &a->ASSET_USCORECODE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BAY", -1, &a->BAY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:BUCKET", -1, &a->BUCKET, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CPU", -1, &a->CPU, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:HDD_SIZE", -1, &a->HDD_USCORESIZE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IP_CHASSIS", -1, &a->IP_USCORECHASSIS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IP_CONSOLE", -1, &a->IP_USCORECONSOLE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_HDD_RAID_TYPE", -1, &a->OS_USCOREHDD_USCORERAID_USCORETYPE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PRODUCT_CODE", -1, &a->PRODUCT_USCORECODE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RACK", -1, &a->RACK, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RAM", -1, &a->RAM, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SERIAL_NUMBER", -1, &a->SERIAL_USCORENUMBER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SERVER_MODEL", -1, &a->SERVER_USCOREMODEL, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SITE", -1, &a->SITE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STATUS", -1, &a->STATUS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TOTAL_MEMORY", -1, &a->TOTAL_USCOREMEMORY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TYPE_CHANGE", -1, &a->TYPE_USCORECHANGE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:U", -1, &a->U, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HandleServerPhysicalInfoRequest * SOAP_FMAC4 soap_in_ns4__HandleServerPhysicalInfoRequest(struct soap *soap, const char *tag, struct ns4__HandleServerPhysicalInfoRequest *a, const char *type)
{
	size_t soap_flag_ASSET_USCORECODE = 1;
	size_t soap_flag_BAY = 1;
	size_t soap_flag_BUCKET = 1;
	size_t soap_flag_CPU = 1;
	size_t soap_flag_HDD_USCORESIZE = 1;
	size_t soap_flag_IP_USCORECHASSIS = 1;
	size_t soap_flag_IP_USCORECONSOLE = 1;
	size_t soap_flag_OS_USCOREHDD_USCORERAID_USCORETYPE = 1;
	size_t soap_flag_PRODUCT_USCORECODE = 1;
	size_t soap_flag_RACK = 1;
	size_t soap_flag_RAM = 1;
	size_t soap_flag_SERIAL_USCORENUMBER = 1;
	size_t soap_flag_SERVER_USCOREMODEL = 1;
	size_t soap_flag_SITE = 1;
	size_t soap_flag_STATUS = 1;
	size_t soap_flag_TOTAL_USCOREMEMORY = 1;
	size_t soap_flag_TYPE_USCORECHANGE = 1;
	size_t soap_flag_U = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HandleServerPhysicalInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest, sizeof(struct ns4__HandleServerPhysicalInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HandleServerPhysicalInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ASSET_USCORECODE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ASSET_CODE", &a->ASSET_USCORECODE, "xsd:string"))
				{	soap_flag_ASSET_USCORECODE--;
					continue;
				}
			if (soap_flag_BAY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BAY", &a->BAY, "xsd:string"))
				{	soap_flag_BAY--;
					continue;
				}
			if (soap_flag_BUCKET && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BUCKET", &a->BUCKET, "xsd:string"))
				{	soap_flag_BUCKET--;
					continue;
				}
			if (soap_flag_CPU && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CPU", &a->CPU, "xsd:string"))
				{	soap_flag_CPU--;
					continue;
				}
			if (soap_flag_HDD_USCORESIZE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:HDD_SIZE", &a->HDD_USCORESIZE, "xsd:string"))
				{	soap_flag_HDD_USCORESIZE--;
					continue;
				}
			if (soap_flag_IP_USCORECHASSIS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IP_CHASSIS", &a->IP_USCORECHASSIS, "xsd:string"))
				{	soap_flag_IP_USCORECHASSIS--;
					continue;
				}
			if (soap_flag_IP_USCORECONSOLE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IP_CONSOLE", &a->IP_USCORECONSOLE, "xsd:string"))
				{	soap_flag_IP_USCORECONSOLE--;
					continue;
				}
			if (soap_flag_OS_USCOREHDD_USCORERAID_USCORETYPE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_HDD_RAID_TYPE", &a->OS_USCOREHDD_USCORERAID_USCORETYPE, "xsd:string"))
				{	soap_flag_OS_USCOREHDD_USCORERAID_USCORETYPE--;
					continue;
				}
			if (soap_flag_PRODUCT_USCORECODE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PRODUCT_CODE", &a->PRODUCT_USCORECODE, "xsd:string"))
				{	soap_flag_PRODUCT_USCORECODE--;
					continue;
				}
			if (soap_flag_RACK && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RACK", &a->RACK, "xsd:string"))
				{	soap_flag_RACK--;
					continue;
				}
			if (soap_flag_RAM && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RAM", &a->RAM, "xsd:string"))
				{	soap_flag_RAM--;
					continue;
				}
			if (soap_flag_SERIAL_USCORENUMBER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SERIAL_NUMBER", &a->SERIAL_USCORENUMBER, "xsd:string"))
				{	soap_flag_SERIAL_USCORENUMBER--;
					continue;
				}
			if (soap_flag_SERVER_USCOREMODEL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SERVER_MODEL", &a->SERVER_USCOREMODEL, "xsd:string"))
				{	soap_flag_SERVER_USCOREMODEL--;
					continue;
				}
			if (soap_flag_SITE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SITE", &a->SITE, "xsd:string"))
				{	soap_flag_SITE--;
					continue;
				}
			if (soap_flag_STATUS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STATUS", &a->STATUS, "xsd:string"))
				{	soap_flag_STATUS--;
					continue;
				}
			if (soap_flag_TOTAL_USCOREMEMORY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TOTAL_MEMORY", &a->TOTAL_USCOREMEMORY, "xsd:string"))
				{	soap_flag_TOTAL_USCOREMEMORY--;
					continue;
				}
			if (soap_flag_TYPE_USCORECHANGE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TYPE_CHANGE", &a->TYPE_USCORECHANGE, "xsd:string"))
				{	soap_flag_TYPE_USCORECHANGE--;
					continue;
				}
			if (soap_flag_U && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:U", &a->U, "xsd:string"))
				{	soap_flag_U--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__HandleServerPhysicalInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest, 0, sizeof(struct ns4__HandleServerPhysicalInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HandleServerPhysicalInfoRequest(struct soap *soap, const struct ns4__HandleServerPhysicalInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest);
	if (soap_out_ns4__HandleServerPhysicalInfoRequest(soap, tag?tag:"ns4:HandleServerPhysicalInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HandleServerPhysicalInfoRequest * SOAP_FMAC4 soap_get_ns4__HandleServerPhysicalInfoRequest(struct soap *soap, struct ns4__HandleServerPhysicalInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HandleServerPhysicalInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ServerInfo(struct soap *soap, struct ns4__ServerInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPAddress);
	soap_default_string(soap, &a->MacAddress);
	soap_default_string(soap, &a->SerialNumber);
	soap_default_string(soap, &a->ServerKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ServerInfo(struct soap *soap, const struct ns4__ServerInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->IPAddress);
	soap_serialize_string(soap, &a->MacAddress);
	soap_serialize_string(soap, &a->SerialNumber);
	soap_serialize_string(soap, &a->ServerKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ServerInfo(struct soap *soap, const char *tag, int id, const struct ns4__ServerInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ServerInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPAddress", -1, &a->IPAddress, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MacAddress", -1, &a->MacAddress, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SerialNumber", -1, &a->SerialNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ServerKey", -1, &a->ServerKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ServerInfo * SOAP_FMAC4 soap_in_ns4__ServerInfo(struct soap *soap, const char *tag, struct ns4__ServerInfo *a, const char *type)
{
	size_t soap_flag_IPAddress = 1;
	size_t soap_flag_MacAddress = 1;
	size_t soap_flag_SerialNumber = 1;
	size_t soap_flag_ServerKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ServerInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ServerInfo, sizeof(struct ns4__ServerInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ServerInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPAddress", &a->IPAddress, "xsd:string"))
				{	soap_flag_IPAddress--;
					continue;
				}
			if (soap_flag_MacAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MacAddress", &a->MacAddress, "xsd:string"))
				{	soap_flag_MacAddress--;
					continue;
				}
			if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SerialNumber", &a->SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber--;
					continue;
				}
			if (soap_flag_ServerKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ServerKey", &a->ServerKey, "xsd:string"))
				{	soap_flag_ServerKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ServerInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ServerInfo, 0, sizeof(struct ns4__ServerInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ServerInfo(struct soap *soap, const struct ns4__ServerInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__ServerInfo);
	if (soap_out_ns4__ServerInfo(soap, tag?tag:"ns4:ServerInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ServerInfo * SOAP_FMAC4 soap_get_ns4__ServerInfo(struct soap *soap, struct ns4__ServerInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ServerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SDKUpdateIpMacRequest(struct soap *soap, struct ns4__SDKUpdateIpMacRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IP_USCOREPrivate = NULL;
	a->IP_USCOREPublic = NULL;
	soap_default_string(soap, &a->OS_USCOREVersion);
	soap_default_string(soap, &a->SW_USCOREList);
	soap_default_string(soap, &a->Serial_USCORENumber);
	soap_default_string(soap, &a->Server_USCOREName);
	soap_default_string(soap, &a->Zbx_USCORELast_USCOREClock);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SDKUpdateIpMacRequest(struct soap *soap, const struct ns4__SDKUpdateIpMacRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfInterfaceAddress(soap, &a->IP_USCOREPrivate);
	soap_serialize_PointerTons4__ArrayOfInterfaceAddress(soap, &a->IP_USCOREPublic);
	soap_serialize_string(soap, &a->OS_USCOREVersion);
	soap_serialize_string(soap, &a->SW_USCOREList);
	soap_serialize_string(soap, &a->Serial_USCORENumber);
	soap_serialize_string(soap, &a->Server_USCOREName);
	soap_serialize_string(soap, &a->Zbx_USCORELast_USCOREClock);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SDKUpdateIpMacRequest(struct soap *soap, const char *tag, int id, const struct ns4__SDKUpdateIpMacRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SDKUpdateIpMacRequest), type))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Private", -1, &a->IP_USCOREPrivate, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Public", -1, &a->IP_USCOREPublic, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_Version", -1, &a->OS_USCOREVersion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SW_List", -1, &a->SW_USCOREList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Serial_Number", -1, &a->Serial_USCORENumber, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Server_Name", -1, &a->Server_USCOREName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Zbx_Last_Clock", -1, &a->Zbx_USCORELast_USCOREClock, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SDKUpdateIpMacRequest * SOAP_FMAC4 soap_in_ns4__SDKUpdateIpMacRequest(struct soap *soap, const char *tag, struct ns4__SDKUpdateIpMacRequest *a, const char *type)
{
	size_t soap_flag_IP_USCOREPrivate = 1;
	size_t soap_flag_IP_USCOREPublic = 1;
	size_t soap_flag_OS_USCOREVersion = 1;
	size_t soap_flag_SW_USCOREList = 1;
	size_t soap_flag_Serial_USCORENumber = 1;
	size_t soap_flag_Server_USCOREName = 1;
	size_t soap_flag_Zbx_USCORELast_USCOREClock = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SDKUpdateIpMacRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SDKUpdateIpMacRequest, sizeof(struct ns4__SDKUpdateIpMacRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SDKUpdateIpMacRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IP_USCOREPrivate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Private", &a->IP_USCOREPrivate, "ns4:ArrayOfInterfaceAddress"))
				{	soap_flag_IP_USCOREPrivate--;
					continue;
				}
			if (soap_flag_IP_USCOREPublic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Public", &a->IP_USCOREPublic, "ns4:ArrayOfInterfaceAddress"))
				{	soap_flag_IP_USCOREPublic--;
					continue;
				}
			if (soap_flag_OS_USCOREVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_Version", &a->OS_USCOREVersion, "xsd:string"))
				{	soap_flag_OS_USCOREVersion--;
					continue;
				}
			if (soap_flag_SW_USCOREList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SW_List", &a->SW_USCOREList, "xsd:string"))
				{	soap_flag_SW_USCOREList--;
					continue;
				}
			if (soap_flag_Serial_USCORENumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Serial_Number", &a->Serial_USCORENumber, "xsd:string"))
				{	soap_flag_Serial_USCORENumber--;
					continue;
				}
			if (soap_flag_Server_USCOREName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Server_Name", &a->Server_USCOREName, "xsd:string"))
				{	soap_flag_Server_USCOREName--;
					continue;
				}
			if (soap_flag_Zbx_USCORELast_USCOREClock && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Zbx_Last_Clock", &a->Zbx_USCORELast_USCOREClock, "xsd:string"))
				{	soap_flag_Zbx_USCORELast_USCOREClock--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKUpdateIpMacRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SDKUpdateIpMacRequest, 0, sizeof(struct ns4__SDKUpdateIpMacRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SDKUpdateIpMacRequest(struct soap *soap, const struct ns4__SDKUpdateIpMacRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SDKUpdateIpMacRequest);
	if (soap_out_ns4__SDKUpdateIpMacRequest(soap, tag?tag:"ns4:SDKUpdateIpMacRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKUpdateIpMacRequest * SOAP_FMAC4 soap_get_ns4__SDKUpdateIpMacRequest(struct soap *soap, struct ns4__SDKUpdateIpMacRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SDKUpdateIpMacRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SDKPostRequest(struct soap *soap, struct ns4__SDKPostRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Checksum);
	soap_default_string(soap, &a->ClientId);
	a->DataFormat = NULL;
	a->GetHostInfoRequest = NULL;
	soap_default_string(soap, &a->Operation);
	soap_default_string(soap, &a->RequestData);
	a->RequestTime = NULL;
	soap_default_string(soap, &a->Signature);
	a->theCMDBV2_USCOREGetServerDetailRequest = NULL;
	a->theCMDBV2_USCOREHandleServerVMInfoRequest = NULL;
	a->theCMDBV2_USCORESDKUpdateIpMacRequest = NULL;
	a->theGetCCUByProductCodeRequest = NULL;
	a->theGetIRDServerVMInfoRequest = NULL;
	a->theGetIRDTechnicalOwnerInfoRequest = NULL;
	a->theGetListAllServerRequest = NULL;
	a->theGetODAHostInfoListRequest = NULL;
	a->theGetODAServerInfoListRequest = NULL;
	a->theGetProductInfoByIPRequest = NULL;
	a->theGetSDKServerInfoListRequest = NULL;
	a->theGetSO6InfoServerRequest = NULL;
	a->theGetServerNameBySerialRequest = NULL;
	a->theGetSnSInfoTechnicalOwnerRequest = NULL;
	a->theHandleServerVMInfoRequest = NULL;
	a->theHostInfoRequest = NULL;
	a->theInsertDataServerVMRequest = NULL;
	a->theInsertMeasuredDataRequest = NULL;
	a->theItemValueRequest = NULL;
	a->theMacAddressRequest = NULL;
	a->theOpenIncidentByCSRequest = NULL;
	a->theOpenIncidentByDCRequest = NULL;
	a->theOpenIncidentByG8Request = NULL;
	a->theRemoveDataServerVMRequest = NULL;
	a->theSDKPostRequest = NULL;
	a->theSDKUpdateIpMacRequest = NULL;
	a->theServerInfo = NULL;
	a->theUpdateDataServerPhysicalRequest = NULL;
	a->theUpdateDataServerVMRequest = NULL;
	a->theUpdateInfoRequest = NULL;
	a->theUpdateServerStatusRequest = NULL;
	a->PostData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SDKPostRequest(struct soap *soap, const struct ns4__SDKPostRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Checksum);
	soap_serialize_string(soap, &a->ClientId);
	soap_serialize_PointerTons4__DataFormatEnum(soap, &a->DataFormat);
	soap_serialize_PointerTons4__GetGSOCCURequest(soap, &a->GetHostInfoRequest);
	soap_serialize_string(soap, &a->Operation);
	soap_serialize_string(soap, &a->RequestData);
	soap_serialize_PointerTounsignedInt(soap, &a->RequestTime);
	soap_serialize_string(soap, &a->Signature);
	soap_serialize_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, &a->theCMDBV2_USCOREGetServerDetailRequest);
	soap_serialize_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, &a->theCMDBV2_USCOREHandleServerVMInfoRequest);
	soap_serialize_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, &a->theCMDBV2_USCORESDKUpdateIpMacRequest);
	soap_serialize_PointerTons4__GetCCUByProductCodeRequest(soap, &a->theGetCCUByProductCodeRequest);
	soap_serialize_PointerTons4__GetIRDServerVMInfoRequest(soap, &a->theGetIRDServerVMInfoRequest);
	soap_serialize_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, &a->theGetIRDTechnicalOwnerInfoRequest);
	soap_serialize_PointerTons4__GetListAllServerRequest(soap, &a->theGetListAllServerRequest);
	soap_serialize_PointerTons4__GetODAHostInfoListRequest(soap, &a->theGetODAHostInfoListRequest);
	soap_serialize_PointerTons4__GetODAServerInfoListRequest(soap, &a->theGetODAServerInfoListRequest);
	soap_serialize_PointerTons4__GetProductInfoByIPRequest(soap, &a->theGetProductInfoByIPRequest);
	soap_serialize_PointerTons4__GetSDKServerInfoListRequest(soap, &a->theGetSDKServerInfoListRequest);
	soap_serialize_PointerTons4__GetSO6InfoServerRequest(soap, &a->theGetSO6InfoServerRequest);
	soap_serialize_PointerTons4__GetServerNameBySerialNumberRequest(soap, &a->theGetServerNameBySerialRequest);
	soap_serialize_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, &a->theGetSnSInfoTechnicalOwnerRequest);
	soap_serialize_PointerTons4__HandleServerVMInfoRequest(soap, &a->theHandleServerVMInfoRequest);
	soap_serialize_PointerTons4__GetHostsInfoRequest(soap, &a->theHostInfoRequest);
	soap_serialize_PointerTons4__InsertDataServerVMRequest(soap, &a->theInsertDataServerVMRequest);
	soap_serialize_PointerTons4__InsertMeasuredDataRequest(soap, &a->theInsertMeasuredDataRequest);
	soap_serialize_PointerTons4__GetItemValueListRequest(soap, &a->theItemValueRequest);
	soap_serialize_PointerTons4__GetHostInfoByIPRequest(soap, &a->theMacAddressRequest);
	soap_serialize_PointerTons4__OpenIncidentByCSRequest(soap, &a->theOpenIncidentByCSRequest);
	soap_serialize_PointerTons4__OpenIncidentByDCRequest(soap, &a->theOpenIncidentByDCRequest);
	soap_serialize_PointerTons4__OpenIncidentByG8Request(soap, &a->theOpenIncidentByG8Request);
	soap_serialize_PointerTons4__RemoveDataServerVMRequest(soap, &a->theRemoveDataServerVMRequest);
	soap_serialize_PointerTons4__SDKPostRequest(soap, &a->theSDKPostRequest);
	soap_serialize_PointerTons4__SDKUpdateIpMacRequest(soap, &a->theSDKUpdateIpMacRequest);
	soap_serialize_PointerTons4__ServerInfo(soap, &a->theServerInfo);
	soap_serialize_PointerTons4__HandleServerPhysicalInfoRequest(soap, &a->theUpdateDataServerPhysicalRequest);
	soap_serialize_PointerTons4__UpdateDataServerVMRequest(soap, &a->theUpdateDataServerVMRequest);
	soap_serialize_PointerTons4__UpdateInfoRequest(soap, &a->theUpdateInfoRequest);
	soap_serialize_PointerTons4__UpdateServerStatusRequest(soap, &a->theUpdateServerStatusRequest);
	soap_serialize_PointerTons5__ArrayOfbase64Binary(soap, &a->PostData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SDKPostRequest(struct soap *soap, const char *tag, int id, const struct ns4__SDKPostRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SDKPostRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:Checksum", -1, &a->Checksum, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ClientId", -1, &a->ClientId, ""))
		return soap->error;
	if (soap_out_PointerTons4__DataFormatEnum(soap, "ns4:DataFormat", -1, &a->DataFormat, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetGSOCCURequest(soap, "ns4:GetHostInfoRequest", -1, &a->GetHostInfoRequest, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Operation", -1, &a->Operation, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RequestData", -1, &a->RequestData, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:RequestTime", -1, &a->RequestTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Signature", -1, &a->Signature, ""))
		return soap->error;
	if (soap_out_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, "ns4:theCMDBV2_GetServerDetailRequest", -1, &a->theCMDBV2_USCOREGetServerDetailRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, "ns4:theCMDBV2_HandleServerVMInfoRequest", -1, &a->theCMDBV2_USCOREHandleServerVMInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, "ns4:theCMDBV2_SDKUpdateIpMacRequest", -1, &a->theCMDBV2_USCORESDKUpdateIpMacRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetCCUByProductCodeRequest(soap, "ns4:theGetCCUByProductCodeRequest", -1, &a->theGetCCUByProductCodeRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetIRDServerVMInfoRequest(soap, "ns4:theGetIRDServerVMInfoRequest", -1, &a->theGetIRDServerVMInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, "ns4:theGetIRDTechnicalOwnerInfoRequest", -1, &a->theGetIRDTechnicalOwnerInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetListAllServerRequest(soap, "ns4:theGetListAllServerRequest", -1, &a->theGetListAllServerRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetODAHostInfoListRequest(soap, "ns4:theGetODAHostInfoListRequest", -1, &a->theGetODAHostInfoListRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetODAServerInfoListRequest(soap, "ns4:theGetODAServerInfoListRequest", -1, &a->theGetODAServerInfoListRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetProductInfoByIPRequest(soap, "ns4:theGetProductInfoByIPRequest", -1, &a->theGetProductInfoByIPRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetSDKServerInfoListRequest(soap, "ns4:theGetSDKServerInfoListRequest", -1, &a->theGetSDKServerInfoListRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetSO6InfoServerRequest(soap, "ns4:theGetSO6InfoServerRequest", -1, &a->theGetSO6InfoServerRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetServerNameBySerialNumberRequest(soap, "ns4:theGetServerNameBySerialRequest", -1, &a->theGetServerNameBySerialRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, "ns4:theGetSnSInfoTechnicalOwnerRequest", -1, &a->theGetSnSInfoTechnicalOwnerRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__HandleServerVMInfoRequest(soap, "ns4:theHandleServerVMInfoRequest", -1, &a->theHandleServerVMInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetHostsInfoRequest(soap, "ns4:theHostInfoRequest", -1, &a->theHostInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__InsertDataServerVMRequest(soap, "ns4:theInsertDataServerVMRequest", -1, &a->theInsertDataServerVMRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__InsertMeasuredDataRequest(soap, "ns4:theInsertMeasuredDataRequest", -1, &a->theInsertMeasuredDataRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetItemValueListRequest(soap, "ns4:theItemValueRequest", -1, &a->theItemValueRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetHostInfoByIPRequest(soap, "ns4:theMacAddressRequest", -1, &a->theMacAddressRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__OpenIncidentByCSRequest(soap, "ns4:theOpenIncidentByCSRequest", -1, &a->theOpenIncidentByCSRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__OpenIncidentByDCRequest(soap, "ns4:theOpenIncidentByDCRequest", -1, &a->theOpenIncidentByDCRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__OpenIncidentByG8Request(soap, "ns4:theOpenIncidentByG8Request", -1, &a->theOpenIncidentByG8Request, ""))
		return soap->error;
	if (soap_out_PointerTons4__RemoveDataServerVMRequest(soap, "ns4:theRemoveDataServerVMRequest", -1, &a->theRemoveDataServerVMRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__SDKPostRequest(soap, "ns4:theSDKPostRequest", -1, &a->theSDKPostRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__SDKUpdateIpMacRequest(soap, "ns4:theSDKUpdateIpMacRequest", -1, &a->theSDKUpdateIpMacRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__ServerInfo(soap, "ns4:theServerInfo", -1, &a->theServerInfo, ""))
		return soap->error;
	if (soap_out_PointerTons4__HandleServerPhysicalInfoRequest(soap, "ns4:theUpdateDataServerPhysicalRequest", -1, &a->theUpdateDataServerPhysicalRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__UpdateDataServerVMRequest(soap, "ns4:theUpdateDataServerVMRequest", -1, &a->theUpdateDataServerVMRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__UpdateInfoRequest(soap, "ns4:theUpdateInfoRequest", -1, &a->theUpdateInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__UpdateServerStatusRequest(soap, "ns4:theUpdateServerStatusRequest", -1, &a->theUpdateServerStatusRequest, ""))
		return soap->error;
	if (soap_out_PointerTons5__ArrayOfbase64Binary(soap, "ns4:PostData", -1, &a->PostData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SDKPostRequest * SOAP_FMAC4 soap_in_ns4__SDKPostRequest(struct soap *soap, const char *tag, struct ns4__SDKPostRequest *a, const char *type)
{
	size_t soap_flag_Checksum = 1;
	size_t soap_flag_ClientId = 1;
	size_t soap_flag_DataFormat = 1;
	size_t soap_flag_GetHostInfoRequest = 1;
	size_t soap_flag_Operation = 1;
	size_t soap_flag_RequestData = 1;
	size_t soap_flag_RequestTime = 1;
	size_t soap_flag_Signature = 1;
	size_t soap_flag_theCMDBV2_USCOREGetServerDetailRequest = 1;
	size_t soap_flag_theCMDBV2_USCOREHandleServerVMInfoRequest = 1;
	size_t soap_flag_theCMDBV2_USCORESDKUpdateIpMacRequest = 1;
	size_t soap_flag_theGetCCUByProductCodeRequest = 1;
	size_t soap_flag_theGetIRDServerVMInfoRequest = 1;
	size_t soap_flag_theGetIRDTechnicalOwnerInfoRequest = 1;
	size_t soap_flag_theGetListAllServerRequest = 1;
	size_t soap_flag_theGetODAHostInfoListRequest = 1;
	size_t soap_flag_theGetODAServerInfoListRequest = 1;
	size_t soap_flag_theGetProductInfoByIPRequest = 1;
	size_t soap_flag_theGetSDKServerInfoListRequest = 1;
	size_t soap_flag_theGetSO6InfoServerRequest = 1;
	size_t soap_flag_theGetServerNameBySerialRequest = 1;
	size_t soap_flag_theGetSnSInfoTechnicalOwnerRequest = 1;
	size_t soap_flag_theHandleServerVMInfoRequest = 1;
	size_t soap_flag_theHostInfoRequest = 1;
	size_t soap_flag_theInsertDataServerVMRequest = 1;
	size_t soap_flag_theInsertMeasuredDataRequest = 1;
	size_t soap_flag_theItemValueRequest = 1;
	size_t soap_flag_theMacAddressRequest = 1;
	size_t soap_flag_theOpenIncidentByCSRequest = 1;
	size_t soap_flag_theOpenIncidentByDCRequest = 1;
	size_t soap_flag_theOpenIncidentByG8Request = 1;
	size_t soap_flag_theRemoveDataServerVMRequest = 1;
	size_t soap_flag_theSDKPostRequest = 1;
	size_t soap_flag_theSDKUpdateIpMacRequest = 1;
	size_t soap_flag_theServerInfo = 1;
	size_t soap_flag_theUpdateDataServerPhysicalRequest = 1;
	size_t soap_flag_theUpdateDataServerVMRequest = 1;
	size_t soap_flag_theUpdateInfoRequest = 1;
	size_t soap_flag_theUpdateServerStatusRequest = 1;
	size_t soap_flag_PostData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SDKPostRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SDKPostRequest, sizeof(struct ns4__SDKPostRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SDKPostRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Checksum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Checksum", &a->Checksum, "xsd:string"))
				{	soap_flag_Checksum--;
					continue;
				}
			if (soap_flag_ClientId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ClientId", &a->ClientId, "xsd:string"))
				{	soap_flag_ClientId--;
					continue;
				}
			if (soap_flag_DataFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DataFormatEnum(soap, "ns4:DataFormat", &a->DataFormat, "ns4:DataFormatEnum"))
				{	soap_flag_DataFormat--;
					continue;
				}
			if (soap_flag_GetHostInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetGSOCCURequest(soap, "ns4:GetHostInfoRequest", &a->GetHostInfoRequest, "ns4:GetGSOCCURequest"))
				{	soap_flag_GetHostInfoRequest--;
					continue;
				}
			if (soap_flag_Operation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Operation", &a->Operation, "xsd:string"))
				{	soap_flag_Operation--;
					continue;
				}
			if (soap_flag_RequestData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RequestData", &a->RequestData, "xsd:string"))
				{	soap_flag_RequestData--;
					continue;
				}
			if (soap_flag_RequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:RequestTime", &a->RequestTime, "xsd:unsignedInt"))
				{	soap_flag_RequestTime--;
					continue;
				}
			if (soap_flag_Signature && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Signature", &a->Signature, "xsd:string"))
				{	soap_flag_Signature--;
					continue;
				}
			if (soap_flag_theCMDBV2_USCOREGetServerDetailRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, "ns4:theCMDBV2_GetServerDetailRequest", &a->theCMDBV2_USCOREGetServerDetailRequest, "ns4:CMDBV2_GetServerDetailRequest"))
				{	soap_flag_theCMDBV2_USCOREGetServerDetailRequest--;
					continue;
				}
			if (soap_flag_theCMDBV2_USCOREHandleServerVMInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, "ns4:theCMDBV2_HandleServerVMInfoRequest", &a->theCMDBV2_USCOREHandleServerVMInfoRequest, "ns4:CMDBV2_HandleServerVMInfoRequest"))
				{	soap_flag_theCMDBV2_USCOREHandleServerVMInfoRequest--;
					continue;
				}
			if (soap_flag_theCMDBV2_USCORESDKUpdateIpMacRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, "ns4:theCMDBV2_SDKUpdateIpMacRequest", &a->theCMDBV2_USCORESDKUpdateIpMacRequest, "ns4:CMDBv2_SDKUpdateIpMacRequest"))
				{	soap_flag_theCMDBV2_USCORESDKUpdateIpMacRequest--;
					continue;
				}
			if (soap_flag_theGetCCUByProductCodeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetCCUByProductCodeRequest(soap, "ns4:theGetCCUByProductCodeRequest", &a->theGetCCUByProductCodeRequest, "ns4:GetCCUByProductCodeRequest"))
				{	soap_flag_theGetCCUByProductCodeRequest--;
					continue;
				}
			if (soap_flag_theGetIRDServerVMInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetIRDServerVMInfoRequest(soap, "ns4:theGetIRDServerVMInfoRequest", &a->theGetIRDServerVMInfoRequest, "ns4:GetIRDServerVMInfoRequest"))
				{	soap_flag_theGetIRDServerVMInfoRequest--;
					continue;
				}
			if (soap_flag_theGetIRDTechnicalOwnerInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, "ns4:theGetIRDTechnicalOwnerInfoRequest", &a->theGetIRDTechnicalOwnerInfoRequest, "ns4:GetIRDTechnicalOwnerInfoRequest"))
				{	soap_flag_theGetIRDTechnicalOwnerInfoRequest--;
					continue;
				}
			if (soap_flag_theGetListAllServerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetListAllServerRequest(soap, "ns4:theGetListAllServerRequest", &a->theGetListAllServerRequest, "ns4:GetListAllServerRequest"))
				{	soap_flag_theGetListAllServerRequest--;
					continue;
				}
			if (soap_flag_theGetODAHostInfoListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetODAHostInfoListRequest(soap, "ns4:theGetODAHostInfoListRequest", &a->theGetODAHostInfoListRequest, "ns4:GetODAHostInfoListRequest"))
				{	soap_flag_theGetODAHostInfoListRequest--;
					continue;
				}
			if (soap_flag_theGetODAServerInfoListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetODAServerInfoListRequest(soap, "ns4:theGetODAServerInfoListRequest", &a->theGetODAServerInfoListRequest, "ns4:GetODAServerInfoListRequest"))
				{	soap_flag_theGetODAServerInfoListRequest--;
					continue;
				}
			if (soap_flag_theGetProductInfoByIPRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetProductInfoByIPRequest(soap, "ns4:theGetProductInfoByIPRequest", &a->theGetProductInfoByIPRequest, "ns4:GetProductInfoByIPRequest"))
				{	soap_flag_theGetProductInfoByIPRequest--;
					continue;
				}
			if (soap_flag_theGetSDKServerInfoListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetSDKServerInfoListRequest(soap, "ns4:theGetSDKServerInfoListRequest", &a->theGetSDKServerInfoListRequest, "ns4:GetSDKServerInfoListRequest"))
				{	soap_flag_theGetSDKServerInfoListRequest--;
					continue;
				}
			if (soap_flag_theGetSO6InfoServerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetSO6InfoServerRequest(soap, "ns4:theGetSO6InfoServerRequest", &a->theGetSO6InfoServerRequest, "ns4:GetSO6InfoServerRequest"))
				{	soap_flag_theGetSO6InfoServerRequest--;
					continue;
				}
			if (soap_flag_theGetServerNameBySerialRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetServerNameBySerialNumberRequest(soap, "ns4:theGetServerNameBySerialRequest", &a->theGetServerNameBySerialRequest, "ns4:GetServerNameBySerialNumberRequest"))
				{	soap_flag_theGetServerNameBySerialRequest--;
					continue;
				}
			if (soap_flag_theGetSnSInfoTechnicalOwnerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, "ns4:theGetSnSInfoTechnicalOwnerRequest", &a->theGetSnSInfoTechnicalOwnerRequest, "ns4:GetSnSInfoTechnicalOwnerRequest"))
				{	soap_flag_theGetSnSInfoTechnicalOwnerRequest--;
					continue;
				}
			if (soap_flag_theHandleServerVMInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HandleServerVMInfoRequest(soap, "ns4:theHandleServerVMInfoRequest", &a->theHandleServerVMInfoRequest, "ns4:HandleServerVMInfoRequest"))
				{	soap_flag_theHandleServerVMInfoRequest--;
					continue;
				}
			if (soap_flag_theHostInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetHostsInfoRequest(soap, "ns4:theHostInfoRequest", &a->theHostInfoRequest, "ns4:GetHostsInfoRequest"))
				{	soap_flag_theHostInfoRequest--;
					continue;
				}
			if (soap_flag_theInsertDataServerVMRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__InsertDataServerVMRequest(soap, "ns4:theInsertDataServerVMRequest", &a->theInsertDataServerVMRequest, "ns4:InsertDataServerVMRequest"))
				{	soap_flag_theInsertDataServerVMRequest--;
					continue;
				}
			if (soap_flag_theInsertMeasuredDataRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__InsertMeasuredDataRequest(soap, "ns4:theInsertMeasuredDataRequest", &a->theInsertMeasuredDataRequest, "ns4:InsertMeasuredDataRequest"))
				{	soap_flag_theInsertMeasuredDataRequest--;
					continue;
				}
			if (soap_flag_theItemValueRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetItemValueListRequest(soap, "ns4:theItemValueRequest", &a->theItemValueRequest, "ns4:GetItemValueListRequest"))
				{	soap_flag_theItemValueRequest--;
					continue;
				}
			if (soap_flag_theMacAddressRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetHostInfoByIPRequest(soap, "ns4:theMacAddressRequest", &a->theMacAddressRequest, "ns4:GetHostInfoByIPRequest"))
				{	soap_flag_theMacAddressRequest--;
					continue;
				}
			if (soap_flag_theOpenIncidentByCSRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OpenIncidentByCSRequest(soap, "ns4:theOpenIncidentByCSRequest", &a->theOpenIncidentByCSRequest, "ns4:OpenIncidentByCSRequest"))
				{	soap_flag_theOpenIncidentByCSRequest--;
					continue;
				}
			if (soap_flag_theOpenIncidentByDCRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OpenIncidentByDCRequest(soap, "ns4:theOpenIncidentByDCRequest", &a->theOpenIncidentByDCRequest, "ns4:OpenIncidentByDCRequest"))
				{	soap_flag_theOpenIncidentByDCRequest--;
					continue;
				}
			if (soap_flag_theOpenIncidentByG8Request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OpenIncidentByG8Request(soap, "ns4:theOpenIncidentByG8Request", &a->theOpenIncidentByG8Request, "ns4:OpenIncidentByG8Request"))
				{	soap_flag_theOpenIncidentByG8Request--;
					continue;
				}
			if (soap_flag_theRemoveDataServerVMRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RemoveDataServerVMRequest(soap, "ns4:theRemoveDataServerVMRequest", &a->theRemoveDataServerVMRequest, "ns4:RemoveDataServerVMRequest"))
				{	soap_flag_theRemoveDataServerVMRequest--;
					continue;
				}
			if (soap_flag_theSDKPostRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SDKPostRequest(soap, "ns4:theSDKPostRequest", &a->theSDKPostRequest, "ns4:SDKPostRequest"))
				{	soap_flag_theSDKPostRequest--;
					continue;
				}
			if (soap_flag_theSDKUpdateIpMacRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SDKUpdateIpMacRequest(soap, "ns4:theSDKUpdateIpMacRequest", &a->theSDKUpdateIpMacRequest, "ns4:SDKUpdateIpMacRequest"))
				{	soap_flag_theSDKUpdateIpMacRequest--;
					continue;
				}
			if (soap_flag_theServerInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ServerInfo(soap, "ns4:theServerInfo", &a->theServerInfo, "ns4:ServerInfo"))
				{	soap_flag_theServerInfo--;
					continue;
				}
			if (soap_flag_theUpdateDataServerPhysicalRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HandleServerPhysicalInfoRequest(soap, "ns4:theUpdateDataServerPhysicalRequest", &a->theUpdateDataServerPhysicalRequest, "ns4:HandleServerPhysicalInfoRequest"))
				{	soap_flag_theUpdateDataServerPhysicalRequest--;
					continue;
				}
			if (soap_flag_theUpdateDataServerVMRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateDataServerVMRequest(soap, "ns4:theUpdateDataServerVMRequest", &a->theUpdateDataServerVMRequest, "ns4:UpdateDataServerVMRequest"))
				{	soap_flag_theUpdateDataServerVMRequest--;
					continue;
				}
			if (soap_flag_theUpdateInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateInfoRequest(soap, "ns4:theUpdateInfoRequest", &a->theUpdateInfoRequest, "ns4:UpdateInfoRequest"))
				{	soap_flag_theUpdateInfoRequest--;
					continue;
				}
			if (soap_flag_theUpdateServerStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateServerStatusRequest(soap, "ns4:theUpdateServerStatusRequest", &a->theUpdateServerStatusRequest, "ns4:UpdateServerStatusRequest"))
				{	soap_flag_theUpdateServerStatusRequest--;
					continue;
				}
			if (soap_flag_PostData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ArrayOfbase64Binary(soap, "ns4:PostData", &a->PostData, "ns5:ArrayOfbase64Binary"))
				{	soap_flag_PostData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKPostRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SDKPostRequest, 0, sizeof(struct ns4__SDKPostRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SDKPostRequest(struct soap *soap, const struct ns4__SDKPostRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SDKPostRequest);
	if (soap_out_ns4__SDKPostRequest(soap, tag?tag:"ns4:SDKPostRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKPostRequest * SOAP_FMAC4 soap_get_ns4__SDKPostRequest(struct soap *soap, struct ns4__SDKPostRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SDKPostRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__RemoveDataServerVMRequest(struct soap *soap, struct ns4__RemoveDataServerVMRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->VM_USCOREKEY);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__RemoveDataServerVMRequest(struct soap *soap, const struct ns4__RemoveDataServerVMRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->VM_USCOREKEY);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RemoveDataServerVMRequest(struct soap *soap, const char *tag, int id, const struct ns4__RemoveDataServerVMRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__RemoveDataServerVMRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:VID", -1, &a->VID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_KEY", -1, &a->VM_USCOREKEY, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__RemoveDataServerVMRequest * SOAP_FMAC4 soap_in_ns4__RemoveDataServerVMRequest(struct soap *soap, const char *tag, struct ns4__RemoveDataServerVMRequest *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_VM_USCOREKEY = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__RemoveDataServerVMRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__RemoveDataServerVMRequest, sizeof(struct ns4__RemoveDataServerVMRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__RemoveDataServerVMRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_VM_USCOREKEY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_KEY", &a->VM_USCOREKEY, "xsd:string"))
				{	soap_flag_VM_USCOREKEY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__RemoveDataServerVMRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__RemoveDataServerVMRequest, 0, sizeof(struct ns4__RemoveDataServerVMRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__RemoveDataServerVMRequest(struct soap *soap, const struct ns4__RemoveDataServerVMRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__RemoveDataServerVMRequest);
	if (soap_out_ns4__RemoveDataServerVMRequest(soap, tag?tag:"ns4:RemoveDataServerVMRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__RemoveDataServerVMRequest * SOAP_FMAC4 soap_get_ns4__RemoveDataServerVMRequest(struct soap *soap, struct ns4__RemoveDataServerVMRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RemoveDataServerVMRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__OpenIncidentByG8Request(struct soap *soap, struct ns4__OpenIncidentByG8Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Action = NULL;
	soap_default_string(soap, &a->AffectedDeals);
	soap_default_string(soap, &a->AttachmentList);
	soap_default_string(soap, &a->CCList);
	soap_default_string(soap, &a->CurrentStatus);
	soap_default_string(soap, &a->Description);
	a->ImpactedCustomerCount = NULL;
	soap_default_string(soap, &a->IncidentCode);
	a->OutageStart = NULL;
	soap_default_string(soap, &a->ProductAlias);
	soap_default_string(soap, &a->Title);
	soap_default_string(soap, &a->ToList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__OpenIncidentByG8Request(struct soap *soap, const struct ns4__OpenIncidentByG8Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__G8Action(soap, &a->Action);
	soap_serialize_string(soap, &a->AffectedDeals);
	soap_serialize_string(soap, &a->AttachmentList);
	soap_serialize_string(soap, &a->CCList);
	soap_serialize_string(soap, &a->CurrentStatus);
	soap_serialize_string(soap, &a->Description);
	soap_serialize_PointerToint(soap, &a->ImpactedCustomerCount);
	soap_serialize_string(soap, &a->IncidentCode);
	soap_serialize_PointerTounsignedInt(soap, &a->OutageStart);
	soap_serialize_string(soap, &a->ProductAlias);
	soap_serialize_string(soap, &a->Title);
	soap_serialize_string(soap, &a->ToList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OpenIncidentByG8Request(struct soap *soap, const char *tag, int id, const struct ns4__OpenIncidentByG8Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OpenIncidentByG8Request), type))
		return soap->error;
	if (soap_out_PointerTons4__G8Action(soap, "ns4:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AffectedDeals", -1, &a->AffectedDeals, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:AttachmentList", -1, &a->AttachmentList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CCList", -1, &a->CCList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CurrentStatus", -1, &a->CurrentStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Description", -1, &a->Description, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:ImpactedCustomerCount", -1, &a->ImpactedCustomerCount, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IncidentCode", -1, &a->IncidentCode, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:OutageStart", -1, &a->OutageStart, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ProductAlias", -1, &a->ProductAlias, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Title", -1, &a->Title, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ToList", -1, &a->ToList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__OpenIncidentByG8Request * SOAP_FMAC4 soap_in_ns4__OpenIncidentByG8Request(struct soap *soap, const char *tag, struct ns4__OpenIncidentByG8Request *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_AffectedDeals = 1;
	size_t soap_flag_AttachmentList = 1;
	size_t soap_flag_CCList = 1;
	size_t soap_flag_CurrentStatus = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_ImpactedCustomerCount = 1;
	size_t soap_flag_IncidentCode = 1;
	size_t soap_flag_OutageStart = 1;
	size_t soap_flag_ProductAlias = 1;
	size_t soap_flag_Title = 1;
	size_t soap_flag_ToList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__OpenIncidentByG8Request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OpenIncidentByG8Request, sizeof(struct ns4__OpenIncidentByG8Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__OpenIncidentByG8Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__G8Action(soap, "ns4:Action", &a->Action, "ns4:G8Action"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_AffectedDeals && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AffectedDeals", &a->AffectedDeals, "xsd:string"))
				{	soap_flag_AffectedDeals--;
					continue;
				}
			if (soap_flag_AttachmentList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:AttachmentList", &a->AttachmentList, "xsd:string"))
				{	soap_flag_AttachmentList--;
					continue;
				}
			if (soap_flag_CCList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CCList", &a->CCList, "xsd:string"))
				{	soap_flag_CCList--;
					continue;
				}
			if (soap_flag_CurrentStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CurrentStatus", &a->CurrentStatus, "xsd:string"))
				{	soap_flag_CurrentStatus--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Description", &a->Description, "xsd:string"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_ImpactedCustomerCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:ImpactedCustomerCount", &a->ImpactedCustomerCount, "xsd:int"))
				{	soap_flag_ImpactedCustomerCount--;
					continue;
				}
			if (soap_flag_IncidentCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IncidentCode", &a->IncidentCode, "xsd:string"))
				{	soap_flag_IncidentCode--;
					continue;
				}
			if (soap_flag_OutageStart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:OutageStart", &a->OutageStart, "xsd:unsignedInt"))
				{	soap_flag_OutageStart--;
					continue;
				}
			if (soap_flag_ProductAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ProductAlias", &a->ProductAlias, "xsd:string"))
				{	soap_flag_ProductAlias--;
					continue;
				}
			if (soap_flag_Title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Title", &a->Title, "xsd:string"))
				{	soap_flag_Title--;
					continue;
				}
			if (soap_flag_ToList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ToList", &a->ToList, "xsd:string"))
				{	soap_flag_ToList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__OpenIncidentByG8Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OpenIncidentByG8Request, 0, sizeof(struct ns4__OpenIncidentByG8Request), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__OpenIncidentByG8Request(struct soap *soap, const struct ns4__OpenIncidentByG8Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__OpenIncidentByG8Request);
	if (soap_out_ns4__OpenIncidentByG8Request(soap, tag?tag:"ns4:OpenIncidentByG8Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__OpenIncidentByG8Request * SOAP_FMAC4 soap_get_ns4__OpenIncidentByG8Request(struct soap *soap, struct ns4__OpenIncidentByG8Request *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OpenIncidentByG8Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__OpenIncidentByDCRequest(struct soap *soap, struct ns4__OpenIncidentByDCRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Description);
	soap_default_string(soap, &a->DeviceName);
	soap_default_string(soap, &a->HostService);
	soap_default_string(soap, &a->ISPPath);
	soap_default_string(soap, &a->Location);
	soap_default_string(soap, &a->Status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__OpenIncidentByDCRequest(struct soap *soap, const struct ns4__OpenIncidentByDCRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Description);
	soap_serialize_string(soap, &a->DeviceName);
	soap_serialize_string(soap, &a->HostService);
	soap_serialize_string(soap, &a->ISPPath);
	soap_serialize_string(soap, &a->Location);
	soap_serialize_string(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OpenIncidentByDCRequest(struct soap *soap, const char *tag, int id, const struct ns4__OpenIncidentByDCRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OpenIncidentByDCRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:Description", -1, &a->Description, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DeviceName", -1, &a->DeviceName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:HostService", -1, &a->HostService, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ISPPath", -1, &a->ISPPath, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Location", -1, &a->Location, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__OpenIncidentByDCRequest * SOAP_FMAC4 soap_in_ns4__OpenIncidentByDCRequest(struct soap *soap, const char *tag, struct ns4__OpenIncidentByDCRequest *a, const char *type)
{
	size_t soap_flag_Description = 1;
	size_t soap_flag_DeviceName = 1;
	size_t soap_flag_HostService = 1;
	size_t soap_flag_ISPPath = 1;
	size_t soap_flag_Location = 1;
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__OpenIncidentByDCRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OpenIncidentByDCRequest, sizeof(struct ns4__OpenIncidentByDCRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__OpenIncidentByDCRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Description", &a->Description, "xsd:string"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_DeviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DeviceName", &a->DeviceName, "xsd:string"))
				{	soap_flag_DeviceName--;
					continue;
				}
			if (soap_flag_HostService && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:HostService", &a->HostService, "xsd:string"))
				{	soap_flag_HostService--;
					continue;
				}
			if (soap_flag_ISPPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ISPPath", &a->ISPPath, "xsd:string"))
				{	soap_flag_ISPPath--;
					continue;
				}
			if (soap_flag_Location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Location", &a->Location, "xsd:string"))
				{	soap_flag_Location--;
					continue;
				}
			if (soap_flag_Status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Status", &a->Status, "xsd:string"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__OpenIncidentByDCRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OpenIncidentByDCRequest, 0, sizeof(struct ns4__OpenIncidentByDCRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__OpenIncidentByDCRequest(struct soap *soap, const struct ns4__OpenIncidentByDCRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__OpenIncidentByDCRequest);
	if (soap_out_ns4__OpenIncidentByDCRequest(soap, tag?tag:"ns4:OpenIncidentByDCRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__OpenIncidentByDCRequest * SOAP_FMAC4 soap_get_ns4__OpenIncidentByDCRequest(struct soap *soap, struct ns4__OpenIncidentByDCRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OpenIncidentByDCRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__OpenIncidentByCSRequest(struct soap *soap, struct ns4__OpenIncidentByCSRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Attachment = NULL;
	a->CaseCount = NULL;
	soap_default_string(soap, &a->Description);
	soap_default_string(soap, &a->IncidentCode);
	soap_default_string(soap, &a->Product);
	soap_default_string(soap, &a->Server);
	soap_default_string(soap, &a->Title);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__OpenIncidentByCSRequest(struct soap *soap, const struct ns4__OpenIncidentByCSRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ArrayOfstring(soap, &a->Attachment);
	soap_serialize_PointerTounsignedInt(soap, &a->CaseCount);
	soap_serialize_string(soap, &a->Description);
	soap_serialize_string(soap, &a->IncidentCode);
	soap_serialize_string(soap, &a->Product);
	soap_serialize_string(soap, &a->Server);
	soap_serialize_string(soap, &a->Title);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__OpenIncidentByCSRequest(struct soap *soap, const char *tag, int id, const struct ns4__OpenIncidentByCSRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__OpenIncidentByCSRequest), type))
		return soap->error;
	if (soap_out_PointerTons5__ArrayOfstring(soap, "ns4:Attachment", -1, &a->Attachment, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:CaseCount", -1, &a->CaseCount, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Description", -1, &a->Description, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IncidentCode", -1, &a->IncidentCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Product", -1, &a->Product, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Server", -1, &a->Server, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Title", -1, &a->Title, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__OpenIncidentByCSRequest * SOAP_FMAC4 soap_in_ns4__OpenIncidentByCSRequest(struct soap *soap, const char *tag, struct ns4__OpenIncidentByCSRequest *a, const char *type)
{
	size_t soap_flag_Attachment = 1;
	size_t soap_flag_CaseCount = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_IncidentCode = 1;
	size_t soap_flag_Product = 1;
	size_t soap_flag_Server = 1;
	size_t soap_flag_Title = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__OpenIncidentByCSRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__OpenIncidentByCSRequest, sizeof(struct ns4__OpenIncidentByCSRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__OpenIncidentByCSRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Attachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ArrayOfstring(soap, "ns4:Attachment", &a->Attachment, "ns5:ArrayOfstring"))
				{	soap_flag_Attachment--;
					continue;
				}
			if (soap_flag_CaseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:CaseCount", &a->CaseCount, "xsd:unsignedInt"))
				{	soap_flag_CaseCount--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Description", &a->Description, "xsd:string"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_IncidentCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IncidentCode", &a->IncidentCode, "xsd:string"))
				{	soap_flag_IncidentCode--;
					continue;
				}
			if (soap_flag_Product && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Product", &a->Product, "xsd:string"))
				{	soap_flag_Product--;
					continue;
				}
			if (soap_flag_Server && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Server", &a->Server, "xsd:string"))
				{	soap_flag_Server--;
					continue;
				}
			if (soap_flag_Title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Title", &a->Title, "xsd:string"))
				{	soap_flag_Title--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__OpenIncidentByCSRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__OpenIncidentByCSRequest, 0, sizeof(struct ns4__OpenIncidentByCSRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__OpenIncidentByCSRequest(struct soap *soap, const struct ns4__OpenIncidentByCSRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__OpenIncidentByCSRequest);
	if (soap_out_ns4__OpenIncidentByCSRequest(soap, tag?tag:"ns4:OpenIncidentByCSRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__OpenIncidentByCSRequest * SOAP_FMAC4 soap_get_ns4__OpenIncidentByCSRequest(struct soap *soap, struct ns4__OpenIncidentByCSRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__OpenIncidentByCSRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetHostInfoByIPRequest(struct soap *soap, struct ns4__GetHostInfoByIPRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetHostInfoByIPRequest(struct soap *soap, const struct ns4__GetHostInfoByIPRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ArrayOfstring(soap, &a->IPAddressList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetHostInfoByIPRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetHostInfoByIPRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetHostInfoByIPRequest), type))
		return soap->error;
	if (soap_out_PointerTons5__ArrayOfstring(soap, "ns4:IPAddressList", -1, &a->IPAddressList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetHostInfoByIPRequest * SOAP_FMAC4 soap_in_ns4__GetHostInfoByIPRequest(struct soap *soap, const char *tag, struct ns4__GetHostInfoByIPRequest *a, const char *type)
{
	size_t soap_flag_IPAddressList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetHostInfoByIPRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetHostInfoByIPRequest, sizeof(struct ns4__GetHostInfoByIPRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetHostInfoByIPRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ArrayOfstring(soap, "ns4:IPAddressList", &a->IPAddressList, "ns5:ArrayOfstring"))
				{	soap_flag_IPAddressList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetHostInfoByIPRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetHostInfoByIPRequest, 0, sizeof(struct ns4__GetHostInfoByIPRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetHostInfoByIPRequest(struct soap *soap, const struct ns4__GetHostInfoByIPRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetHostInfoByIPRequest);
	if (soap_out_ns4__GetHostInfoByIPRequest(soap, tag?tag:"ns4:GetHostInfoByIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetHostInfoByIPRequest * SOAP_FMAC4 soap_get_ns4__GetHostInfoByIPRequest(struct soap *soap, struct ns4__GetHostInfoByIPRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetHostInfoByIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetItemValueListRequest(struct soap *soap, struct ns4__GetItemValueListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ItemIDList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetItemValueListRequest(struct soap *soap, const struct ns4__GetItemValueListRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ItemIDList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetItemValueListRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetItemValueListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetItemValueListRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:ItemIDList", -1, &a->ItemIDList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetItemValueListRequest * SOAP_FMAC4 soap_in_ns4__GetItemValueListRequest(struct soap *soap, const char *tag, struct ns4__GetItemValueListRequest *a, const char *type)
{
	size_t soap_flag_ItemIDList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetItemValueListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetItemValueListRequest, sizeof(struct ns4__GetItemValueListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetItemValueListRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemIDList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ItemIDList", &a->ItemIDList, "xsd:string"))
				{	soap_flag_ItemIDList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetItemValueListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetItemValueListRequest, 0, sizeof(struct ns4__GetItemValueListRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetItemValueListRequest(struct soap *soap, const struct ns4__GetItemValueListRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetItemValueListRequest);
	if (soap_out_ns4__GetItemValueListRequest(soap, tag?tag:"ns4:GetItemValueListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetItemValueListRequest * SOAP_FMAC4 soap_get_ns4__GetItemValueListRequest(struct soap *soap, struct ns4__GetItemValueListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetItemValueListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InsertMeasuredDataRequest(struct soap *soap, struct ns4__InsertMeasuredDataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Clock = NULL;
	soap_default_string(soap, &a->Type);
	a->Value = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InsertMeasuredDataRequest(struct soap *soap, const struct ns4__InsertMeasuredDataRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTounsignedInt(soap, &a->Clock);
	soap_serialize_string(soap, &a->Type);
	soap_serialize_PointerTofloat(soap, &a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InsertMeasuredDataRequest(struct soap *soap, const char *tag, int id, const struct ns4__InsertMeasuredDataRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InsertMeasuredDataRequest), type))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:Clock", -1, &a->Clock, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns4:Value", -1, &a->Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InsertMeasuredDataRequest * SOAP_FMAC4 soap_in_ns4__InsertMeasuredDataRequest(struct soap *soap, const char *tag, struct ns4__InsertMeasuredDataRequest *a, const char *type)
{
	size_t soap_flag_Clock = 1;
	size_t soap_flag_Type = 1;
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InsertMeasuredDataRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InsertMeasuredDataRequest, sizeof(struct ns4__InsertMeasuredDataRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InsertMeasuredDataRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Clock && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:Clock", &a->Clock, "xsd:unsignedInt"))
				{	soap_flag_Clock--;
					continue;
				}
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Type", &a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns4:Value", &a->Value, "xsd:float"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InsertMeasuredDataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InsertMeasuredDataRequest, 0, sizeof(struct ns4__InsertMeasuredDataRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InsertMeasuredDataRequest(struct soap *soap, const struct ns4__InsertMeasuredDataRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InsertMeasuredDataRequest);
	if (soap_out_ns4__InsertMeasuredDataRequest(soap, tag?tag:"ns4:InsertMeasuredDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InsertMeasuredDataRequest * SOAP_FMAC4 soap_get_ns4__InsertMeasuredDataRequest(struct soap *soap, struct ns4__InsertMeasuredDataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InsertMeasuredDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__InsertDataServerVMRequest(struct soap *soap, struct ns4__InsertDataServerVMRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->BUCKET);
	soap_default_string(soap, &a->CPU);
	soap_default_string(soap, &a->HDD);
	soap_default_string(soap, &a->IPADDRESS);
	soap_default_string(soap, &a->MACADDRESS);
	soap_default_string(soap, &a->MEMORY);
	soap_default_string(soap, &a->OS);
	soap_default_string(soap, &a->OS_USCORESERVERNAME);
	soap_default_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_default_string(soap, &a->PHYSICAL_USCORESERVER_USCOREIP);
	soap_default_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_default_string(soap, &a->PRODUCT_USCORECODE);
	soap_default_string(soap, &a->PURPOSE_USCOREUSE);
	soap_default_string(soap, &a->SERVER_USCORENAME);
	soap_default_string(soap, &a->STATUS);
	soap_default_string(soap, &a->TECHNICAL_USCOREOWNER);
	soap_default_string(soap, &a->UUID);
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->VLAN);
	soap_default_string(soap, &a->VMW_USCORETOOL);
	soap_default_string(soap, &a->VM_USCORECENTER);
	soap_default_string(soap, &a->VM_USCOREID);
	soap_default_string(soap, &a->VM_USCOREKEY);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__InsertDataServerVMRequest(struct soap *soap, const struct ns4__InsertDataServerVMRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->BUCKET);
	soap_serialize_string(soap, &a->CPU);
	soap_serialize_string(soap, &a->HDD);
	soap_serialize_string(soap, &a->IPADDRESS);
	soap_serialize_string(soap, &a->MACADDRESS);
	soap_serialize_string(soap, &a->MEMORY);
	soap_serialize_string(soap, &a->OS);
	soap_serialize_string(soap, &a->OS_USCORESERVERNAME);
	soap_serialize_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_serialize_string(soap, &a->PHYSICAL_USCORESERVER_USCOREIP);
	soap_serialize_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_serialize_string(soap, &a->PRODUCT_USCORECODE);
	soap_serialize_string(soap, &a->PURPOSE_USCOREUSE);
	soap_serialize_string(soap, &a->SERVER_USCORENAME);
	soap_serialize_string(soap, &a->STATUS);
	soap_serialize_string(soap, &a->TECHNICAL_USCOREOWNER);
	soap_serialize_string(soap, &a->UUID);
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->VLAN);
	soap_serialize_string(soap, &a->VMW_USCORETOOL);
	soap_serialize_string(soap, &a->VM_USCORECENTER);
	soap_serialize_string(soap, &a->VM_USCOREID);
	soap_serialize_string(soap, &a->VM_USCOREKEY);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__InsertDataServerVMRequest(struct soap *soap, const char *tag, int id, const struct ns4__InsertDataServerVMRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__InsertDataServerVMRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:BUCKET", -1, &a->BUCKET, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CPU", -1, &a->CPU, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:HDD", -1, &a->HDD, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPADDRESS", -1, &a->IPADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MACADDRESS", -1, &a->MACADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MEMORY", -1, &a->MEMORY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS", -1, &a->OS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_SERVERNAME", -1, &a->OS_USCORESERVERNAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_CHASSIS_SN", -1, &a->PHYSICAL_USCORECHASSIS_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_SERVER_IP", -1, &a->PHYSICAL_USCORESERVER_USCOREIP, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_SERVER_SN", -1, &a->PHYSICAL_USCORESERVER_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PRODUCT_CODE", -1, &a->PRODUCT_USCORECODE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PURPOSE_USE", -1, &a->PURPOSE_USCOREUSE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SERVER_NAME", -1, &a->SERVER_USCORENAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STATUS", -1, &a->STATUS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TECHNICAL_OWNER", -1, &a->TECHNICAL_USCOREOWNER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:UUID", -1, &a->UUID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VID", -1, &a->VID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VLAN", -1, &a->VLAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMW_TOOL", -1, &a->VMW_USCORETOOL, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_CENTER", -1, &a->VM_USCORECENTER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_ID", -1, &a->VM_USCOREID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_KEY", -1, &a->VM_USCOREKEY, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__InsertDataServerVMRequest * SOAP_FMAC4 soap_in_ns4__InsertDataServerVMRequest(struct soap *soap, const char *tag, struct ns4__InsertDataServerVMRequest *a, const char *type)
{
	size_t soap_flag_BUCKET = 1;
	size_t soap_flag_CPU = 1;
	size_t soap_flag_HDD = 1;
	size_t soap_flag_IPADDRESS = 1;
	size_t soap_flag_MACADDRESS = 1;
	size_t soap_flag_MEMORY = 1;
	size_t soap_flag_OS = 1;
	size_t soap_flag_OS_USCORESERVERNAME = 1;
	size_t soap_flag_PHYSICAL_USCORECHASSIS_USCORESN = 1;
	size_t soap_flag_PHYSICAL_USCORESERVER_USCOREIP = 1;
	size_t soap_flag_PHYSICAL_USCORESERVER_USCORESN = 1;
	size_t soap_flag_PRODUCT_USCORECODE = 1;
	size_t soap_flag_PURPOSE_USCOREUSE = 1;
	size_t soap_flag_SERVER_USCORENAME = 1;
	size_t soap_flag_STATUS = 1;
	size_t soap_flag_TECHNICAL_USCOREOWNER = 1;
	size_t soap_flag_UUID = 1;
	size_t soap_flag_VID = 1;
	size_t soap_flag_VLAN = 1;
	size_t soap_flag_VMW_USCORETOOL = 1;
	size_t soap_flag_VM_USCORECENTER = 1;
	size_t soap_flag_VM_USCOREID = 1;
	size_t soap_flag_VM_USCOREKEY = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__InsertDataServerVMRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__InsertDataServerVMRequest, sizeof(struct ns4__InsertDataServerVMRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__InsertDataServerVMRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BUCKET && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BUCKET", &a->BUCKET, "xsd:string"))
				{	soap_flag_BUCKET--;
					continue;
				}
			if (soap_flag_CPU && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CPU", &a->CPU, "xsd:string"))
				{	soap_flag_CPU--;
					continue;
				}
			if (soap_flag_HDD && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:HDD", &a->HDD, "xsd:string"))
				{	soap_flag_HDD--;
					continue;
				}
			if (soap_flag_IPADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPADDRESS", &a->IPADDRESS, "xsd:string"))
				{	soap_flag_IPADDRESS--;
					continue;
				}
			if (soap_flag_MACADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MACADDRESS", &a->MACADDRESS, "xsd:string"))
				{	soap_flag_MACADDRESS--;
					continue;
				}
			if (soap_flag_MEMORY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MEMORY", &a->MEMORY, "xsd:string"))
				{	soap_flag_MEMORY--;
					continue;
				}
			if (soap_flag_OS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS", &a->OS, "xsd:string"))
				{	soap_flag_OS--;
					continue;
				}
			if (soap_flag_OS_USCORESERVERNAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_SERVERNAME", &a->OS_USCORESERVERNAME, "xsd:string"))
				{	soap_flag_OS_USCORESERVERNAME--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORECHASSIS_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_CHASSIS_SN", &a->PHYSICAL_USCORECHASSIS_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORECHASSIS_USCORESN--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORESERVER_USCOREIP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_SERVER_IP", &a->PHYSICAL_USCORESERVER_USCOREIP, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORESERVER_USCOREIP--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORESERVER_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_SERVER_SN", &a->PHYSICAL_USCORESERVER_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORESERVER_USCORESN--;
					continue;
				}
			if (soap_flag_PRODUCT_USCORECODE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PRODUCT_CODE", &a->PRODUCT_USCORECODE, "xsd:string"))
				{	soap_flag_PRODUCT_USCORECODE--;
					continue;
				}
			if (soap_flag_PURPOSE_USCOREUSE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PURPOSE_USE", &a->PURPOSE_USCOREUSE, "xsd:string"))
				{	soap_flag_PURPOSE_USCOREUSE--;
					continue;
				}
			if (soap_flag_SERVER_USCORENAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SERVER_NAME", &a->SERVER_USCORENAME, "xsd:string"))
				{	soap_flag_SERVER_USCORENAME--;
					continue;
				}
			if (soap_flag_STATUS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STATUS", &a->STATUS, "xsd:string"))
				{	soap_flag_STATUS--;
					continue;
				}
			if (soap_flag_TECHNICAL_USCOREOWNER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TECHNICAL_OWNER", &a->TECHNICAL_USCOREOWNER, "xsd:string"))
				{	soap_flag_TECHNICAL_USCOREOWNER--;
					continue;
				}
			if (soap_flag_UUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UUID", &a->UUID, "xsd:string"))
				{	soap_flag_UUID--;
					continue;
				}
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_VLAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VLAN", &a->VLAN, "xsd:string"))
				{	soap_flag_VLAN--;
					continue;
				}
			if (soap_flag_VMW_USCORETOOL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMW_TOOL", &a->VMW_USCORETOOL, "xsd:string"))
				{	soap_flag_VMW_USCORETOOL--;
					continue;
				}
			if (soap_flag_VM_USCORECENTER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_CENTER", &a->VM_USCORECENTER, "xsd:string"))
				{	soap_flag_VM_USCORECENTER--;
					continue;
				}
			if (soap_flag_VM_USCOREID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_ID", &a->VM_USCOREID, "xsd:string"))
				{	soap_flag_VM_USCOREID--;
					continue;
				}
			if (soap_flag_VM_USCOREKEY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_KEY", &a->VM_USCOREKEY, "xsd:string"))
				{	soap_flag_VM_USCOREKEY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__InsertDataServerVMRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__InsertDataServerVMRequest, 0, sizeof(struct ns4__InsertDataServerVMRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__InsertDataServerVMRequest(struct soap *soap, const struct ns4__InsertDataServerVMRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__InsertDataServerVMRequest);
	if (soap_out_ns4__InsertDataServerVMRequest(soap, tag?tag:"ns4:InsertDataServerVMRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InsertDataServerVMRequest * SOAP_FMAC4 soap_get_ns4__InsertDataServerVMRequest(struct soap *soap, struct ns4__InsertDataServerVMRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__InsertDataServerVMRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetHostsInfoRequest(struct soap *soap, struct ns4__GetHostsInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ServerInfoList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetHostsInfoRequest(struct soap *soap, const struct ns4__GetHostsInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfServerInfo(soap, &a->ServerInfoList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetHostsInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetHostsInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetHostsInfoRequest), type))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfServerInfo(soap, "ns4:ServerInfoList", -1, &a->ServerInfoList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetHostsInfoRequest * SOAP_FMAC4 soap_in_ns4__GetHostsInfoRequest(struct soap *soap, const char *tag, struct ns4__GetHostsInfoRequest *a, const char *type)
{
	size_t soap_flag_ServerInfoList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetHostsInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetHostsInfoRequest, sizeof(struct ns4__GetHostsInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetHostsInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ServerInfoList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfServerInfo(soap, "ns4:ServerInfoList", &a->ServerInfoList, "ns4:ArrayOfServerInfo"))
				{	soap_flag_ServerInfoList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetHostsInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetHostsInfoRequest, 0, sizeof(struct ns4__GetHostsInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetHostsInfoRequest(struct soap *soap, const struct ns4__GetHostsInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetHostsInfoRequest);
	if (soap_out_ns4__GetHostsInfoRequest(soap, tag?tag:"ns4:GetHostsInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetHostsInfoRequest * SOAP_FMAC4 soap_get_ns4__GetHostsInfoRequest(struct soap *soap, struct ns4__GetHostsInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetHostsInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HandleServerVMInfoRequest(struct soap *soap, struct ns4__HandleServerVMInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->BUCKET);
	soap_default_string(soap, &a->CPU);
	soap_default_string(soap, &a->DELETE);
	soap_default_string(soap, &a->DEPARTMENT);
	soap_default_string(soap, &a->DIVISION);
	soap_default_string(soap, &a->HDD);
	soap_default_string(soap, &a->IPADDRESS);
	soap_default_string(soap, &a->MACADDRESS);
	soap_default_string(soap, &a->MEMORY);
	soap_default_string(soap, &a->NEW_USCOREDEPARTMENT);
	soap_default_string(soap, &a->OS);
	soap_default_string(soap, &a->OS_USCORESERVERNAME);
	soap_default_string(soap, &a->PHYSICALSERVERIP);
	soap_default_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_default_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_default_string(soap, &a->PRODUCT);
	soap_default_string(soap, &a->PURPOSE_USCOREUSE);
	soap_default_string(soap, &a->SERVERNAME);
	soap_default_string(soap, &a->STATUS);
	soap_default_string(soap, &a->TECHNICALOWNER);
	soap_default_string(soap, &a->UUID);
	soap_default_string(soap, &a->VLAN);
	soap_default_string(soap, &a->VMCENTER);
	soap_default_string(soap, &a->VMKEY);
	soap_default_string(soap, &a->VMWTOOL);
	soap_default_string(soap, &a->VM_USCOREID);
	soap_default_string(soap, &a->V_USCOREID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HandleServerVMInfoRequest(struct soap *soap, const struct ns4__HandleServerVMInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->BUCKET);
	soap_serialize_string(soap, &a->CPU);
	soap_serialize_string(soap, &a->DELETE);
	soap_serialize_string(soap, &a->DEPARTMENT);
	soap_serialize_string(soap, &a->DIVISION);
	soap_serialize_string(soap, &a->HDD);
	soap_serialize_string(soap, &a->IPADDRESS);
	soap_serialize_string(soap, &a->MACADDRESS);
	soap_serialize_string(soap, &a->MEMORY);
	soap_serialize_string(soap, &a->NEW_USCOREDEPARTMENT);
	soap_serialize_string(soap, &a->OS);
	soap_serialize_string(soap, &a->OS_USCORESERVERNAME);
	soap_serialize_string(soap, &a->PHYSICALSERVERIP);
	soap_serialize_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_serialize_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_serialize_string(soap, &a->PRODUCT);
	soap_serialize_string(soap, &a->PURPOSE_USCOREUSE);
	soap_serialize_string(soap, &a->SERVERNAME);
	soap_serialize_string(soap, &a->STATUS);
	soap_serialize_string(soap, &a->TECHNICALOWNER);
	soap_serialize_string(soap, &a->UUID);
	soap_serialize_string(soap, &a->VLAN);
	soap_serialize_string(soap, &a->VMCENTER);
	soap_serialize_string(soap, &a->VMKEY);
	soap_serialize_string(soap, &a->VMWTOOL);
	soap_serialize_string(soap, &a->VM_USCOREID);
	soap_serialize_string(soap, &a->V_USCOREID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HandleServerVMInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__HandleServerVMInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HandleServerVMInfoRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:BUCKET", -1, &a->BUCKET, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CPU", -1, &a->CPU, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DELETE", -1, &a->DELETE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DEPARTMENT", -1, &a->DEPARTMENT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DIVISION", -1, &a->DIVISION, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:HDD", -1, &a->HDD, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPADDRESS", -1, &a->IPADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MACADDRESS", -1, &a->MACADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MEMORY", -1, &a->MEMORY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:NEW_DEPARTMENT", -1, &a->NEW_USCOREDEPARTMENT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS", -1, &a->OS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_SERVERNAME", -1, &a->OS_USCORESERVERNAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICALSERVERIP", -1, &a->PHYSICALSERVERIP, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_CHASSIS_SN", -1, &a->PHYSICAL_USCORECHASSIS_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_SERVER_SN", -1, &a->PHYSICAL_USCORESERVER_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PRODUCT", -1, &a->PRODUCT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PURPOSE_USE", -1, &a->PURPOSE_USCOREUSE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SERVERNAME", -1, &a->SERVERNAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STATUS", -1, &a->STATUS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TECHNICALOWNER", -1, &a->TECHNICALOWNER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:UUID", -1, &a->UUID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VLAN", -1, &a->VLAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMCENTER", -1, &a->VMCENTER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMKEY", -1, &a->VMKEY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMWTOOL", -1, &a->VMWTOOL, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_ID", -1, &a->VM_USCOREID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:V_ID", -1, &a->V_USCOREID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HandleServerVMInfoRequest * SOAP_FMAC4 soap_in_ns4__HandleServerVMInfoRequest(struct soap *soap, const char *tag, struct ns4__HandleServerVMInfoRequest *a, const char *type)
{
	size_t soap_flag_BUCKET = 1;
	size_t soap_flag_CPU = 1;
	size_t soap_flag_DELETE = 1;
	size_t soap_flag_DEPARTMENT = 1;
	size_t soap_flag_DIVISION = 1;
	size_t soap_flag_HDD = 1;
	size_t soap_flag_IPADDRESS = 1;
	size_t soap_flag_MACADDRESS = 1;
	size_t soap_flag_MEMORY = 1;
	size_t soap_flag_NEW_USCOREDEPARTMENT = 1;
	size_t soap_flag_OS = 1;
	size_t soap_flag_OS_USCORESERVERNAME = 1;
	size_t soap_flag_PHYSICALSERVERIP = 1;
	size_t soap_flag_PHYSICAL_USCORECHASSIS_USCORESN = 1;
	size_t soap_flag_PHYSICAL_USCORESERVER_USCORESN = 1;
	size_t soap_flag_PRODUCT = 1;
	size_t soap_flag_PURPOSE_USCOREUSE = 1;
	size_t soap_flag_SERVERNAME = 1;
	size_t soap_flag_STATUS = 1;
	size_t soap_flag_TECHNICALOWNER = 1;
	size_t soap_flag_UUID = 1;
	size_t soap_flag_VLAN = 1;
	size_t soap_flag_VMCENTER = 1;
	size_t soap_flag_VMKEY = 1;
	size_t soap_flag_VMWTOOL = 1;
	size_t soap_flag_VM_USCOREID = 1;
	size_t soap_flag_V_USCOREID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HandleServerVMInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HandleServerVMInfoRequest, sizeof(struct ns4__HandleServerVMInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HandleServerVMInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BUCKET && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BUCKET", &a->BUCKET, "xsd:string"))
				{	soap_flag_BUCKET--;
					continue;
				}
			if (soap_flag_CPU && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CPU", &a->CPU, "xsd:string"))
				{	soap_flag_CPU--;
					continue;
				}
			if (soap_flag_DELETE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DELETE", &a->DELETE, "xsd:string"))
				{	soap_flag_DELETE--;
					continue;
				}
			if (soap_flag_DEPARTMENT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DEPARTMENT", &a->DEPARTMENT, "xsd:string"))
				{	soap_flag_DEPARTMENT--;
					continue;
				}
			if (soap_flag_DIVISION && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DIVISION", &a->DIVISION, "xsd:string"))
				{	soap_flag_DIVISION--;
					continue;
				}
			if (soap_flag_HDD && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:HDD", &a->HDD, "xsd:string"))
				{	soap_flag_HDD--;
					continue;
				}
			if (soap_flag_IPADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPADDRESS", &a->IPADDRESS, "xsd:string"))
				{	soap_flag_IPADDRESS--;
					continue;
				}
			if (soap_flag_MACADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MACADDRESS", &a->MACADDRESS, "xsd:string"))
				{	soap_flag_MACADDRESS--;
					continue;
				}
			if (soap_flag_MEMORY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MEMORY", &a->MEMORY, "xsd:string"))
				{	soap_flag_MEMORY--;
					continue;
				}
			if (soap_flag_NEW_USCOREDEPARTMENT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NEW_DEPARTMENT", &a->NEW_USCOREDEPARTMENT, "xsd:string"))
				{	soap_flag_NEW_USCOREDEPARTMENT--;
					continue;
				}
			if (soap_flag_OS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS", &a->OS, "xsd:string"))
				{	soap_flag_OS--;
					continue;
				}
			if (soap_flag_OS_USCORESERVERNAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_SERVERNAME", &a->OS_USCORESERVERNAME, "xsd:string"))
				{	soap_flag_OS_USCORESERVERNAME--;
					continue;
				}
			if (soap_flag_PHYSICALSERVERIP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICALSERVERIP", &a->PHYSICALSERVERIP, "xsd:string"))
				{	soap_flag_PHYSICALSERVERIP--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORECHASSIS_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_CHASSIS_SN", &a->PHYSICAL_USCORECHASSIS_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORECHASSIS_USCORESN--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORESERVER_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_SERVER_SN", &a->PHYSICAL_USCORESERVER_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORESERVER_USCORESN--;
					continue;
				}
			if (soap_flag_PRODUCT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PRODUCT", &a->PRODUCT, "xsd:string"))
				{	soap_flag_PRODUCT--;
					continue;
				}
			if (soap_flag_PURPOSE_USCOREUSE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PURPOSE_USE", &a->PURPOSE_USCOREUSE, "xsd:string"))
				{	soap_flag_PURPOSE_USCOREUSE--;
					continue;
				}
			if (soap_flag_SERVERNAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SERVERNAME", &a->SERVERNAME, "xsd:string"))
				{	soap_flag_SERVERNAME--;
					continue;
				}
			if (soap_flag_STATUS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STATUS", &a->STATUS, "xsd:string"))
				{	soap_flag_STATUS--;
					continue;
				}
			if (soap_flag_TECHNICALOWNER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TECHNICALOWNER", &a->TECHNICALOWNER, "xsd:string"))
				{	soap_flag_TECHNICALOWNER--;
					continue;
				}
			if (soap_flag_UUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UUID", &a->UUID, "xsd:string"))
				{	soap_flag_UUID--;
					continue;
				}
			if (soap_flag_VLAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VLAN", &a->VLAN, "xsd:string"))
				{	soap_flag_VLAN--;
					continue;
				}
			if (soap_flag_VMCENTER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMCENTER", &a->VMCENTER, "xsd:string"))
				{	soap_flag_VMCENTER--;
					continue;
				}
			if (soap_flag_VMKEY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMKEY", &a->VMKEY, "xsd:string"))
				{	soap_flag_VMKEY--;
					continue;
				}
			if (soap_flag_VMWTOOL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMWTOOL", &a->VMWTOOL, "xsd:string"))
				{	soap_flag_VMWTOOL--;
					continue;
				}
			if (soap_flag_VM_USCOREID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_ID", &a->VM_USCOREID, "xsd:string"))
				{	soap_flag_VM_USCOREID--;
					continue;
				}
			if (soap_flag_V_USCOREID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:V_ID", &a->V_USCOREID, "xsd:string"))
				{	soap_flag_V_USCOREID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__HandleServerVMInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HandleServerVMInfoRequest, 0, sizeof(struct ns4__HandleServerVMInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HandleServerVMInfoRequest(struct soap *soap, const struct ns4__HandleServerVMInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__HandleServerVMInfoRequest);
	if (soap_out_ns4__HandleServerVMInfoRequest(soap, tag?tag:"ns4:HandleServerVMInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HandleServerVMInfoRequest * SOAP_FMAC4 soap_get_ns4__HandleServerVMInfoRequest(struct soap *soap, struct ns4__HandleServerVMInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HandleServerVMInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, struct ns4__GetSnSInfoTechnicalOwnerRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Department);
	soap_default_string(soap, &a->NameTechnicalOwner);
	soap_default_string(soap, &a->Product);
	soap_default_string(soap, &a->UserOwner);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, const struct ns4__GetSnSInfoTechnicalOwnerRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Department);
	soap_serialize_string(soap, &a->NameTechnicalOwner);
	soap_serialize_string(soap, &a->Product);
	soap_serialize_string(soap, &a->UserOwner);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetSnSInfoTechnicalOwnerRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:Department", -1, &a->Department, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:NameTechnicalOwner", -1, &a->NameTechnicalOwner, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Product", -1, &a->Product, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:UserOwner", -1, &a->UserOwner, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetSnSInfoTechnicalOwnerRequest * SOAP_FMAC4 soap_in_ns4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, const char *tag, struct ns4__GetSnSInfoTechnicalOwnerRequest *a, const char *type)
{
	size_t soap_flag_Department = 1;
	size_t soap_flag_NameTechnicalOwner = 1;
	size_t soap_flag_Product = 1;
	size_t soap_flag_UserOwner = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetSnSInfoTechnicalOwnerRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest, sizeof(struct ns4__GetSnSInfoTechnicalOwnerRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetSnSInfoTechnicalOwnerRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Department && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Department", &a->Department, "xsd:string"))
				{	soap_flag_Department--;
					continue;
				}
			if (soap_flag_NameTechnicalOwner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NameTechnicalOwner", &a->NameTechnicalOwner, "xsd:string"))
				{	soap_flag_NameTechnicalOwner--;
					continue;
				}
			if (soap_flag_Product && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Product", &a->Product, "xsd:string"))
				{	soap_flag_Product--;
					continue;
				}
			if (soap_flag_UserOwner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UserOwner", &a->UserOwner, "xsd:string"))
				{	soap_flag_UserOwner--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetSnSInfoTechnicalOwnerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest, 0, sizeof(struct ns4__GetSnSInfoTechnicalOwnerRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, const struct ns4__GetSnSInfoTechnicalOwnerRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest);
	if (soap_out_ns4__GetSnSInfoTechnicalOwnerRequest(soap, tag?tag:"ns4:GetSnSInfoTechnicalOwnerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetSnSInfoTechnicalOwnerRequest * SOAP_FMAC4 soap_get_ns4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, struct ns4__GetSnSInfoTechnicalOwnerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetSnSInfoTechnicalOwnerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetServerNameBySerialNumberRequest(struct soap *soap, struct ns4__GetServerNameBySerialNumberRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ServerKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetServerNameBySerialNumberRequest(struct soap *soap, const struct ns4__GetServerNameBySerialNumberRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ServerKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetServerNameBySerialNumberRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetServerNameBySerialNumberRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:ServerKey", -1, &a->ServerKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetServerNameBySerialNumberRequest * SOAP_FMAC4 soap_in_ns4__GetServerNameBySerialNumberRequest(struct soap *soap, const char *tag, struct ns4__GetServerNameBySerialNumberRequest *a, const char *type)
{
	size_t soap_flag_ServerKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetServerNameBySerialNumberRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest, sizeof(struct ns4__GetServerNameBySerialNumberRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetServerNameBySerialNumberRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ServerKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ServerKey", &a->ServerKey, "xsd:string"))
				{	soap_flag_ServerKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetServerNameBySerialNumberRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest, 0, sizeof(struct ns4__GetServerNameBySerialNumberRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetServerNameBySerialNumberRequest(struct soap *soap, const struct ns4__GetServerNameBySerialNumberRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest);
	if (soap_out_ns4__GetServerNameBySerialNumberRequest(soap, tag?tag:"ns4:GetServerNameBySerialNumberRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetServerNameBySerialNumberRequest * SOAP_FMAC4 soap_get_ns4__GetServerNameBySerialNumberRequest(struct soap *soap, struct ns4__GetServerNameBySerialNumberRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetServerNameBySerialNumberRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetSO6InfoServerRequest(struct soap *soap, struct ns4__GetSO6InfoServerRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->TYPE_USCORESERVER);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetSO6InfoServerRequest(struct soap *soap, const struct ns4__GetSO6InfoServerRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->TYPE_USCORESERVER);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetSO6InfoServerRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetSO6InfoServerRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetSO6InfoServerRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:TYPE_SERVER", -1, &a->TYPE_USCORESERVER, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetSO6InfoServerRequest * SOAP_FMAC4 soap_in_ns4__GetSO6InfoServerRequest(struct soap *soap, const char *tag, struct ns4__GetSO6InfoServerRequest *a, const char *type)
{
	size_t soap_flag_TYPE_USCORESERVER = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetSO6InfoServerRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetSO6InfoServerRequest, sizeof(struct ns4__GetSO6InfoServerRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetSO6InfoServerRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TYPE_USCORESERVER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TYPE_SERVER", &a->TYPE_USCORESERVER, "xsd:string"))
				{	soap_flag_TYPE_USCORESERVER--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetSO6InfoServerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetSO6InfoServerRequest, 0, sizeof(struct ns4__GetSO6InfoServerRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetSO6InfoServerRequest(struct soap *soap, const struct ns4__GetSO6InfoServerRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetSO6InfoServerRequest);
	if (soap_out_ns4__GetSO6InfoServerRequest(soap, tag?tag:"ns4:GetSO6InfoServerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetSO6InfoServerRequest * SOAP_FMAC4 soap_get_ns4__GetSO6InfoServerRequest(struct soap *soap, struct ns4__GetSO6InfoServerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetSO6InfoServerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetSDKServerInfoListRequest(struct soap *soap, struct ns4__GetSDKServerInfoListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NAME);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetSDKServerInfoListRequest(struct soap *soap, const struct ns4__GetSDKServerInfoListRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->NAME);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetSDKServerInfoListRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetSDKServerInfoListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetSDKServerInfoListRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:NAME", -1, &a->NAME, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetSDKServerInfoListRequest * SOAP_FMAC4 soap_in_ns4__GetSDKServerInfoListRequest(struct soap *soap, const char *tag, struct ns4__GetSDKServerInfoListRequest *a, const char *type)
{
	size_t soap_flag_NAME = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetSDKServerInfoListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetSDKServerInfoListRequest, sizeof(struct ns4__GetSDKServerInfoListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetSDKServerInfoListRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NAME", &a->NAME, "xsd:string"))
				{	soap_flag_NAME--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetSDKServerInfoListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetSDKServerInfoListRequest, 0, sizeof(struct ns4__GetSDKServerInfoListRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetSDKServerInfoListRequest(struct soap *soap, const struct ns4__GetSDKServerInfoListRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetSDKServerInfoListRequest);
	if (soap_out_ns4__GetSDKServerInfoListRequest(soap, tag?tag:"ns4:GetSDKServerInfoListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetSDKServerInfoListRequest * SOAP_FMAC4 soap_get_ns4__GetSDKServerInfoListRequest(struct soap *soap, struct ns4__GetSDKServerInfoListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetSDKServerInfoListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetProductInfoByIPRequest(struct soap *soap, struct ns4__GetProductInfoByIPRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetProductInfoByIPRequest(struct soap *soap, const struct ns4__GetProductInfoByIPRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->IPList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetProductInfoByIPRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetProductInfoByIPRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetProductInfoByIPRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPList", -1, &a->IPList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetProductInfoByIPRequest * SOAP_FMAC4 soap_in_ns4__GetProductInfoByIPRequest(struct soap *soap, const char *tag, struct ns4__GetProductInfoByIPRequest *a, const char *type)
{
	size_t soap_flag_IPList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetProductInfoByIPRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetProductInfoByIPRequest, sizeof(struct ns4__GetProductInfoByIPRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetProductInfoByIPRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPList && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPList", &a->IPList, "xsd:string"))
				{	soap_flag_IPList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetProductInfoByIPRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetProductInfoByIPRequest, 0, sizeof(struct ns4__GetProductInfoByIPRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetProductInfoByIPRequest(struct soap *soap, const struct ns4__GetProductInfoByIPRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetProductInfoByIPRequest);
	if (soap_out_ns4__GetProductInfoByIPRequest(soap, tag?tag:"ns4:GetProductInfoByIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetProductInfoByIPRequest * SOAP_FMAC4 soap_get_ns4__GetProductInfoByIPRequest(struct soap *soap, struct ns4__GetProductInfoByIPRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetProductInfoByIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetODAServerInfoListRequest(struct soap *soap, struct ns4__GetODAServerInfoListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ServerType = NULL;
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetODAServerInfoListRequest(struct soap *soap, const struct ns4__GetODAServerInfoListRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->ServerType);
	soap_serialize_PointerToint(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetODAServerInfoListRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetODAServerInfoListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetODAServerInfoListRequest), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:ServerType", -1, &a->ServerType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns4:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetODAServerInfoListRequest * SOAP_FMAC4 soap_in_ns4__GetODAServerInfoListRequest(struct soap *soap, const char *tag, struct ns4__GetODAServerInfoListRequest *a, const char *type)
{
	size_t soap_flag_ServerType = 1;
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetODAServerInfoListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetODAServerInfoListRequest, sizeof(struct ns4__GetODAServerInfoListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetODAServerInfoListRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ServerType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:ServerType", &a->ServerType, "xsd:int"))
				{	soap_flag_ServerType--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns4:Status", &a->Status, "xsd:int"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetODAServerInfoListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetODAServerInfoListRequest, 0, sizeof(struct ns4__GetODAServerInfoListRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetODAServerInfoListRequest(struct soap *soap, const struct ns4__GetODAServerInfoListRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetODAServerInfoListRequest);
	if (soap_out_ns4__GetODAServerInfoListRequest(soap, tag?tag:"ns4:GetODAServerInfoListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetODAServerInfoListRequest * SOAP_FMAC4 soap_get_ns4__GetODAServerInfoListRequest(struct soap *soap, struct ns4__GetODAServerInfoListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetODAServerInfoListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetODAHostInfoListRequest(struct soap *soap, struct ns4__GetODAHostInfoListRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetODAHostInfoListRequest(struct soap *soap, const struct ns4__GetODAHostInfoListRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetODAHostInfoListRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetODAHostInfoListRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetODAHostInfoListRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetODAHostInfoListRequest * SOAP_FMAC4 soap_in_ns4__GetODAHostInfoListRequest(struct soap *soap, const char *tag, struct ns4__GetODAHostInfoListRequest *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetODAHostInfoListRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetODAHostInfoListRequest, sizeof(struct ns4__GetODAHostInfoListRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetODAHostInfoListRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetODAHostInfoListRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetODAHostInfoListRequest, 0, sizeof(struct ns4__GetODAHostInfoListRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetODAHostInfoListRequest(struct soap *soap, const struct ns4__GetODAHostInfoListRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetODAHostInfoListRequest);
	if (soap_out_ns4__GetODAHostInfoListRequest(soap, tag?tag:"ns4:GetODAHostInfoListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetODAHostInfoListRequest * SOAP_FMAC4 soap_get_ns4__GetODAHostInfoListRequest(struct soap *soap, struct ns4__GetODAHostInfoListRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetODAHostInfoListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetListAllServerRequest(struct soap *soap, struct ns4__GetListAllServerRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Department);
	soap_default_string(soap, &a->Key);
	a->PageNumber = NULL;
	soap_default_string(soap, &a->Product);
	soap_default_string(soap, &a->UserOwner);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetListAllServerRequest(struct soap *soap, const struct ns4__GetListAllServerRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Department);
	soap_serialize_string(soap, &a->Key);
	soap_serialize_PointerTounsignedShort(soap, &a->PageNumber);
	soap_serialize_string(soap, &a->Product);
	soap_serialize_string(soap, &a->UserOwner);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetListAllServerRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetListAllServerRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetListAllServerRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:Department", -1, &a->Department, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTounsignedShort(soap, "ns4:PageNumber", -1, &a->PageNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Product", -1, &a->Product, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:UserOwner", -1, &a->UserOwner, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetListAllServerRequest * SOAP_FMAC4 soap_in_ns4__GetListAllServerRequest(struct soap *soap, const char *tag, struct ns4__GetListAllServerRequest *a, const char *type)
{
	size_t soap_flag_Department = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_PageNumber = 1;
	size_t soap_flag_Product = 1;
	size_t soap_flag_UserOwner = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetListAllServerRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetListAllServerRequest, sizeof(struct ns4__GetListAllServerRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetListAllServerRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Department && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Department", &a->Department, "xsd:string"))
				{	soap_flag_Department--;
					continue;
				}
			if (soap_flag_Key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Key", &a->Key, "xsd:string"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_PageNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedShort(soap, "ns4:PageNumber", &a->PageNumber, "xsd:unsignedShort"))
				{	soap_flag_PageNumber--;
					continue;
				}
			if (soap_flag_Product && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Product", &a->Product, "xsd:string"))
				{	soap_flag_Product--;
					continue;
				}
			if (soap_flag_UserOwner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UserOwner", &a->UserOwner, "xsd:string"))
				{	soap_flag_UserOwner--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetListAllServerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetListAllServerRequest, 0, sizeof(struct ns4__GetListAllServerRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetListAllServerRequest(struct soap *soap, const struct ns4__GetListAllServerRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetListAllServerRequest);
	if (soap_out_ns4__GetListAllServerRequest(soap, tag?tag:"ns4:GetListAllServerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetListAllServerRequest * SOAP_FMAC4 soap_get_ns4__GetListAllServerRequest(struct soap *soap, struct ns4__GetListAllServerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetListAllServerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, struct ns4__GetIRDTechnicalOwnerInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PRODUCT_USCORECODE);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, const struct ns4__GetIRDTechnicalOwnerInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->PRODUCT_USCORECODE);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetIRDTechnicalOwnerInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:PRODUCT_CODE", -1, &a->PRODUCT_USCORECODE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetIRDTechnicalOwnerInfoRequest * SOAP_FMAC4 soap_in_ns4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, const char *tag, struct ns4__GetIRDTechnicalOwnerInfoRequest *a, const char *type)
{
	size_t soap_flag_PRODUCT_USCORECODE = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetIRDTechnicalOwnerInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest, sizeof(struct ns4__GetIRDTechnicalOwnerInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetIRDTechnicalOwnerInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PRODUCT_USCORECODE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PRODUCT_CODE", &a->PRODUCT_USCORECODE, "xsd:string"))
				{	soap_flag_PRODUCT_USCORECODE--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetIRDTechnicalOwnerInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest, 0, sizeof(struct ns4__GetIRDTechnicalOwnerInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, const struct ns4__GetIRDTechnicalOwnerInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest);
	if (soap_out_ns4__GetIRDTechnicalOwnerInfoRequest(soap, tag?tag:"ns4:GetIRDTechnicalOwnerInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetIRDTechnicalOwnerInfoRequest * SOAP_FMAC4 soap_get_ns4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, struct ns4__GetIRDTechnicalOwnerInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetIRDTechnicalOwnerInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetIRDServerVMInfoRequest(struct soap *soap, struct ns4__GetIRDServerVMInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetIRDServerVMInfoRequest(struct soap *soap, const struct ns4__GetIRDServerVMInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetIRDServerVMInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetIRDServerVMInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:VID", -1, &a->VID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetIRDServerVMInfoRequest * SOAP_FMAC4 soap_in_ns4__GetIRDServerVMInfoRequest(struct soap *soap, const char *tag, struct ns4__GetIRDServerVMInfoRequest *a, const char *type)
{
	size_t soap_flag_VID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetIRDServerVMInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest, sizeof(struct ns4__GetIRDServerVMInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetIRDServerVMInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetIRDServerVMInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest, 0, sizeof(struct ns4__GetIRDServerVMInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetIRDServerVMInfoRequest(struct soap *soap, const struct ns4__GetIRDServerVMInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest);
	if (soap_out_ns4__GetIRDServerVMInfoRequest(soap, tag?tag:"ns4:GetIRDServerVMInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetIRDServerVMInfoRequest * SOAP_FMAC4 soap_get_ns4__GetIRDServerVMInfoRequest(struct soap *soap, struct ns4__GetIRDServerVMInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetIRDServerVMInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetCCUByProductCodeRequest(struct soap *soap, struct ns4__GetCCUByProductCodeRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EndTime = NULL;
	soap_default_string(soap, &a->ProductCode);
	a->StartTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetCCUByProductCodeRequest(struct soap *soap, const struct ns4__GetCCUByProductCodeRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTounsignedInt(soap, &a->EndTime);
	soap_serialize_string(soap, &a->ProductCode);
	soap_serialize_PointerTounsignedInt(soap, &a->StartTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetCCUByProductCodeRequest(struct soap *soap, const char *tag, int id, const struct ns4__GetCCUByProductCodeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetCCUByProductCodeRequest), type))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ProductCode", -1, &a->ProductCode, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetCCUByProductCodeRequest * SOAP_FMAC4 soap_in_ns4__GetCCUByProductCodeRequest(struct soap *soap, const char *tag, struct ns4__GetCCUByProductCodeRequest *a, const char *type)
{
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_ProductCode = 1;
	size_t soap_flag_StartTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetCCUByProductCodeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetCCUByProductCodeRequest, sizeof(struct ns4__GetCCUByProductCodeRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetCCUByProductCodeRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:EndTime", &a->EndTime, "xsd:unsignedInt"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_ProductCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ProductCode", &a->ProductCode, "xsd:string"))
				{	soap_flag_ProductCode--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:StartTime", &a->StartTime, "xsd:unsignedInt"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetCCUByProductCodeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetCCUByProductCodeRequest, 0, sizeof(struct ns4__GetCCUByProductCodeRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetCCUByProductCodeRequest(struct soap *soap, const struct ns4__GetCCUByProductCodeRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetCCUByProductCodeRequest);
	if (soap_out_ns4__GetCCUByProductCodeRequest(soap, tag?tag:"ns4:GetCCUByProductCodeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetCCUByProductCodeRequest * SOAP_FMAC4 soap_get_ns4__GetCCUByProductCodeRequest(struct soap *soap, struct ns4__GetCCUByProductCodeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetCCUByProductCodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IP_USCOREPrivate = NULL;
	a->IP_USCOREPublic = NULL;
	soap_default_string(soap, &a->OS_USCOREVersion);
	soap_default_string(soap, &a->Serial_USCORENumber);
	soap_default_string(soap, &a->Server_USCOREName);
	soap_default_string(soap, &a->Zbx_USCORELast_USCOREClock);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, const struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfInterfaceAddress(soap, &a->IP_USCOREPrivate);
	soap_serialize_PointerTons4__ArrayOfInterfaceAddress(soap, &a->IP_USCOREPublic);
	soap_serialize_string(soap, &a->OS_USCOREVersion);
	soap_serialize_string(soap, &a->Serial_USCORENumber);
	soap_serialize_string(soap, &a->Server_USCOREName);
	soap_serialize_string(soap, &a->Zbx_USCORELast_USCOREClock);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, const char *tag, int id, const struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest), type))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Private", -1, &a->IP_USCOREPrivate, ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Public", -1, &a->IP_USCOREPublic, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_Version", -1, &a->OS_USCOREVersion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Serial_Number", -1, &a->Serial_USCORENumber, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Server_Name", -1, &a->Server_USCOREName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Zbx_Last_Clock", -1, &a->Zbx_USCORELast_USCOREClock, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest * SOAP_FMAC4 soap_in_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, const char *tag, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *a, const char *type)
{
	size_t soap_flag_IP_USCOREPrivate = 1;
	size_t soap_flag_IP_USCOREPublic = 1;
	size_t soap_flag_OS_USCOREVersion = 1;
	size_t soap_flag_Serial_USCORENumber = 1;
	size_t soap_flag_Server_USCOREName = 1;
	size_t soap_flag_Zbx_USCORELast_USCOREClock = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest, sizeof(struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IP_USCOREPrivate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Private", &a->IP_USCOREPrivate, "ns4:ArrayOfInterfaceAddress"))
				{	soap_flag_IP_USCOREPrivate--;
					continue;
				}
			if (soap_flag_IP_USCOREPublic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfInterfaceAddress(soap, "ns4:IP_Public", &a->IP_USCOREPublic, "ns4:ArrayOfInterfaceAddress"))
				{	soap_flag_IP_USCOREPublic--;
					continue;
				}
			if (soap_flag_OS_USCOREVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_Version", &a->OS_USCOREVersion, "xsd:string"))
				{	soap_flag_OS_USCOREVersion--;
					continue;
				}
			if (soap_flag_Serial_USCORENumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Serial_Number", &a->Serial_USCORENumber, "xsd:string"))
				{	soap_flag_Serial_USCORENumber--;
					continue;
				}
			if (soap_flag_Server_USCOREName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Server_Name", &a->Server_USCOREName, "xsd:string"))
				{	soap_flag_Server_USCOREName--;
					continue;
				}
			if (soap_flag_Zbx_USCORELast_USCOREClock && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Zbx_Last_Clock", &a->Zbx_USCORELast_USCOREClock, "xsd:string"))
				{	soap_flag_Zbx_USCORELast_USCOREClock--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest, 0, sizeof(struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, const struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest);
	if (soap_out_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag?tag:"ns4:CMDBv2_SDKUpdateIpMacRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest * SOAP_FMAC4 soap_get_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->BUCKET);
	soap_default_string(soap, &a->CPU);
	soap_default_string(soap, &a->DELETE);
	soap_default_string(soap, &a->DEPARTMENT);
	soap_default_string(soap, &a->DIVISION);
	soap_default_string(soap, &a->HDD);
	soap_default_string(soap, &a->IPADDRESS);
	soap_default_string(soap, &a->MACADDRESS);
	soap_default_string(soap, &a->MEMORY);
	soap_default_string(soap, &a->NEW_USCOREDEPARTMENT);
	soap_default_string(soap, &a->OS);
	soap_default_string(soap, &a->OS_USCORESERVERNAME);
	soap_default_string(soap, &a->PHYSICALSERVERIP);
	soap_default_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_default_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_default_string(soap, &a->PRODUCT);
	soap_default_string(soap, &a->PURPOSE_USCOREUSE);
	soap_default_string(soap, &a->SERVERNAME);
	soap_default_string(soap, &a->STATUS);
	soap_default_string(soap, &a->TECHNICALOWNER);
	soap_default_string(soap, &a->UUID);
	soap_default_string(soap, &a->VLAN);
	soap_default_string(soap, &a->VMCENTER);
	soap_default_string(soap, &a->VMKEY);
	soap_default_string(soap, &a->VMWTOOL);
	soap_default_string(soap, &a->VM_USCOREID);
	soap_default_string(soap, &a->V_USCOREID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, const struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->BUCKET);
	soap_serialize_string(soap, &a->CPU);
	soap_serialize_string(soap, &a->DELETE);
	soap_serialize_string(soap, &a->DEPARTMENT);
	soap_serialize_string(soap, &a->DIVISION);
	soap_serialize_string(soap, &a->HDD);
	soap_serialize_string(soap, &a->IPADDRESS);
	soap_serialize_string(soap, &a->MACADDRESS);
	soap_serialize_string(soap, &a->MEMORY);
	soap_serialize_string(soap, &a->NEW_USCOREDEPARTMENT);
	soap_serialize_string(soap, &a->OS);
	soap_serialize_string(soap, &a->OS_USCORESERVERNAME);
	soap_serialize_string(soap, &a->PHYSICALSERVERIP);
	soap_serialize_string(soap, &a->PHYSICAL_USCORECHASSIS_USCORESN);
	soap_serialize_string(soap, &a->PHYSICAL_USCORESERVER_USCORESN);
	soap_serialize_string(soap, &a->PRODUCT);
	soap_serialize_string(soap, &a->PURPOSE_USCOREUSE);
	soap_serialize_string(soap, &a->SERVERNAME);
	soap_serialize_string(soap, &a->STATUS);
	soap_serialize_string(soap, &a->TECHNICALOWNER);
	soap_serialize_string(soap, &a->UUID);
	soap_serialize_string(soap, &a->VLAN);
	soap_serialize_string(soap, &a->VMCENTER);
	soap_serialize_string(soap, &a->VMKEY);
	soap_serialize_string(soap, &a->VMWTOOL);
	soap_serialize_string(soap, &a->VM_USCOREID);
	soap_serialize_string(soap, &a->V_USCOREID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, const char *tag, int id, const struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:BUCKET", -1, &a->BUCKET, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:CPU", -1, &a->CPU, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DELETE", -1, &a->DELETE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DEPARTMENT", -1, &a->DEPARTMENT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:DIVISION", -1, &a->DIVISION, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:HDD", -1, &a->HDD, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:IPADDRESS", -1, &a->IPADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MACADDRESS", -1, &a->MACADDRESS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:MEMORY", -1, &a->MEMORY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:NEW_DEPARTMENT", -1, &a->NEW_USCOREDEPARTMENT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS", -1, &a->OS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:OS_SERVERNAME", -1, &a->OS_USCORESERVERNAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICALSERVERIP", -1, &a->PHYSICALSERVERIP, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_CHASSIS_SN", -1, &a->PHYSICAL_USCORECHASSIS_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PHYSICAL_SERVER_SN", -1, &a->PHYSICAL_USCORESERVER_USCORESN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PRODUCT", -1, &a->PRODUCT, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:PURPOSE_USE", -1, &a->PURPOSE_USCOREUSE, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:SERVERNAME", -1, &a->SERVERNAME, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:STATUS", -1, &a->STATUS, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:TECHNICALOWNER", -1, &a->TECHNICALOWNER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:UUID", -1, &a->UUID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VLAN", -1, &a->VLAN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMCENTER", -1, &a->VMCENTER, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMKEY", -1, &a->VMKEY, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VMWTOOL", -1, &a->VMWTOOL, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:VM_ID", -1, &a->VM_USCOREID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:V_ID", -1, &a->V_USCOREID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest * SOAP_FMAC4 soap_in_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, const char *tag, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *a, const char *type)
{
	size_t soap_flag_BUCKET = 1;
	size_t soap_flag_CPU = 1;
	size_t soap_flag_DELETE = 1;
	size_t soap_flag_DEPARTMENT = 1;
	size_t soap_flag_DIVISION = 1;
	size_t soap_flag_HDD = 1;
	size_t soap_flag_IPADDRESS = 1;
	size_t soap_flag_MACADDRESS = 1;
	size_t soap_flag_MEMORY = 1;
	size_t soap_flag_NEW_USCOREDEPARTMENT = 1;
	size_t soap_flag_OS = 1;
	size_t soap_flag_OS_USCORESERVERNAME = 1;
	size_t soap_flag_PHYSICALSERVERIP = 1;
	size_t soap_flag_PHYSICAL_USCORECHASSIS_USCORESN = 1;
	size_t soap_flag_PHYSICAL_USCORESERVER_USCORESN = 1;
	size_t soap_flag_PRODUCT = 1;
	size_t soap_flag_PURPOSE_USCOREUSE = 1;
	size_t soap_flag_SERVERNAME = 1;
	size_t soap_flag_STATUS = 1;
	size_t soap_flag_TECHNICALOWNER = 1;
	size_t soap_flag_UUID = 1;
	size_t soap_flag_VLAN = 1;
	size_t soap_flag_VMCENTER = 1;
	size_t soap_flag_VMKEY = 1;
	size_t soap_flag_VMWTOOL = 1;
	size_t soap_flag_VM_USCOREID = 1;
	size_t soap_flag_V_USCOREID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest, sizeof(struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BUCKET && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:BUCKET", &a->BUCKET, "xsd:string"))
				{	soap_flag_BUCKET--;
					continue;
				}
			if (soap_flag_CPU && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:CPU", &a->CPU, "xsd:string"))
				{	soap_flag_CPU--;
					continue;
				}
			if (soap_flag_DELETE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DELETE", &a->DELETE, "xsd:string"))
				{	soap_flag_DELETE--;
					continue;
				}
			if (soap_flag_DEPARTMENT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DEPARTMENT", &a->DEPARTMENT, "xsd:string"))
				{	soap_flag_DEPARTMENT--;
					continue;
				}
			if (soap_flag_DIVISION && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:DIVISION", &a->DIVISION, "xsd:string"))
				{	soap_flag_DIVISION--;
					continue;
				}
			if (soap_flag_HDD && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:HDD", &a->HDD, "xsd:string"))
				{	soap_flag_HDD--;
					continue;
				}
			if (soap_flag_IPADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:IPADDRESS", &a->IPADDRESS, "xsd:string"))
				{	soap_flag_IPADDRESS--;
					continue;
				}
			if (soap_flag_MACADDRESS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MACADDRESS", &a->MACADDRESS, "xsd:string"))
				{	soap_flag_MACADDRESS--;
					continue;
				}
			if (soap_flag_MEMORY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:MEMORY", &a->MEMORY, "xsd:string"))
				{	soap_flag_MEMORY--;
					continue;
				}
			if (soap_flag_NEW_USCOREDEPARTMENT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NEW_DEPARTMENT", &a->NEW_USCOREDEPARTMENT, "xsd:string"))
				{	soap_flag_NEW_USCOREDEPARTMENT--;
					continue;
				}
			if (soap_flag_OS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS", &a->OS, "xsd:string"))
				{	soap_flag_OS--;
					continue;
				}
			if (soap_flag_OS_USCORESERVERNAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:OS_SERVERNAME", &a->OS_USCORESERVERNAME, "xsd:string"))
				{	soap_flag_OS_USCORESERVERNAME--;
					continue;
				}
			if (soap_flag_PHYSICALSERVERIP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICALSERVERIP", &a->PHYSICALSERVERIP, "xsd:string"))
				{	soap_flag_PHYSICALSERVERIP--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORECHASSIS_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_CHASSIS_SN", &a->PHYSICAL_USCORECHASSIS_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORECHASSIS_USCORESN--;
					continue;
				}
			if (soap_flag_PHYSICAL_USCORESERVER_USCORESN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PHYSICAL_SERVER_SN", &a->PHYSICAL_USCORESERVER_USCORESN, "xsd:string"))
				{	soap_flag_PHYSICAL_USCORESERVER_USCORESN--;
					continue;
				}
			if (soap_flag_PRODUCT && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PRODUCT", &a->PRODUCT, "xsd:string"))
				{	soap_flag_PRODUCT--;
					continue;
				}
			if (soap_flag_PURPOSE_USCOREUSE && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:PURPOSE_USE", &a->PURPOSE_USCOREUSE, "xsd:string"))
				{	soap_flag_PURPOSE_USCOREUSE--;
					continue;
				}
			if (soap_flag_SERVERNAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:SERVERNAME", &a->SERVERNAME, "xsd:string"))
				{	soap_flag_SERVERNAME--;
					continue;
				}
			if (soap_flag_STATUS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:STATUS", &a->STATUS, "xsd:string"))
				{	soap_flag_STATUS--;
					continue;
				}
			if (soap_flag_TECHNICALOWNER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:TECHNICALOWNER", &a->TECHNICALOWNER, "xsd:string"))
				{	soap_flag_TECHNICALOWNER--;
					continue;
				}
			if (soap_flag_UUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UUID", &a->UUID, "xsd:string"))
				{	soap_flag_UUID--;
					continue;
				}
			if (soap_flag_VLAN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VLAN", &a->VLAN, "xsd:string"))
				{	soap_flag_VLAN--;
					continue;
				}
			if (soap_flag_VMCENTER && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMCENTER", &a->VMCENTER, "xsd:string"))
				{	soap_flag_VMCENTER--;
					continue;
				}
			if (soap_flag_VMKEY && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMKEY", &a->VMKEY, "xsd:string"))
				{	soap_flag_VMKEY--;
					continue;
				}
			if (soap_flag_VMWTOOL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VMWTOOL", &a->VMWTOOL, "xsd:string"))
				{	soap_flag_VMWTOOL--;
					continue;
				}
			if (soap_flag_VM_USCOREID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:VM_ID", &a->VM_USCOREID, "xsd:string"))
				{	soap_flag_VM_USCOREID--;
					continue;
				}
			if (soap_flag_V_USCOREID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:V_ID", &a->V_USCOREID, "xsd:string"))
				{	soap_flag_V_USCOREID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest, 0, sizeof(struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, const struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest);
	if (soap_out_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag?tag:"ns4:CMDBV2_HandleServerVMInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest * SOAP_FMAC4 soap_get_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, struct ns4__CMDBV2_USCOREGetServerDetailRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NAME);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, const struct ns4__CMDBV2_USCOREGetServerDetailRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->NAME);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, const char *tag, int id, const struct ns4__CMDBV2_USCOREGetServerDetailRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:NAME", -1, &a->NAME, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREGetServerDetailRequest * SOAP_FMAC4 soap_in_ns4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, const char *tag, struct ns4__CMDBV2_USCOREGetServerDetailRequest *a, const char *type)
{
	size_t soap_flag_NAME = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__CMDBV2_USCOREGetServerDetailRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest, sizeof(struct ns4__CMDBV2_USCOREGetServerDetailRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NAME && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:NAME", &a->NAME, "xsd:string"))
				{	soap_flag_NAME--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__CMDBV2_USCOREGetServerDetailRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest, 0, sizeof(struct ns4__CMDBV2_USCOREGetServerDetailRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, const struct ns4__CMDBV2_USCOREGetServerDetailRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest);
	if (soap_out_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, tag?tag:"ns4:CMDBV2_GetServerDetailRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREGetServerDetailRequest * SOAP_FMAC4 soap_get_ns4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, struct ns4__CMDBV2_USCOREGetServerDetailRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__GetGSOCCURequest(struct soap *soap, struct ns4__GetGSOCCURequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->RequestDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__GetGSOCCURequest(struct soap *soap, const struct ns4__GetGSOCCURequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->RequestDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__GetGSOCCURequest(struct soap *soap, const char *tag, int id, const struct ns4__GetGSOCCURequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__GetGSOCCURequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:RequestDate", -1, &a->RequestDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__GetGSOCCURequest * SOAP_FMAC4 soap_in_ns4__GetGSOCCURequest(struct soap *soap, const char *tag, struct ns4__GetGSOCCURequest *a, const char *type)
{
	size_t soap_flag_RequestDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__GetGSOCCURequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__GetGSOCCURequest, sizeof(struct ns4__GetGSOCCURequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__GetGSOCCURequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RequestDate", &a->RequestDate, "xsd:string"))
				{	soap_flag_RequestDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__GetGSOCCURequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__GetGSOCCURequest, 0, sizeof(struct ns4__GetGSOCCURequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__GetGSOCCURequest(struct soap *soap, const struct ns4__GetGSOCCURequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__GetGSOCCURequest);
	if (soap_out_ns4__GetGSOCCURequest(soap, tag?tag:"ns4:GetGSOCCURequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetGSOCCURequest * SOAP_FMAC4 soap_get_ns4__GetGSOCCURequest(struct soap *soap, struct ns4__GetGSOCCURequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__GetGSOCCURequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SDKResponse(struct soap *soap, struct ns4__SDKResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ResponseData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SDKResponse(struct soap *soap, const struct ns4__SDKResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ResponseData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SDKResponse(struct soap *soap, const char *tag, int id, const struct ns4__SDKResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SDKResponse), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:ResponseData", -1, &a->ResponseData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SDKResponse * SOAP_FMAC4 soap_in_ns4__SDKResponse(struct soap *soap, const char *tag, struct ns4__SDKResponse *a, const char *type)
{
	size_t soap_flag_ResponseData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SDKResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SDKResponse, sizeof(struct ns4__SDKResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SDKResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResponseData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ResponseData", &a->ResponseData, "xsd:string"))
				{	soap_flag_ResponseData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SDKResponse, 0, sizeof(struct ns4__SDKResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SDKResponse(struct soap *soap, const struct ns4__SDKResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SDKResponse);
	if (soap_out_ns4__SDKResponse(soap, tag?tag:"ns4:SDKResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKResponse * SOAP_FMAC4 soap_get_ns4__SDKResponse(struct soap *soap, struct ns4__SDKResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SDKResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__CallResponse(struct soap *soap, struct _ns1__CallResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CallResult = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__CallResponse(struct soap *soap, const struct _ns1__CallResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__SDKResponse(soap, &a->CallResult);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CallResponse(struct soap *soap, const char *tag, int id, const struct _ns1__CallResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CallResponse), type))
		return soap->error;
	if (a->CallResult)
		soap_element_result(soap, "ns1:CallResult");
	if (soap_out_PointerTons4__SDKResponse(soap, "ns1:CallResult", -1, &a->CallResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__CallResponse * SOAP_FMAC4 soap_in__ns1__CallResponse(struct soap *soap, const char *tag, struct _ns1__CallResponse *a, const char *type)
{
	size_t soap_flag_CallResult = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__CallResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CallResponse, sizeof(struct _ns1__CallResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__CallResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CallResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SDKResponse(soap, "ns1:CallResult", &a->CallResult, "ns4:SDKResponse"))
				{	soap_flag_CallResult--;
					continue;
				}
			soap_check_result(soap, "ns1:CallResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__CallResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CallResponse, 0, sizeof(struct _ns1__CallResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__CallResponse(struct soap *soap, const struct _ns1__CallResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__CallResponse);
	if (soap_out__ns1__CallResponse(soap, tag?tag:"ns1:CallResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CallResponse * SOAP_FMAC4 soap_get__ns1__CallResponse(struct soap *soap, struct _ns1__CallResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CallResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SDKRequest(struct soap *soap, struct ns4__SDKRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Checksum);
	soap_default_string(soap, &a->ClientId);
	a->DataFormat = NULL;
	a->GetHostInfoRequest = NULL;
	soap_default_string(soap, &a->Operation);
	soap_default_string(soap, &a->RequestData);
	a->RequestTime = NULL;
	soap_default_string(soap, &a->Signature);
	a->theCMDBV2_USCOREGetServerDetailRequest = NULL;
	a->theCMDBV2_USCOREHandleServerVMInfoRequest = NULL;
	a->theCMDBV2_USCORESDKUpdateIpMacRequest = NULL;
	a->theGetCCUByProductCodeRequest = NULL;
	a->theGetIRDServerVMInfoRequest = NULL;
	a->theGetIRDTechnicalOwnerInfoRequest = NULL;
	a->theGetListAllServerRequest = NULL;
	a->theGetODAHostInfoListRequest = NULL;
	a->theGetODAServerInfoListRequest = NULL;
	a->theGetProductInfoByIPRequest = NULL;
	a->theGetSDKServerInfoListRequest = NULL;
	a->theGetSO6InfoServerRequest = NULL;
	a->theGetServerNameBySerialRequest = NULL;
	a->theGetSnSInfoTechnicalOwnerRequest = NULL;
	a->theHandleServerVMInfoRequest = NULL;
	a->theHostInfoRequest = NULL;
	a->theInsertDataServerVMRequest = NULL;
	a->theInsertMeasuredDataRequest = NULL;
	a->theItemValueRequest = NULL;
	a->theMacAddressRequest = NULL;
	a->theOpenIncidentByCSRequest = NULL;
	a->theOpenIncidentByDCRequest = NULL;
	a->theOpenIncidentByG8Request = NULL;
	a->theRemoveDataServerVMRequest = NULL;
	a->theSDKPostRequest = NULL;
	a->theSDKUpdateIpMacRequest = NULL;
	a->theServerInfo = NULL;
	a->theUpdateDataServerPhysicalRequest = NULL;
	a->theUpdateDataServerVMRequest = NULL;
	a->theUpdateInfoRequest = NULL;
	a->theUpdateServerStatusRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SDKRequest(struct soap *soap, const struct ns4__SDKRequest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Checksum);
	soap_serialize_string(soap, &a->ClientId);
	soap_serialize_PointerTons4__DataFormatEnum(soap, &a->DataFormat);
	soap_serialize_PointerTons4__GetGSOCCURequest(soap, &a->GetHostInfoRequest);
	soap_serialize_string(soap, &a->Operation);
	soap_serialize_string(soap, &a->RequestData);
	soap_serialize_PointerTounsignedInt(soap, &a->RequestTime);
	soap_serialize_string(soap, &a->Signature);
	soap_serialize_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, &a->theCMDBV2_USCOREGetServerDetailRequest);
	soap_serialize_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, &a->theCMDBV2_USCOREHandleServerVMInfoRequest);
	soap_serialize_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, &a->theCMDBV2_USCORESDKUpdateIpMacRequest);
	soap_serialize_PointerTons4__GetCCUByProductCodeRequest(soap, &a->theGetCCUByProductCodeRequest);
	soap_serialize_PointerTons4__GetIRDServerVMInfoRequest(soap, &a->theGetIRDServerVMInfoRequest);
	soap_serialize_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, &a->theGetIRDTechnicalOwnerInfoRequest);
	soap_serialize_PointerTons4__GetListAllServerRequest(soap, &a->theGetListAllServerRequest);
	soap_serialize_PointerTons4__GetODAHostInfoListRequest(soap, &a->theGetODAHostInfoListRequest);
	soap_serialize_PointerTons4__GetODAServerInfoListRequest(soap, &a->theGetODAServerInfoListRequest);
	soap_serialize_PointerTons4__GetProductInfoByIPRequest(soap, &a->theGetProductInfoByIPRequest);
	soap_serialize_PointerTons4__GetSDKServerInfoListRequest(soap, &a->theGetSDKServerInfoListRequest);
	soap_serialize_PointerTons4__GetSO6InfoServerRequest(soap, &a->theGetSO6InfoServerRequest);
	soap_serialize_PointerTons4__GetServerNameBySerialNumberRequest(soap, &a->theGetServerNameBySerialRequest);
	soap_serialize_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, &a->theGetSnSInfoTechnicalOwnerRequest);
	soap_serialize_PointerTons4__HandleServerVMInfoRequest(soap, &a->theHandleServerVMInfoRequest);
	soap_serialize_PointerTons4__GetHostsInfoRequest(soap, &a->theHostInfoRequest);
	soap_serialize_PointerTons4__InsertDataServerVMRequest(soap, &a->theInsertDataServerVMRequest);
	soap_serialize_PointerTons4__InsertMeasuredDataRequest(soap, &a->theInsertMeasuredDataRequest);
	soap_serialize_PointerTons4__GetItemValueListRequest(soap, &a->theItemValueRequest);
	soap_serialize_PointerTons4__GetHostInfoByIPRequest(soap, &a->theMacAddressRequest);
	soap_serialize_PointerTons4__OpenIncidentByCSRequest(soap, &a->theOpenIncidentByCSRequest);
	soap_serialize_PointerTons4__OpenIncidentByDCRequest(soap, &a->theOpenIncidentByDCRequest);
	soap_serialize_PointerTons4__OpenIncidentByG8Request(soap, &a->theOpenIncidentByG8Request);
	soap_serialize_PointerTons4__RemoveDataServerVMRequest(soap, &a->theRemoveDataServerVMRequest);
	soap_serialize_PointerTons4__SDKPostRequest(soap, &a->theSDKPostRequest);
	soap_serialize_PointerTons4__SDKUpdateIpMacRequest(soap, &a->theSDKUpdateIpMacRequest);
	soap_serialize_PointerTons4__ServerInfo(soap, &a->theServerInfo);
	soap_serialize_PointerTons4__HandleServerPhysicalInfoRequest(soap, &a->theUpdateDataServerPhysicalRequest);
	soap_serialize_PointerTons4__UpdateDataServerVMRequest(soap, &a->theUpdateDataServerVMRequest);
	soap_serialize_PointerTons4__UpdateInfoRequest(soap, &a->theUpdateInfoRequest);
	soap_serialize_PointerTons4__UpdateServerStatusRequest(soap, &a->theUpdateServerStatusRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SDKRequest(struct soap *soap, const char *tag, int id, const struct ns4__SDKRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SDKRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:Checksum", -1, &a->Checksum, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:ClientId", -1, &a->ClientId, ""))
		return soap->error;
	if (soap_out_PointerTons4__DataFormatEnum(soap, "ns4:DataFormat", -1, &a->DataFormat, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetGSOCCURequest(soap, "ns4:GetHostInfoRequest", -1, &a->GetHostInfoRequest, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Operation", -1, &a->Operation, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:RequestData", -1, &a->RequestData, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "ns4:RequestTime", -1, &a->RequestTime, ""))
		return soap->error;
	if (soap_out_string(soap, "ns4:Signature", -1, &a->Signature, ""))
		return soap->error;
	if (soap_out_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, "ns4:theCMDBV2_GetServerDetailRequest", -1, &a->theCMDBV2_USCOREGetServerDetailRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, "ns4:theCMDBV2_HandleServerVMInfoRequest", -1, &a->theCMDBV2_USCOREHandleServerVMInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, "ns4:theCMDBV2_SDKUpdateIpMacRequest", -1, &a->theCMDBV2_USCORESDKUpdateIpMacRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetCCUByProductCodeRequest(soap, "ns4:theGetCCUByProductCodeRequest", -1, &a->theGetCCUByProductCodeRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetIRDServerVMInfoRequest(soap, "ns4:theGetIRDServerVMInfoRequest", -1, &a->theGetIRDServerVMInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, "ns4:theGetIRDTechnicalOwnerInfoRequest", -1, &a->theGetIRDTechnicalOwnerInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetListAllServerRequest(soap, "ns4:theGetListAllServerRequest", -1, &a->theGetListAllServerRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetODAHostInfoListRequest(soap, "ns4:theGetODAHostInfoListRequest", -1, &a->theGetODAHostInfoListRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetODAServerInfoListRequest(soap, "ns4:theGetODAServerInfoListRequest", -1, &a->theGetODAServerInfoListRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetProductInfoByIPRequest(soap, "ns4:theGetProductInfoByIPRequest", -1, &a->theGetProductInfoByIPRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetSDKServerInfoListRequest(soap, "ns4:theGetSDKServerInfoListRequest", -1, &a->theGetSDKServerInfoListRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetSO6InfoServerRequest(soap, "ns4:theGetSO6InfoServerRequest", -1, &a->theGetSO6InfoServerRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetServerNameBySerialNumberRequest(soap, "ns4:theGetServerNameBySerialRequest", -1, &a->theGetServerNameBySerialRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, "ns4:theGetSnSInfoTechnicalOwnerRequest", -1, &a->theGetSnSInfoTechnicalOwnerRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__HandleServerVMInfoRequest(soap, "ns4:theHandleServerVMInfoRequest", -1, &a->theHandleServerVMInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetHostsInfoRequest(soap, "ns4:theHostInfoRequest", -1, &a->theHostInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__InsertDataServerVMRequest(soap, "ns4:theInsertDataServerVMRequest", -1, &a->theInsertDataServerVMRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__InsertMeasuredDataRequest(soap, "ns4:theInsertMeasuredDataRequest", -1, &a->theInsertMeasuredDataRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetItemValueListRequest(soap, "ns4:theItemValueRequest", -1, &a->theItemValueRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__GetHostInfoByIPRequest(soap, "ns4:theMacAddressRequest", -1, &a->theMacAddressRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__OpenIncidentByCSRequest(soap, "ns4:theOpenIncidentByCSRequest", -1, &a->theOpenIncidentByCSRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__OpenIncidentByDCRequest(soap, "ns4:theOpenIncidentByDCRequest", -1, &a->theOpenIncidentByDCRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__OpenIncidentByG8Request(soap, "ns4:theOpenIncidentByG8Request", -1, &a->theOpenIncidentByG8Request, ""))
		return soap->error;
	if (soap_out_PointerTons4__RemoveDataServerVMRequest(soap, "ns4:theRemoveDataServerVMRequest", -1, &a->theRemoveDataServerVMRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__SDKPostRequest(soap, "ns4:theSDKPostRequest", -1, &a->theSDKPostRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__SDKUpdateIpMacRequest(soap, "ns4:theSDKUpdateIpMacRequest", -1, &a->theSDKUpdateIpMacRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__ServerInfo(soap, "ns4:theServerInfo", -1, &a->theServerInfo, ""))
		return soap->error;
	if (soap_out_PointerTons4__HandleServerPhysicalInfoRequest(soap, "ns4:theUpdateDataServerPhysicalRequest", -1, &a->theUpdateDataServerPhysicalRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__UpdateDataServerVMRequest(soap, "ns4:theUpdateDataServerVMRequest", -1, &a->theUpdateDataServerVMRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__UpdateInfoRequest(soap, "ns4:theUpdateInfoRequest", -1, &a->theUpdateInfoRequest, ""))
		return soap->error;
	if (soap_out_PointerTons4__UpdateServerStatusRequest(soap, "ns4:theUpdateServerStatusRequest", -1, &a->theUpdateServerStatusRequest, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SDKRequest * SOAP_FMAC4 soap_in_ns4__SDKRequest(struct soap *soap, const char *tag, struct ns4__SDKRequest *a, const char *type)
{
	size_t soap_flag_Checksum = 1;
	size_t soap_flag_ClientId = 1;
	size_t soap_flag_DataFormat = 1;
	size_t soap_flag_GetHostInfoRequest = 1;
	size_t soap_flag_Operation = 1;
	size_t soap_flag_RequestData = 1;
	size_t soap_flag_RequestTime = 1;
	size_t soap_flag_Signature = 1;
	size_t soap_flag_theCMDBV2_USCOREGetServerDetailRequest = 1;
	size_t soap_flag_theCMDBV2_USCOREHandleServerVMInfoRequest = 1;
	size_t soap_flag_theCMDBV2_USCORESDKUpdateIpMacRequest = 1;
	size_t soap_flag_theGetCCUByProductCodeRequest = 1;
	size_t soap_flag_theGetIRDServerVMInfoRequest = 1;
	size_t soap_flag_theGetIRDTechnicalOwnerInfoRequest = 1;
	size_t soap_flag_theGetListAllServerRequest = 1;
	size_t soap_flag_theGetODAHostInfoListRequest = 1;
	size_t soap_flag_theGetODAServerInfoListRequest = 1;
	size_t soap_flag_theGetProductInfoByIPRequest = 1;
	size_t soap_flag_theGetSDKServerInfoListRequest = 1;
	size_t soap_flag_theGetSO6InfoServerRequest = 1;
	size_t soap_flag_theGetServerNameBySerialRequest = 1;
	size_t soap_flag_theGetSnSInfoTechnicalOwnerRequest = 1;
	size_t soap_flag_theHandleServerVMInfoRequest = 1;
	size_t soap_flag_theHostInfoRequest = 1;
	size_t soap_flag_theInsertDataServerVMRequest = 1;
	size_t soap_flag_theInsertMeasuredDataRequest = 1;
	size_t soap_flag_theItemValueRequest = 1;
	size_t soap_flag_theMacAddressRequest = 1;
	size_t soap_flag_theOpenIncidentByCSRequest = 1;
	size_t soap_flag_theOpenIncidentByDCRequest = 1;
	size_t soap_flag_theOpenIncidentByG8Request = 1;
	size_t soap_flag_theRemoveDataServerVMRequest = 1;
	size_t soap_flag_theSDKPostRequest = 1;
	size_t soap_flag_theSDKUpdateIpMacRequest = 1;
	size_t soap_flag_theServerInfo = 1;
	size_t soap_flag_theUpdateDataServerPhysicalRequest = 1;
	size_t soap_flag_theUpdateDataServerVMRequest = 1;
	size_t soap_flag_theUpdateInfoRequest = 1;
	size_t soap_flag_theUpdateServerStatusRequest = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SDKRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SDKRequest, sizeof(struct ns4__SDKRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SDKRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Checksum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Checksum", &a->Checksum, "xsd:string"))
				{	soap_flag_Checksum--;
					continue;
				}
			if (soap_flag_ClientId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:ClientId", &a->ClientId, "xsd:string"))
				{	soap_flag_ClientId--;
					continue;
				}
			if (soap_flag_DataFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__DataFormatEnum(soap, "ns4:DataFormat", &a->DataFormat, "ns4:DataFormatEnum"))
				{	soap_flag_DataFormat--;
					continue;
				}
			if (soap_flag_GetHostInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetGSOCCURequest(soap, "ns4:GetHostInfoRequest", &a->GetHostInfoRequest, "ns4:GetGSOCCURequest"))
				{	soap_flag_GetHostInfoRequest--;
					continue;
				}
			if (soap_flag_Operation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Operation", &a->Operation, "xsd:string"))
				{	soap_flag_Operation--;
					continue;
				}
			if (soap_flag_RequestData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:RequestData", &a->RequestData, "xsd:string"))
				{	soap_flag_RequestData--;
					continue;
				}
			if (soap_flag_RequestTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "ns4:RequestTime", &a->RequestTime, "xsd:unsignedInt"))
				{	soap_flag_RequestTime--;
					continue;
				}
			if (soap_flag_Signature && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Signature", &a->Signature, "xsd:string"))
				{	soap_flag_Signature--;
					continue;
				}
			if (soap_flag_theCMDBV2_USCOREGetServerDetailRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, "ns4:theCMDBV2_GetServerDetailRequest", &a->theCMDBV2_USCOREGetServerDetailRequest, "ns4:CMDBV2_GetServerDetailRequest"))
				{	soap_flag_theCMDBV2_USCOREGetServerDetailRequest--;
					continue;
				}
			if (soap_flag_theCMDBV2_USCOREHandleServerVMInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, "ns4:theCMDBV2_HandleServerVMInfoRequest", &a->theCMDBV2_USCOREHandleServerVMInfoRequest, "ns4:CMDBV2_HandleServerVMInfoRequest"))
				{	soap_flag_theCMDBV2_USCOREHandleServerVMInfoRequest--;
					continue;
				}
			if (soap_flag_theCMDBV2_USCORESDKUpdateIpMacRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, "ns4:theCMDBV2_SDKUpdateIpMacRequest", &a->theCMDBV2_USCORESDKUpdateIpMacRequest, "ns4:CMDBv2_SDKUpdateIpMacRequest"))
				{	soap_flag_theCMDBV2_USCORESDKUpdateIpMacRequest--;
					continue;
				}
			if (soap_flag_theGetCCUByProductCodeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetCCUByProductCodeRequest(soap, "ns4:theGetCCUByProductCodeRequest", &a->theGetCCUByProductCodeRequest, "ns4:GetCCUByProductCodeRequest"))
				{	soap_flag_theGetCCUByProductCodeRequest--;
					continue;
				}
			if (soap_flag_theGetIRDServerVMInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetIRDServerVMInfoRequest(soap, "ns4:theGetIRDServerVMInfoRequest", &a->theGetIRDServerVMInfoRequest, "ns4:GetIRDServerVMInfoRequest"))
				{	soap_flag_theGetIRDServerVMInfoRequest--;
					continue;
				}
			if (soap_flag_theGetIRDTechnicalOwnerInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, "ns4:theGetIRDTechnicalOwnerInfoRequest", &a->theGetIRDTechnicalOwnerInfoRequest, "ns4:GetIRDTechnicalOwnerInfoRequest"))
				{	soap_flag_theGetIRDTechnicalOwnerInfoRequest--;
					continue;
				}
			if (soap_flag_theGetListAllServerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetListAllServerRequest(soap, "ns4:theGetListAllServerRequest", &a->theGetListAllServerRequest, "ns4:GetListAllServerRequest"))
				{	soap_flag_theGetListAllServerRequest--;
					continue;
				}
			if (soap_flag_theGetODAHostInfoListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetODAHostInfoListRequest(soap, "ns4:theGetODAHostInfoListRequest", &a->theGetODAHostInfoListRequest, "ns4:GetODAHostInfoListRequest"))
				{	soap_flag_theGetODAHostInfoListRequest--;
					continue;
				}
			if (soap_flag_theGetODAServerInfoListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetODAServerInfoListRequest(soap, "ns4:theGetODAServerInfoListRequest", &a->theGetODAServerInfoListRequest, "ns4:GetODAServerInfoListRequest"))
				{	soap_flag_theGetODAServerInfoListRequest--;
					continue;
				}
			if (soap_flag_theGetProductInfoByIPRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetProductInfoByIPRequest(soap, "ns4:theGetProductInfoByIPRequest", &a->theGetProductInfoByIPRequest, "ns4:GetProductInfoByIPRequest"))
				{	soap_flag_theGetProductInfoByIPRequest--;
					continue;
				}
			if (soap_flag_theGetSDKServerInfoListRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetSDKServerInfoListRequest(soap, "ns4:theGetSDKServerInfoListRequest", &a->theGetSDKServerInfoListRequest, "ns4:GetSDKServerInfoListRequest"))
				{	soap_flag_theGetSDKServerInfoListRequest--;
					continue;
				}
			if (soap_flag_theGetSO6InfoServerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetSO6InfoServerRequest(soap, "ns4:theGetSO6InfoServerRequest", &a->theGetSO6InfoServerRequest, "ns4:GetSO6InfoServerRequest"))
				{	soap_flag_theGetSO6InfoServerRequest--;
					continue;
				}
			if (soap_flag_theGetServerNameBySerialRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetServerNameBySerialNumberRequest(soap, "ns4:theGetServerNameBySerialRequest", &a->theGetServerNameBySerialRequest, "ns4:GetServerNameBySerialNumberRequest"))
				{	soap_flag_theGetServerNameBySerialRequest--;
					continue;
				}
			if (soap_flag_theGetSnSInfoTechnicalOwnerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, "ns4:theGetSnSInfoTechnicalOwnerRequest", &a->theGetSnSInfoTechnicalOwnerRequest, "ns4:GetSnSInfoTechnicalOwnerRequest"))
				{	soap_flag_theGetSnSInfoTechnicalOwnerRequest--;
					continue;
				}
			if (soap_flag_theHandleServerVMInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HandleServerVMInfoRequest(soap, "ns4:theHandleServerVMInfoRequest", &a->theHandleServerVMInfoRequest, "ns4:HandleServerVMInfoRequest"))
				{	soap_flag_theHandleServerVMInfoRequest--;
					continue;
				}
			if (soap_flag_theHostInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetHostsInfoRequest(soap, "ns4:theHostInfoRequest", &a->theHostInfoRequest, "ns4:GetHostsInfoRequest"))
				{	soap_flag_theHostInfoRequest--;
					continue;
				}
			if (soap_flag_theInsertDataServerVMRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__InsertDataServerVMRequest(soap, "ns4:theInsertDataServerVMRequest", &a->theInsertDataServerVMRequest, "ns4:InsertDataServerVMRequest"))
				{	soap_flag_theInsertDataServerVMRequest--;
					continue;
				}
			if (soap_flag_theInsertMeasuredDataRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__InsertMeasuredDataRequest(soap, "ns4:theInsertMeasuredDataRequest", &a->theInsertMeasuredDataRequest, "ns4:InsertMeasuredDataRequest"))
				{	soap_flag_theInsertMeasuredDataRequest--;
					continue;
				}
			if (soap_flag_theItemValueRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetItemValueListRequest(soap, "ns4:theItemValueRequest", &a->theItemValueRequest, "ns4:GetItemValueListRequest"))
				{	soap_flag_theItemValueRequest--;
					continue;
				}
			if (soap_flag_theMacAddressRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__GetHostInfoByIPRequest(soap, "ns4:theMacAddressRequest", &a->theMacAddressRequest, "ns4:GetHostInfoByIPRequest"))
				{	soap_flag_theMacAddressRequest--;
					continue;
				}
			if (soap_flag_theOpenIncidentByCSRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OpenIncidentByCSRequest(soap, "ns4:theOpenIncidentByCSRequest", &a->theOpenIncidentByCSRequest, "ns4:OpenIncidentByCSRequest"))
				{	soap_flag_theOpenIncidentByCSRequest--;
					continue;
				}
			if (soap_flag_theOpenIncidentByDCRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OpenIncidentByDCRequest(soap, "ns4:theOpenIncidentByDCRequest", &a->theOpenIncidentByDCRequest, "ns4:OpenIncidentByDCRequest"))
				{	soap_flag_theOpenIncidentByDCRequest--;
					continue;
				}
			if (soap_flag_theOpenIncidentByG8Request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__OpenIncidentByG8Request(soap, "ns4:theOpenIncidentByG8Request", &a->theOpenIncidentByG8Request, "ns4:OpenIncidentByG8Request"))
				{	soap_flag_theOpenIncidentByG8Request--;
					continue;
				}
			if (soap_flag_theRemoveDataServerVMRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__RemoveDataServerVMRequest(soap, "ns4:theRemoveDataServerVMRequest", &a->theRemoveDataServerVMRequest, "ns4:RemoveDataServerVMRequest"))
				{	soap_flag_theRemoveDataServerVMRequest--;
					continue;
				}
			if (soap_flag_theSDKPostRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SDKPostRequest(soap, "ns4:theSDKPostRequest", &a->theSDKPostRequest, "ns4:SDKPostRequest"))
				{	soap_flag_theSDKPostRequest--;
					continue;
				}
			if (soap_flag_theSDKUpdateIpMacRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SDKUpdateIpMacRequest(soap, "ns4:theSDKUpdateIpMacRequest", &a->theSDKUpdateIpMacRequest, "ns4:SDKUpdateIpMacRequest"))
				{	soap_flag_theSDKUpdateIpMacRequest--;
					continue;
				}
			if (soap_flag_theServerInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ServerInfo(soap, "ns4:theServerInfo", &a->theServerInfo, "ns4:ServerInfo"))
				{	soap_flag_theServerInfo--;
					continue;
				}
			if (soap_flag_theUpdateDataServerPhysicalRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HandleServerPhysicalInfoRequest(soap, "ns4:theUpdateDataServerPhysicalRequest", &a->theUpdateDataServerPhysicalRequest, "ns4:HandleServerPhysicalInfoRequest"))
				{	soap_flag_theUpdateDataServerPhysicalRequest--;
					continue;
				}
			if (soap_flag_theUpdateDataServerVMRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateDataServerVMRequest(soap, "ns4:theUpdateDataServerVMRequest", &a->theUpdateDataServerVMRequest, "ns4:UpdateDataServerVMRequest"))
				{	soap_flag_theUpdateDataServerVMRequest--;
					continue;
				}
			if (soap_flag_theUpdateInfoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateInfoRequest(soap, "ns4:theUpdateInfoRequest", &a->theUpdateInfoRequest, "ns4:UpdateInfoRequest"))
				{	soap_flag_theUpdateInfoRequest--;
					continue;
				}
			if (soap_flag_theUpdateServerStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UpdateServerStatusRequest(soap, "ns4:theUpdateServerStatusRequest", &a->theUpdateServerStatusRequest, "ns4:UpdateServerStatusRequest"))
				{	soap_flag_theUpdateServerStatusRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SDKRequest, 0, sizeof(struct ns4__SDKRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SDKRequest(struct soap *soap, const struct ns4__SDKRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__SDKRequest);
	if (soap_out_ns4__SDKRequest(soap, tag?tag:"ns4:SDKRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKRequest * SOAP_FMAC4 soap_get_ns4__SDKRequest(struct soap *soap, struct ns4__SDKRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SDKRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__Call(struct soap *soap, struct _ns1__Call *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__Call(struct soap *soap, const struct _ns1__Call *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__SDKRequest(soap, &a->request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Call(struct soap *soap, const char *tag, int id, const struct _ns1__Call *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Call), type))
		return soap->error;
	if (soap_out_PointerTons4__SDKRequest(soap, "ns1:request", -1, &a->request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__Call * SOAP_FMAC4 soap_in__ns1__Call(struct soap *soap, const char *tag, struct _ns1__Call *a, const char *type)
{
	size_t soap_flag_request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__Call *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Call, sizeof(struct _ns1__Call), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__Call(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SDKRequest(soap, "ns1:request", &a->request, "ns4:SDKRequest"))
				{	soap_flag_request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__Call *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Call, 0, sizeof(struct _ns1__Call), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__Call(struct soap *soap, const struct _ns1__Call *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__Call);
	if (soap_out__ns1__Call(soap, tag?tag:"ns1:Call", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Call * SOAP_FMAC4 soap_get__ns1__Call(struct soap *soap, struct _ns1__Call *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Call(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
#ifndef WITH_NOIDREF
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CallResponse(struct soap *soap, struct _ns1__CallResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CallResponse))
		soap_serialize__ns1__CallResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CallResponse(struct soap *soap, const char *tag, int id, struct _ns1__CallResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CallResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CallResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CallResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CallResponse(struct soap *soap, const char *tag, struct _ns1__CallResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CallResponse **)soap_malloc(soap, sizeof(struct _ns1__CallResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CallResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CallResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CallResponse, sizeof(struct _ns1__CallResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CallResponse(struct soap *soap, struct _ns1__CallResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CallResponse);
	if (soap_out_PointerTo_ns1__CallResponse(soap, tag?tag:"ns1:CallResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CallResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CallResponse(struct soap *soap, struct _ns1__CallResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CallResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Call(struct soap *soap, struct _ns1__Call *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Call))
		soap_serialize__ns1__Call(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Call(struct soap *soap, const char *tag, int id, struct _ns1__Call *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Call);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__Call(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__Call ** SOAP_FMAC4 soap_in_PointerTo_ns1__Call(struct soap *soap, const char *tag, struct _ns1__Call **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__Call **)soap_malloc(soap, sizeof(struct _ns1__Call *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__Call(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__Call **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Call, sizeof(struct _ns1__Call), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Call(struct soap *soap, struct _ns1__Call *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Call);
	if (soap_out_PointerTo_ns1__Call(soap, tag?tag:"ns1:Call", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Call ** SOAP_FMAC4 soap_get_PointerTo_ns1__Call(struct soap *soap, struct _ns1__Call **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Call(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ArrayOfbase64Binary(struct soap *soap, struct ns5__ArrayOfbase64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ArrayOfbase64Binary))
		soap_serialize_ns5__ArrayOfbase64Binary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ArrayOfbase64Binary(struct soap *soap, const char *tag, int id, struct ns5__ArrayOfbase64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ArrayOfbase64Binary);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__ArrayOfbase64Binary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__ArrayOfbase64Binary ** SOAP_FMAC4 soap_in_PointerTons5__ArrayOfbase64Binary(struct soap *soap, const char *tag, struct ns5__ArrayOfbase64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__ArrayOfbase64Binary **)soap_malloc(soap, sizeof(struct ns5__ArrayOfbase64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__ArrayOfbase64Binary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__ArrayOfbase64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ArrayOfbase64Binary, sizeof(struct ns5__ArrayOfbase64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ArrayOfbase64Binary(struct soap *soap, struct ns5__ArrayOfbase64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ArrayOfbase64Binary);
	if (soap_out_PointerTons5__ArrayOfbase64Binary(soap, tag?tag:"ns5:ArrayOfbase64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ArrayOfbase64Binary ** SOAP_FMAC4 soap_get_PointerTons5__ArrayOfbase64Binary(struct soap *soap, struct ns5__ArrayOfbase64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ArrayOfbase64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_xsd__base64Binary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, struct xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__base64Binary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__base64Binary **)soap_malloc(soap, sizeof(struct xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__base64Binary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ServerStatusInfo(struct soap *soap, struct ns4__ServerStatusInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ServerStatusInfo))
		soap_serialize_ns4__ServerStatusInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ServerStatusInfo(struct soap *soap, const char *tag, int id, struct ns4__ServerStatusInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ServerStatusInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ServerStatusInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ServerStatusInfo ** SOAP_FMAC4 soap_in_PointerTons4__ServerStatusInfo(struct soap *soap, const char *tag, struct ns4__ServerStatusInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ServerStatusInfo **)soap_malloc(soap, sizeof(struct ns4__ServerStatusInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ServerStatusInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ServerStatusInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ServerStatusInfo, sizeof(struct ns4__ServerStatusInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ServerStatusInfo(struct soap *soap, struct ns4__ServerStatusInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ServerStatusInfo);
	if (soap_out_PointerTons4__ServerStatusInfo(soap, tag?tag:"ns4:ServerStatusInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ServerStatusInfo ** SOAP_FMAC4 soap_get_PointerTons4__ServerStatusInfo(struct soap *soap, struct ns4__ServerStatusInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ServerStatusInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfServerStatusInfo(struct soap *soap, struct ns4__ArrayOfServerStatusInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfServerStatusInfo))
		soap_serialize_ns4__ArrayOfServerStatusInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfServerStatusInfo(struct soap *soap, const char *tag, int id, struct ns4__ArrayOfServerStatusInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfServerStatusInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ArrayOfServerStatusInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ArrayOfServerStatusInfo ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfServerStatusInfo(struct soap *soap, const char *tag, struct ns4__ArrayOfServerStatusInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ArrayOfServerStatusInfo **)soap_malloc(soap, sizeof(struct ns4__ArrayOfServerStatusInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ArrayOfServerStatusInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfServerStatusInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfServerStatusInfo, sizeof(struct ns4__ArrayOfServerStatusInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfServerStatusInfo(struct soap *soap, struct ns4__ArrayOfServerStatusInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfServerStatusInfo);
	if (soap_out_PointerTons4__ArrayOfServerStatusInfo(soap, tag?tag:"ns4:ArrayOfServerStatusInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfServerStatusInfo ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfServerStatusInfo(struct soap *soap, struct ns4__ArrayOfServerStatusInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfServerStatusInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FieldCode(struct soap *soap, enum ns4__FieldCode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns4__FieldCode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FieldCode(struct soap *soap, const char *tag, int id, enum ns4__FieldCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FieldCode);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__FieldCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__FieldCode ** SOAP_FMAC4 soap_in_PointerTons4__FieldCode(struct soap *soap, const char *tag, enum ns4__FieldCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__FieldCode **)soap_malloc(soap, sizeof(enum ns4__FieldCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__FieldCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__FieldCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FieldCode, sizeof(enum ns4__FieldCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FieldCode(struct soap *soap, enum ns4__FieldCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FieldCode);
	if (soap_out_PointerTons4__FieldCode(soap, tag?tag:"ns4:FieldCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__FieldCode ** SOAP_FMAC4 soap_get_PointerTons4__FieldCode(struct soap *soap, enum ns4__FieldCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FieldCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfFieldPair(struct soap *soap, struct ns4__ArrayOfFieldPair *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfFieldPair))
		soap_serialize_ns4__ArrayOfFieldPair(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfFieldPair(struct soap *soap, const char *tag, int id, struct ns4__ArrayOfFieldPair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfFieldPair);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ArrayOfFieldPair(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ArrayOfFieldPair ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfFieldPair(struct soap *soap, const char *tag, struct ns4__ArrayOfFieldPair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ArrayOfFieldPair **)soap_malloc(soap, sizeof(struct ns4__ArrayOfFieldPair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ArrayOfFieldPair(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfFieldPair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfFieldPair, sizeof(struct ns4__ArrayOfFieldPair), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfFieldPair(struct soap *soap, struct ns4__ArrayOfFieldPair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfFieldPair);
	if (soap_out_PointerTons4__ArrayOfFieldPair(soap, tag?tag:"ns4:ArrayOfFieldPair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfFieldPair ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfFieldPair(struct soap *soap, struct ns4__ArrayOfFieldPair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfFieldPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__FieldPair(struct soap *soap, struct ns4__FieldPair *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__FieldPair))
		soap_serialize_ns4__FieldPair(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__FieldPair(struct soap *soap, const char *tag, int id, struct ns4__FieldPair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__FieldPair);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__FieldPair(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__FieldPair ** SOAP_FMAC4 soap_in_PointerTons4__FieldPair(struct soap *soap, const char *tag, struct ns4__FieldPair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__FieldPair **)soap_malloc(soap, sizeof(struct ns4__FieldPair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__FieldPair(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__FieldPair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__FieldPair, sizeof(struct ns4__FieldPair), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__FieldPair(struct soap *soap, struct ns4__FieldPair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__FieldPair);
	if (soap_out_PointerTons4__FieldPair(soap, tag?tag:"ns4:FieldPair", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FieldPair ** SOAP_FMAC4 soap_get_PointerTons4__FieldPair(struct soap *soap, struct ns4__FieldPair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__FieldPair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UpdateCategory(struct soap *soap, enum ns4__UpdateCategory *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns4__UpdateCategory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UpdateCategory(struct soap *soap, const char *tag, int id, enum ns4__UpdateCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UpdateCategory);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__UpdateCategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__UpdateCategory ** SOAP_FMAC4 soap_in_PointerTons4__UpdateCategory(struct soap *soap, const char *tag, enum ns4__UpdateCategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__UpdateCategory **)soap_malloc(soap, sizeof(enum ns4__UpdateCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__UpdateCategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__UpdateCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UpdateCategory, sizeof(enum ns4__UpdateCategory), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UpdateCategory(struct soap *soap, enum ns4__UpdateCategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UpdateCategory);
	if (soap_out_PointerTons4__UpdateCategory(soap, tag?tag:"ns4:UpdateCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__UpdateCategory ** SOAP_FMAC4 soap_get_PointerTons4__UpdateCategory(struct soap *soap, enum ns4__UpdateCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UpdateCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__G8Action(struct soap *soap, enum ns4__G8Action *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns4__G8Action);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__G8Action(struct soap *soap, const char *tag, int id, enum ns4__G8Action *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__G8Action);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__G8Action(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__G8Action ** SOAP_FMAC4 soap_in_PointerTons4__G8Action(struct soap *soap, const char *tag, enum ns4__G8Action **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__G8Action **)soap_malloc(soap, sizeof(enum ns4__G8Action *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__G8Action(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__G8Action **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__G8Action, sizeof(enum ns4__G8Action), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__G8Action(struct soap *soap, enum ns4__G8Action *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__G8Action);
	if (soap_out_PointerTons4__G8Action(soap, tag?tag:"ns4:G8Action", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__G8Action ** SOAP_FMAC4 soap_get_PointerTons4__G8Action(struct soap *soap, enum ns4__G8Action **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__G8Action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ArrayOfstring(struct soap *soap, struct ns5__ArrayOfstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ArrayOfstring))
		soap_serialize_ns5__ArrayOfstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ArrayOfstring(struct soap *soap, const char *tag, int id, struct ns5__ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ArrayOfstring);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__ArrayOfstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerTons5__ArrayOfstring(struct soap *soap, const char *tag, struct ns5__ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__ArrayOfstring **)soap_malloc(soap, sizeof(struct ns5__ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__ArrayOfstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ArrayOfstring, sizeof(struct ns5__ArrayOfstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ArrayOfstring(struct soap *soap, struct ns5__ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ArrayOfstring);
	if (soap_out_PointerTons5__ArrayOfstring(soap, tag?tag:"ns5:ArrayOfstring", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerTons5__ArrayOfstring(struct soap *soap, struct ns5__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfServerInfo(struct soap *soap, struct ns4__ArrayOfServerInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfServerInfo))
		soap_serialize_ns4__ArrayOfServerInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfServerInfo(struct soap *soap, const char *tag, int id, struct ns4__ArrayOfServerInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfServerInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ArrayOfServerInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ArrayOfServerInfo ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfServerInfo(struct soap *soap, const char *tag, struct ns4__ArrayOfServerInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ArrayOfServerInfo **)soap_malloc(soap, sizeof(struct ns4__ArrayOfServerInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ArrayOfServerInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfServerInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfServerInfo, sizeof(struct ns4__ArrayOfServerInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfServerInfo(struct soap *soap, struct ns4__ArrayOfServerInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfServerInfo);
	if (soap_out_PointerTons4__ArrayOfServerInfo(soap, tag?tag:"ns4:ArrayOfServerInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfServerInfo ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfServerInfo(struct soap *soap, struct ns4__ArrayOfServerInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfServerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedShort(struct soap *soap, unsigned short *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedShort);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedShort(struct soap *soap, const char *tag, int id, unsigned short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedShort);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedShort(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned short ** SOAP_FMAC4 soap_in_PointerTounsignedShort(struct soap *soap, const char *tag, unsigned short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned short **)soap_malloc(soap, sizeof(unsigned short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedShort(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedShort, sizeof(unsigned short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedShort(struct soap *soap, unsigned short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedShort);
	if (soap_out_PointerTounsignedShort(soap, tag?tag:"unsignedShort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short ** SOAP_FMAC4 soap_get_PointerTounsignedShort(struct soap *soap, unsigned short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__InterfaceAddress(struct soap *soap, struct ns4__InterfaceAddress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__InterfaceAddress))
		soap_serialize_ns4__InterfaceAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__InterfaceAddress(struct soap *soap, const char *tag, int id, struct ns4__InterfaceAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__InterfaceAddress);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__InterfaceAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__InterfaceAddress ** SOAP_FMAC4 soap_in_PointerTons4__InterfaceAddress(struct soap *soap, const char *tag, struct ns4__InterfaceAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__InterfaceAddress **)soap_malloc(soap, sizeof(struct ns4__InterfaceAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__InterfaceAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__InterfaceAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__InterfaceAddress, sizeof(struct ns4__InterfaceAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__InterfaceAddress(struct soap *soap, struct ns4__InterfaceAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__InterfaceAddress);
	if (soap_out_PointerTons4__InterfaceAddress(soap, tag?tag:"ns4:InterfaceAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InterfaceAddress ** SOAP_FMAC4 soap_get_PointerTons4__InterfaceAddress(struct soap *soap, struct ns4__InterfaceAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__InterfaceAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfInterfaceAddress(struct soap *soap, struct ns4__ArrayOfInterfaceAddress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfInterfaceAddress))
		soap_serialize_ns4__ArrayOfInterfaceAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfInterfaceAddress(struct soap *soap, const char *tag, int id, struct ns4__ArrayOfInterfaceAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfInterfaceAddress);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ArrayOfInterfaceAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ArrayOfInterfaceAddress ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfInterfaceAddress(struct soap *soap, const char *tag, struct ns4__ArrayOfInterfaceAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ArrayOfInterfaceAddress **)soap_malloc(soap, sizeof(struct ns4__ArrayOfInterfaceAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ArrayOfInterfaceAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ArrayOfInterfaceAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfInterfaceAddress, sizeof(struct ns4__ArrayOfInterfaceAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfInterfaceAddress(struct soap *soap, struct ns4__ArrayOfInterfaceAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfInterfaceAddress);
	if (soap_out_PointerTons4__ArrayOfInterfaceAddress(soap, tag?tag:"ns4:ArrayOfInterfaceAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ArrayOfInterfaceAddress ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfInterfaceAddress(struct soap *soap, struct ns4__ArrayOfInterfaceAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfInterfaceAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UpdateServerStatusRequest(struct soap *soap, struct ns4__UpdateServerStatusRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UpdateServerStatusRequest))
		soap_serialize_ns4__UpdateServerStatusRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UpdateServerStatusRequest(struct soap *soap, const char *tag, int id, struct ns4__UpdateServerStatusRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UpdateServerStatusRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__UpdateServerStatusRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__UpdateServerStatusRequest ** SOAP_FMAC4 soap_in_PointerTons4__UpdateServerStatusRequest(struct soap *soap, const char *tag, struct ns4__UpdateServerStatusRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__UpdateServerStatusRequest **)soap_malloc(soap, sizeof(struct ns4__UpdateServerStatusRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__UpdateServerStatusRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__UpdateServerStatusRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UpdateServerStatusRequest, sizeof(struct ns4__UpdateServerStatusRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UpdateServerStatusRequest(struct soap *soap, struct ns4__UpdateServerStatusRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UpdateServerStatusRequest);
	if (soap_out_PointerTons4__UpdateServerStatusRequest(soap, tag?tag:"ns4:UpdateServerStatusRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UpdateServerStatusRequest ** SOAP_FMAC4 soap_get_PointerTons4__UpdateServerStatusRequest(struct soap *soap, struct ns4__UpdateServerStatusRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UpdateServerStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UpdateInfoRequest(struct soap *soap, struct ns4__UpdateInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UpdateInfoRequest))
		soap_serialize_ns4__UpdateInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UpdateInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__UpdateInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UpdateInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__UpdateInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__UpdateInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__UpdateInfoRequest(struct soap *soap, const char *tag, struct ns4__UpdateInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__UpdateInfoRequest **)soap_malloc(soap, sizeof(struct ns4__UpdateInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__UpdateInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__UpdateInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UpdateInfoRequest, sizeof(struct ns4__UpdateInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UpdateInfoRequest(struct soap *soap, struct ns4__UpdateInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UpdateInfoRequest);
	if (soap_out_PointerTons4__UpdateInfoRequest(soap, tag?tag:"ns4:UpdateInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UpdateInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__UpdateInfoRequest(struct soap *soap, struct ns4__UpdateInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UpdateInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UpdateDataServerVMRequest(struct soap *soap, struct ns4__UpdateDataServerVMRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UpdateDataServerVMRequest))
		soap_serialize_ns4__UpdateDataServerVMRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UpdateDataServerVMRequest(struct soap *soap, const char *tag, int id, struct ns4__UpdateDataServerVMRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UpdateDataServerVMRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__UpdateDataServerVMRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__UpdateDataServerVMRequest ** SOAP_FMAC4 soap_in_PointerTons4__UpdateDataServerVMRequest(struct soap *soap, const char *tag, struct ns4__UpdateDataServerVMRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__UpdateDataServerVMRequest **)soap_malloc(soap, sizeof(struct ns4__UpdateDataServerVMRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__UpdateDataServerVMRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__UpdateDataServerVMRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UpdateDataServerVMRequest, sizeof(struct ns4__UpdateDataServerVMRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UpdateDataServerVMRequest(struct soap *soap, struct ns4__UpdateDataServerVMRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UpdateDataServerVMRequest);
	if (soap_out_PointerTons4__UpdateDataServerVMRequest(soap, tag?tag:"ns4:UpdateDataServerVMRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UpdateDataServerVMRequest ** SOAP_FMAC4 soap_get_PointerTons4__UpdateDataServerVMRequest(struct soap *soap, struct ns4__UpdateDataServerVMRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UpdateDataServerVMRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__HandleServerPhysicalInfoRequest(struct soap *soap, struct ns4__HandleServerPhysicalInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest))
		soap_serialize_ns4__HandleServerPhysicalInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__HandleServerPhysicalInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__HandleServerPhysicalInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__HandleServerPhysicalInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__HandleServerPhysicalInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__HandleServerPhysicalInfoRequest(struct soap *soap, const char *tag, struct ns4__HandleServerPhysicalInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__HandleServerPhysicalInfoRequest **)soap_malloc(soap, sizeof(struct ns4__HandleServerPhysicalInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__HandleServerPhysicalInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__HandleServerPhysicalInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__HandleServerPhysicalInfoRequest, sizeof(struct ns4__HandleServerPhysicalInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__HandleServerPhysicalInfoRequest(struct soap *soap, struct ns4__HandleServerPhysicalInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__HandleServerPhysicalInfoRequest);
	if (soap_out_PointerTons4__HandleServerPhysicalInfoRequest(soap, tag?tag:"ns4:HandleServerPhysicalInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HandleServerPhysicalInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__HandleServerPhysicalInfoRequest(struct soap *soap, struct ns4__HandleServerPhysicalInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__HandleServerPhysicalInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ServerInfo(struct soap *soap, struct ns4__ServerInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ServerInfo))
		soap_serialize_ns4__ServerInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ServerInfo(struct soap *soap, const char *tag, int id, struct ns4__ServerInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ServerInfo);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__ServerInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__ServerInfo ** SOAP_FMAC4 soap_in_PointerTons4__ServerInfo(struct soap *soap, const char *tag, struct ns4__ServerInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__ServerInfo **)soap_malloc(soap, sizeof(struct ns4__ServerInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__ServerInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__ServerInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ServerInfo, sizeof(struct ns4__ServerInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ServerInfo(struct soap *soap, struct ns4__ServerInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ServerInfo);
	if (soap_out_PointerTons4__ServerInfo(soap, tag?tag:"ns4:ServerInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ServerInfo ** SOAP_FMAC4 soap_get_PointerTons4__ServerInfo(struct soap *soap, struct ns4__ServerInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ServerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SDKUpdateIpMacRequest(struct soap *soap, struct ns4__SDKUpdateIpMacRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SDKUpdateIpMacRequest))
		soap_serialize_ns4__SDKUpdateIpMacRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SDKUpdateIpMacRequest(struct soap *soap, const char *tag, int id, struct ns4__SDKUpdateIpMacRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SDKUpdateIpMacRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SDKUpdateIpMacRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SDKUpdateIpMacRequest ** SOAP_FMAC4 soap_in_PointerTons4__SDKUpdateIpMacRequest(struct soap *soap, const char *tag, struct ns4__SDKUpdateIpMacRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SDKUpdateIpMacRequest **)soap_malloc(soap, sizeof(struct ns4__SDKUpdateIpMacRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SDKUpdateIpMacRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKUpdateIpMacRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SDKUpdateIpMacRequest, sizeof(struct ns4__SDKUpdateIpMacRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SDKUpdateIpMacRequest(struct soap *soap, struct ns4__SDKUpdateIpMacRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SDKUpdateIpMacRequest);
	if (soap_out_PointerTons4__SDKUpdateIpMacRequest(soap, tag?tag:"ns4:SDKUpdateIpMacRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKUpdateIpMacRequest ** SOAP_FMAC4 soap_get_PointerTons4__SDKUpdateIpMacRequest(struct soap *soap, struct ns4__SDKUpdateIpMacRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SDKUpdateIpMacRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SDKPostRequest(struct soap *soap, struct ns4__SDKPostRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SDKPostRequest))
		soap_serialize_ns4__SDKPostRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SDKPostRequest(struct soap *soap, const char *tag, int id, struct ns4__SDKPostRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SDKPostRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SDKPostRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SDKPostRequest ** SOAP_FMAC4 soap_in_PointerTons4__SDKPostRequest(struct soap *soap, const char *tag, struct ns4__SDKPostRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SDKPostRequest **)soap_malloc(soap, sizeof(struct ns4__SDKPostRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SDKPostRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKPostRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SDKPostRequest, sizeof(struct ns4__SDKPostRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SDKPostRequest(struct soap *soap, struct ns4__SDKPostRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SDKPostRequest);
	if (soap_out_PointerTons4__SDKPostRequest(soap, tag?tag:"ns4:SDKPostRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKPostRequest ** SOAP_FMAC4 soap_get_PointerTons4__SDKPostRequest(struct soap *soap, struct ns4__SDKPostRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SDKPostRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__RemoveDataServerVMRequest(struct soap *soap, struct ns4__RemoveDataServerVMRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__RemoveDataServerVMRequest))
		soap_serialize_ns4__RemoveDataServerVMRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__RemoveDataServerVMRequest(struct soap *soap, const char *tag, int id, struct ns4__RemoveDataServerVMRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__RemoveDataServerVMRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__RemoveDataServerVMRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__RemoveDataServerVMRequest ** SOAP_FMAC4 soap_in_PointerTons4__RemoveDataServerVMRequest(struct soap *soap, const char *tag, struct ns4__RemoveDataServerVMRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__RemoveDataServerVMRequest **)soap_malloc(soap, sizeof(struct ns4__RemoveDataServerVMRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__RemoveDataServerVMRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__RemoveDataServerVMRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__RemoveDataServerVMRequest, sizeof(struct ns4__RemoveDataServerVMRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__RemoveDataServerVMRequest(struct soap *soap, struct ns4__RemoveDataServerVMRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__RemoveDataServerVMRequest);
	if (soap_out_PointerTons4__RemoveDataServerVMRequest(soap, tag?tag:"ns4:RemoveDataServerVMRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__RemoveDataServerVMRequest ** SOAP_FMAC4 soap_get_PointerTons4__RemoveDataServerVMRequest(struct soap *soap, struct ns4__RemoveDataServerVMRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__RemoveDataServerVMRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OpenIncidentByG8Request(struct soap *soap, struct ns4__OpenIncidentByG8Request *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__OpenIncidentByG8Request))
		soap_serialize_ns4__OpenIncidentByG8Request(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OpenIncidentByG8Request(struct soap *soap, const char *tag, int id, struct ns4__OpenIncidentByG8Request *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OpenIncidentByG8Request);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__OpenIncidentByG8Request(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__OpenIncidentByG8Request ** SOAP_FMAC4 soap_in_PointerTons4__OpenIncidentByG8Request(struct soap *soap, const char *tag, struct ns4__OpenIncidentByG8Request **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__OpenIncidentByG8Request **)soap_malloc(soap, sizeof(struct ns4__OpenIncidentByG8Request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__OpenIncidentByG8Request(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__OpenIncidentByG8Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OpenIncidentByG8Request, sizeof(struct ns4__OpenIncidentByG8Request), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OpenIncidentByG8Request(struct soap *soap, struct ns4__OpenIncidentByG8Request *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__OpenIncidentByG8Request);
	if (soap_out_PointerTons4__OpenIncidentByG8Request(soap, tag?tag:"ns4:OpenIncidentByG8Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__OpenIncidentByG8Request ** SOAP_FMAC4 soap_get_PointerTons4__OpenIncidentByG8Request(struct soap *soap, struct ns4__OpenIncidentByG8Request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OpenIncidentByG8Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OpenIncidentByDCRequest(struct soap *soap, struct ns4__OpenIncidentByDCRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__OpenIncidentByDCRequest))
		soap_serialize_ns4__OpenIncidentByDCRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OpenIncidentByDCRequest(struct soap *soap, const char *tag, int id, struct ns4__OpenIncidentByDCRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OpenIncidentByDCRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__OpenIncidentByDCRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__OpenIncidentByDCRequest ** SOAP_FMAC4 soap_in_PointerTons4__OpenIncidentByDCRequest(struct soap *soap, const char *tag, struct ns4__OpenIncidentByDCRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__OpenIncidentByDCRequest **)soap_malloc(soap, sizeof(struct ns4__OpenIncidentByDCRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__OpenIncidentByDCRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__OpenIncidentByDCRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OpenIncidentByDCRequest, sizeof(struct ns4__OpenIncidentByDCRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OpenIncidentByDCRequest(struct soap *soap, struct ns4__OpenIncidentByDCRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__OpenIncidentByDCRequest);
	if (soap_out_PointerTons4__OpenIncidentByDCRequest(soap, tag?tag:"ns4:OpenIncidentByDCRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__OpenIncidentByDCRequest ** SOAP_FMAC4 soap_get_PointerTons4__OpenIncidentByDCRequest(struct soap *soap, struct ns4__OpenIncidentByDCRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OpenIncidentByDCRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__OpenIncidentByCSRequest(struct soap *soap, struct ns4__OpenIncidentByCSRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__OpenIncidentByCSRequest))
		soap_serialize_ns4__OpenIncidentByCSRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__OpenIncidentByCSRequest(struct soap *soap, const char *tag, int id, struct ns4__OpenIncidentByCSRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__OpenIncidentByCSRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__OpenIncidentByCSRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__OpenIncidentByCSRequest ** SOAP_FMAC4 soap_in_PointerTons4__OpenIncidentByCSRequest(struct soap *soap, const char *tag, struct ns4__OpenIncidentByCSRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__OpenIncidentByCSRequest **)soap_malloc(soap, sizeof(struct ns4__OpenIncidentByCSRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__OpenIncidentByCSRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__OpenIncidentByCSRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__OpenIncidentByCSRequest, sizeof(struct ns4__OpenIncidentByCSRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__OpenIncidentByCSRequest(struct soap *soap, struct ns4__OpenIncidentByCSRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__OpenIncidentByCSRequest);
	if (soap_out_PointerTons4__OpenIncidentByCSRequest(soap, tag?tag:"ns4:OpenIncidentByCSRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__OpenIncidentByCSRequest ** SOAP_FMAC4 soap_get_PointerTons4__OpenIncidentByCSRequest(struct soap *soap, struct ns4__OpenIncidentByCSRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__OpenIncidentByCSRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetHostInfoByIPRequest(struct soap *soap, struct ns4__GetHostInfoByIPRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetHostInfoByIPRequest))
		soap_serialize_ns4__GetHostInfoByIPRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetHostInfoByIPRequest(struct soap *soap, const char *tag, int id, struct ns4__GetHostInfoByIPRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetHostInfoByIPRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetHostInfoByIPRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetHostInfoByIPRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetHostInfoByIPRequest(struct soap *soap, const char *tag, struct ns4__GetHostInfoByIPRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetHostInfoByIPRequest **)soap_malloc(soap, sizeof(struct ns4__GetHostInfoByIPRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetHostInfoByIPRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetHostInfoByIPRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetHostInfoByIPRequest, sizeof(struct ns4__GetHostInfoByIPRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetHostInfoByIPRequest(struct soap *soap, struct ns4__GetHostInfoByIPRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetHostInfoByIPRequest);
	if (soap_out_PointerTons4__GetHostInfoByIPRequest(soap, tag?tag:"ns4:GetHostInfoByIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetHostInfoByIPRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetHostInfoByIPRequest(struct soap *soap, struct ns4__GetHostInfoByIPRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetHostInfoByIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetItemValueListRequest(struct soap *soap, struct ns4__GetItemValueListRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetItemValueListRequest))
		soap_serialize_ns4__GetItemValueListRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetItemValueListRequest(struct soap *soap, const char *tag, int id, struct ns4__GetItemValueListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetItemValueListRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetItemValueListRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetItemValueListRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetItemValueListRequest(struct soap *soap, const char *tag, struct ns4__GetItemValueListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetItemValueListRequest **)soap_malloc(soap, sizeof(struct ns4__GetItemValueListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetItemValueListRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetItemValueListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetItemValueListRequest, sizeof(struct ns4__GetItemValueListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetItemValueListRequest(struct soap *soap, struct ns4__GetItemValueListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetItemValueListRequest);
	if (soap_out_PointerTons4__GetItemValueListRequest(soap, tag?tag:"ns4:GetItemValueListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetItemValueListRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetItemValueListRequest(struct soap *soap, struct ns4__GetItemValueListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetItemValueListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__InsertMeasuredDataRequest(struct soap *soap, struct ns4__InsertMeasuredDataRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__InsertMeasuredDataRequest))
		soap_serialize_ns4__InsertMeasuredDataRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__InsertMeasuredDataRequest(struct soap *soap, const char *tag, int id, struct ns4__InsertMeasuredDataRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__InsertMeasuredDataRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__InsertMeasuredDataRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__InsertMeasuredDataRequest ** SOAP_FMAC4 soap_in_PointerTons4__InsertMeasuredDataRequest(struct soap *soap, const char *tag, struct ns4__InsertMeasuredDataRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__InsertMeasuredDataRequest **)soap_malloc(soap, sizeof(struct ns4__InsertMeasuredDataRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__InsertMeasuredDataRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__InsertMeasuredDataRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__InsertMeasuredDataRequest, sizeof(struct ns4__InsertMeasuredDataRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__InsertMeasuredDataRequest(struct soap *soap, struct ns4__InsertMeasuredDataRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__InsertMeasuredDataRequest);
	if (soap_out_PointerTons4__InsertMeasuredDataRequest(soap, tag?tag:"ns4:InsertMeasuredDataRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InsertMeasuredDataRequest ** SOAP_FMAC4 soap_get_PointerTons4__InsertMeasuredDataRequest(struct soap *soap, struct ns4__InsertMeasuredDataRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__InsertMeasuredDataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__InsertDataServerVMRequest(struct soap *soap, struct ns4__InsertDataServerVMRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__InsertDataServerVMRequest))
		soap_serialize_ns4__InsertDataServerVMRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__InsertDataServerVMRequest(struct soap *soap, const char *tag, int id, struct ns4__InsertDataServerVMRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__InsertDataServerVMRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__InsertDataServerVMRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__InsertDataServerVMRequest ** SOAP_FMAC4 soap_in_PointerTons4__InsertDataServerVMRequest(struct soap *soap, const char *tag, struct ns4__InsertDataServerVMRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__InsertDataServerVMRequest **)soap_malloc(soap, sizeof(struct ns4__InsertDataServerVMRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__InsertDataServerVMRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__InsertDataServerVMRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__InsertDataServerVMRequest, sizeof(struct ns4__InsertDataServerVMRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__InsertDataServerVMRequest(struct soap *soap, struct ns4__InsertDataServerVMRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__InsertDataServerVMRequest);
	if (soap_out_PointerTons4__InsertDataServerVMRequest(soap, tag?tag:"ns4:InsertDataServerVMRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__InsertDataServerVMRequest ** SOAP_FMAC4 soap_get_PointerTons4__InsertDataServerVMRequest(struct soap *soap, struct ns4__InsertDataServerVMRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__InsertDataServerVMRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetHostsInfoRequest(struct soap *soap, struct ns4__GetHostsInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetHostsInfoRequest))
		soap_serialize_ns4__GetHostsInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetHostsInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__GetHostsInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetHostsInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetHostsInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetHostsInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetHostsInfoRequest(struct soap *soap, const char *tag, struct ns4__GetHostsInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetHostsInfoRequest **)soap_malloc(soap, sizeof(struct ns4__GetHostsInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetHostsInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetHostsInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetHostsInfoRequest, sizeof(struct ns4__GetHostsInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetHostsInfoRequest(struct soap *soap, struct ns4__GetHostsInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetHostsInfoRequest);
	if (soap_out_PointerTons4__GetHostsInfoRequest(soap, tag?tag:"ns4:GetHostsInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetHostsInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetHostsInfoRequest(struct soap *soap, struct ns4__GetHostsInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetHostsInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__HandleServerVMInfoRequest(struct soap *soap, struct ns4__HandleServerVMInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__HandleServerVMInfoRequest))
		soap_serialize_ns4__HandleServerVMInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__HandleServerVMInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__HandleServerVMInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__HandleServerVMInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__HandleServerVMInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__HandleServerVMInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__HandleServerVMInfoRequest(struct soap *soap, const char *tag, struct ns4__HandleServerVMInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__HandleServerVMInfoRequest **)soap_malloc(soap, sizeof(struct ns4__HandleServerVMInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__HandleServerVMInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__HandleServerVMInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__HandleServerVMInfoRequest, sizeof(struct ns4__HandleServerVMInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__HandleServerVMInfoRequest(struct soap *soap, struct ns4__HandleServerVMInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__HandleServerVMInfoRequest);
	if (soap_out_PointerTons4__HandleServerVMInfoRequest(soap, tag?tag:"ns4:HandleServerVMInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HandleServerVMInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__HandleServerVMInfoRequest(struct soap *soap, struct ns4__HandleServerVMInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__HandleServerVMInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, struct ns4__GetSnSInfoTechnicalOwnerRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest))
		soap_serialize_ns4__GetSnSInfoTechnicalOwnerRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, const char *tag, int id, struct ns4__GetSnSInfoTechnicalOwnerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetSnSInfoTechnicalOwnerRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetSnSInfoTechnicalOwnerRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, const char *tag, struct ns4__GetSnSInfoTechnicalOwnerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetSnSInfoTechnicalOwnerRequest **)soap_malloc(soap, sizeof(struct ns4__GetSnSInfoTechnicalOwnerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetSnSInfoTechnicalOwnerRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetSnSInfoTechnicalOwnerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetSnSInfoTechnicalOwnerRequest, sizeof(struct ns4__GetSnSInfoTechnicalOwnerRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, struct ns4__GetSnSInfoTechnicalOwnerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetSnSInfoTechnicalOwnerRequest);
	if (soap_out_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, tag?tag:"ns4:GetSnSInfoTechnicalOwnerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetSnSInfoTechnicalOwnerRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetSnSInfoTechnicalOwnerRequest(struct soap *soap, struct ns4__GetSnSInfoTechnicalOwnerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetSnSInfoTechnicalOwnerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetServerNameBySerialNumberRequest(struct soap *soap, struct ns4__GetServerNameBySerialNumberRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest))
		soap_serialize_ns4__GetServerNameBySerialNumberRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetServerNameBySerialNumberRequest(struct soap *soap, const char *tag, int id, struct ns4__GetServerNameBySerialNumberRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetServerNameBySerialNumberRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetServerNameBySerialNumberRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetServerNameBySerialNumberRequest(struct soap *soap, const char *tag, struct ns4__GetServerNameBySerialNumberRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetServerNameBySerialNumberRequest **)soap_malloc(soap, sizeof(struct ns4__GetServerNameBySerialNumberRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetServerNameBySerialNumberRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetServerNameBySerialNumberRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetServerNameBySerialNumberRequest, sizeof(struct ns4__GetServerNameBySerialNumberRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetServerNameBySerialNumberRequest(struct soap *soap, struct ns4__GetServerNameBySerialNumberRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetServerNameBySerialNumberRequest);
	if (soap_out_PointerTons4__GetServerNameBySerialNumberRequest(soap, tag?tag:"ns4:GetServerNameBySerialNumberRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetServerNameBySerialNumberRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetServerNameBySerialNumberRequest(struct soap *soap, struct ns4__GetServerNameBySerialNumberRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetServerNameBySerialNumberRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetSO6InfoServerRequest(struct soap *soap, struct ns4__GetSO6InfoServerRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetSO6InfoServerRequest))
		soap_serialize_ns4__GetSO6InfoServerRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetSO6InfoServerRequest(struct soap *soap, const char *tag, int id, struct ns4__GetSO6InfoServerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetSO6InfoServerRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetSO6InfoServerRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetSO6InfoServerRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetSO6InfoServerRequest(struct soap *soap, const char *tag, struct ns4__GetSO6InfoServerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetSO6InfoServerRequest **)soap_malloc(soap, sizeof(struct ns4__GetSO6InfoServerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetSO6InfoServerRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetSO6InfoServerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetSO6InfoServerRequest, sizeof(struct ns4__GetSO6InfoServerRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetSO6InfoServerRequest(struct soap *soap, struct ns4__GetSO6InfoServerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetSO6InfoServerRequest);
	if (soap_out_PointerTons4__GetSO6InfoServerRequest(soap, tag?tag:"ns4:GetSO6InfoServerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetSO6InfoServerRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetSO6InfoServerRequest(struct soap *soap, struct ns4__GetSO6InfoServerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetSO6InfoServerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetSDKServerInfoListRequest(struct soap *soap, struct ns4__GetSDKServerInfoListRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetSDKServerInfoListRequest))
		soap_serialize_ns4__GetSDKServerInfoListRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetSDKServerInfoListRequest(struct soap *soap, const char *tag, int id, struct ns4__GetSDKServerInfoListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetSDKServerInfoListRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetSDKServerInfoListRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetSDKServerInfoListRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetSDKServerInfoListRequest(struct soap *soap, const char *tag, struct ns4__GetSDKServerInfoListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetSDKServerInfoListRequest **)soap_malloc(soap, sizeof(struct ns4__GetSDKServerInfoListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetSDKServerInfoListRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetSDKServerInfoListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetSDKServerInfoListRequest, sizeof(struct ns4__GetSDKServerInfoListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetSDKServerInfoListRequest(struct soap *soap, struct ns4__GetSDKServerInfoListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetSDKServerInfoListRequest);
	if (soap_out_PointerTons4__GetSDKServerInfoListRequest(soap, tag?tag:"ns4:GetSDKServerInfoListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetSDKServerInfoListRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetSDKServerInfoListRequest(struct soap *soap, struct ns4__GetSDKServerInfoListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetSDKServerInfoListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetProductInfoByIPRequest(struct soap *soap, struct ns4__GetProductInfoByIPRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetProductInfoByIPRequest))
		soap_serialize_ns4__GetProductInfoByIPRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetProductInfoByIPRequest(struct soap *soap, const char *tag, int id, struct ns4__GetProductInfoByIPRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetProductInfoByIPRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetProductInfoByIPRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetProductInfoByIPRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetProductInfoByIPRequest(struct soap *soap, const char *tag, struct ns4__GetProductInfoByIPRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetProductInfoByIPRequest **)soap_malloc(soap, sizeof(struct ns4__GetProductInfoByIPRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetProductInfoByIPRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetProductInfoByIPRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetProductInfoByIPRequest, sizeof(struct ns4__GetProductInfoByIPRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetProductInfoByIPRequest(struct soap *soap, struct ns4__GetProductInfoByIPRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetProductInfoByIPRequest);
	if (soap_out_PointerTons4__GetProductInfoByIPRequest(soap, tag?tag:"ns4:GetProductInfoByIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetProductInfoByIPRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetProductInfoByIPRequest(struct soap *soap, struct ns4__GetProductInfoByIPRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetProductInfoByIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetODAServerInfoListRequest(struct soap *soap, struct ns4__GetODAServerInfoListRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetODAServerInfoListRequest))
		soap_serialize_ns4__GetODAServerInfoListRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetODAServerInfoListRequest(struct soap *soap, const char *tag, int id, struct ns4__GetODAServerInfoListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetODAServerInfoListRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetODAServerInfoListRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetODAServerInfoListRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetODAServerInfoListRequest(struct soap *soap, const char *tag, struct ns4__GetODAServerInfoListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetODAServerInfoListRequest **)soap_malloc(soap, sizeof(struct ns4__GetODAServerInfoListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetODAServerInfoListRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetODAServerInfoListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetODAServerInfoListRequest, sizeof(struct ns4__GetODAServerInfoListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetODAServerInfoListRequest(struct soap *soap, struct ns4__GetODAServerInfoListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetODAServerInfoListRequest);
	if (soap_out_PointerTons4__GetODAServerInfoListRequest(soap, tag?tag:"ns4:GetODAServerInfoListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetODAServerInfoListRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetODAServerInfoListRequest(struct soap *soap, struct ns4__GetODAServerInfoListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetODAServerInfoListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetODAHostInfoListRequest(struct soap *soap, struct ns4__GetODAHostInfoListRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetODAHostInfoListRequest))
		soap_serialize_ns4__GetODAHostInfoListRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetODAHostInfoListRequest(struct soap *soap, const char *tag, int id, struct ns4__GetODAHostInfoListRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetODAHostInfoListRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetODAHostInfoListRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetODAHostInfoListRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetODAHostInfoListRequest(struct soap *soap, const char *tag, struct ns4__GetODAHostInfoListRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetODAHostInfoListRequest **)soap_malloc(soap, sizeof(struct ns4__GetODAHostInfoListRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetODAHostInfoListRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetODAHostInfoListRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetODAHostInfoListRequest, sizeof(struct ns4__GetODAHostInfoListRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetODAHostInfoListRequest(struct soap *soap, struct ns4__GetODAHostInfoListRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetODAHostInfoListRequest);
	if (soap_out_PointerTons4__GetODAHostInfoListRequest(soap, tag?tag:"ns4:GetODAHostInfoListRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetODAHostInfoListRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetODAHostInfoListRequest(struct soap *soap, struct ns4__GetODAHostInfoListRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetODAHostInfoListRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetListAllServerRequest(struct soap *soap, struct ns4__GetListAllServerRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetListAllServerRequest))
		soap_serialize_ns4__GetListAllServerRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetListAllServerRequest(struct soap *soap, const char *tag, int id, struct ns4__GetListAllServerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetListAllServerRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetListAllServerRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetListAllServerRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetListAllServerRequest(struct soap *soap, const char *tag, struct ns4__GetListAllServerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetListAllServerRequest **)soap_malloc(soap, sizeof(struct ns4__GetListAllServerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetListAllServerRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetListAllServerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetListAllServerRequest, sizeof(struct ns4__GetListAllServerRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetListAllServerRequest(struct soap *soap, struct ns4__GetListAllServerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetListAllServerRequest);
	if (soap_out_PointerTons4__GetListAllServerRequest(soap, tag?tag:"ns4:GetListAllServerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetListAllServerRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetListAllServerRequest(struct soap *soap, struct ns4__GetListAllServerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetListAllServerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, struct ns4__GetIRDTechnicalOwnerInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest))
		soap_serialize_ns4__GetIRDTechnicalOwnerInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__GetIRDTechnicalOwnerInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetIRDTechnicalOwnerInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetIRDTechnicalOwnerInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, const char *tag, struct ns4__GetIRDTechnicalOwnerInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetIRDTechnicalOwnerInfoRequest **)soap_malloc(soap, sizeof(struct ns4__GetIRDTechnicalOwnerInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetIRDTechnicalOwnerInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetIRDTechnicalOwnerInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetIRDTechnicalOwnerInfoRequest, sizeof(struct ns4__GetIRDTechnicalOwnerInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, struct ns4__GetIRDTechnicalOwnerInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetIRDTechnicalOwnerInfoRequest);
	if (soap_out_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, tag?tag:"ns4:GetIRDTechnicalOwnerInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetIRDTechnicalOwnerInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetIRDTechnicalOwnerInfoRequest(struct soap *soap, struct ns4__GetIRDTechnicalOwnerInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetIRDTechnicalOwnerInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetIRDServerVMInfoRequest(struct soap *soap, struct ns4__GetIRDServerVMInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest))
		soap_serialize_ns4__GetIRDServerVMInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetIRDServerVMInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__GetIRDServerVMInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetIRDServerVMInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetIRDServerVMInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetIRDServerVMInfoRequest(struct soap *soap, const char *tag, struct ns4__GetIRDServerVMInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetIRDServerVMInfoRequest **)soap_malloc(soap, sizeof(struct ns4__GetIRDServerVMInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetIRDServerVMInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetIRDServerVMInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetIRDServerVMInfoRequest, sizeof(struct ns4__GetIRDServerVMInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetIRDServerVMInfoRequest(struct soap *soap, struct ns4__GetIRDServerVMInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetIRDServerVMInfoRequest);
	if (soap_out_PointerTons4__GetIRDServerVMInfoRequest(soap, tag?tag:"ns4:GetIRDServerVMInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetIRDServerVMInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetIRDServerVMInfoRequest(struct soap *soap, struct ns4__GetIRDServerVMInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetIRDServerVMInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetCCUByProductCodeRequest(struct soap *soap, struct ns4__GetCCUByProductCodeRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetCCUByProductCodeRequest))
		soap_serialize_ns4__GetCCUByProductCodeRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetCCUByProductCodeRequest(struct soap *soap, const char *tag, int id, struct ns4__GetCCUByProductCodeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetCCUByProductCodeRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetCCUByProductCodeRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetCCUByProductCodeRequest ** SOAP_FMAC4 soap_in_PointerTons4__GetCCUByProductCodeRequest(struct soap *soap, const char *tag, struct ns4__GetCCUByProductCodeRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetCCUByProductCodeRequest **)soap_malloc(soap, sizeof(struct ns4__GetCCUByProductCodeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetCCUByProductCodeRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetCCUByProductCodeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetCCUByProductCodeRequest, sizeof(struct ns4__GetCCUByProductCodeRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetCCUByProductCodeRequest(struct soap *soap, struct ns4__GetCCUByProductCodeRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetCCUByProductCodeRequest);
	if (soap_out_PointerTons4__GetCCUByProductCodeRequest(soap, tag?tag:"ns4:GetCCUByProductCodeRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetCCUByProductCodeRequest ** SOAP_FMAC4 soap_get_PointerTons4__GetCCUByProductCodeRequest(struct soap *soap, struct ns4__GetCCUByProductCodeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetCCUByProductCodeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest))
		soap_serialize_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, const char *tag, int id, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest ** SOAP_FMAC4 soap_in_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, const char *tag, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest **)soap_malloc(soap, sizeof(struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CMDBv2_USCORESDKUpdateIpMacRequest, sizeof(struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest);
	if (soap_out_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag?tag:"ns4:CMDBv2_SDKUpdateIpMacRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest ** SOAP_FMAC4 soap_get_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(struct soap *soap, struct ns4__CMDBv2_USCORESDKUpdateIpMacRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CMDBv2_USCORESDKUpdateIpMacRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest))
		soap_serialize_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, const char *tag, int id, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest ** SOAP_FMAC4 soap_in_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, const char *tag, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest **)soap_malloc(soap, sizeof(struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CMDBV2_USCOREHandleServerVMInfoRequest, sizeof(struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest);
	if (soap_out_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag?tag:"ns4:CMDBV2_HandleServerVMInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest ** SOAP_FMAC4 soap_get_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(struct soap *soap, struct ns4__CMDBV2_USCOREHandleServerVMInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CMDBV2_USCOREHandleServerVMInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, struct ns4__CMDBV2_USCOREGetServerDetailRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest))
		soap_serialize_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, const char *tag, int id, struct ns4__CMDBV2_USCOREGetServerDetailRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREGetServerDetailRequest ** SOAP_FMAC4 soap_in_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, const char *tag, struct ns4__CMDBV2_USCOREGetServerDetailRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__CMDBV2_USCOREGetServerDetailRequest **)soap_malloc(soap, sizeof(struct ns4__CMDBV2_USCOREGetServerDetailRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__CMDBV2_USCOREGetServerDetailRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__CMDBV2_USCOREGetServerDetailRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__CMDBV2_USCOREGetServerDetailRequest, sizeof(struct ns4__CMDBV2_USCOREGetServerDetailRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, struct ns4__CMDBV2_USCOREGetServerDetailRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__CMDBV2_USCOREGetServerDetailRequest);
	if (soap_out_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, tag?tag:"ns4:CMDBV2_GetServerDetailRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__CMDBV2_USCOREGetServerDetailRequest ** SOAP_FMAC4 soap_get_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(struct soap *soap, struct ns4__CMDBV2_USCOREGetServerDetailRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__CMDBV2_USCOREGetServerDetailRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedInt);
	if (soap_out_PointerTounsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__GetGSOCCURequest(struct soap *soap, struct ns4__GetGSOCCURequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__GetGSOCCURequest))
		soap_serialize_ns4__GetGSOCCURequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__GetGSOCCURequest(struct soap *soap, const char *tag, int id, struct ns4__GetGSOCCURequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__GetGSOCCURequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__GetGSOCCURequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__GetGSOCCURequest ** SOAP_FMAC4 soap_in_PointerTons4__GetGSOCCURequest(struct soap *soap, const char *tag, struct ns4__GetGSOCCURequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__GetGSOCCURequest **)soap_malloc(soap, sizeof(struct ns4__GetGSOCCURequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__GetGSOCCURequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__GetGSOCCURequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__GetGSOCCURequest, sizeof(struct ns4__GetGSOCCURequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__GetGSOCCURequest(struct soap *soap, struct ns4__GetGSOCCURequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__GetGSOCCURequest);
	if (soap_out_PointerTons4__GetGSOCCURequest(soap, tag?tag:"ns4:GetGSOCCURequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__GetGSOCCURequest ** SOAP_FMAC4 soap_get_PointerTons4__GetGSOCCURequest(struct soap *soap, struct ns4__GetGSOCCURequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__GetGSOCCURequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__DataFormatEnum(struct soap *soap, enum ns4__DataFormatEnum *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns4__DataFormatEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__DataFormatEnum(struct soap *soap, const char *tag, int id, enum ns4__DataFormatEnum *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__DataFormatEnum);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__DataFormatEnum(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns4__DataFormatEnum ** SOAP_FMAC4 soap_in_PointerTons4__DataFormatEnum(struct soap *soap, const char *tag, enum ns4__DataFormatEnum **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns4__DataFormatEnum **)soap_malloc(soap, sizeof(enum ns4__DataFormatEnum *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__DataFormatEnum(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns4__DataFormatEnum **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__DataFormatEnum, sizeof(enum ns4__DataFormatEnum), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__DataFormatEnum(struct soap *soap, enum ns4__DataFormatEnum *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__DataFormatEnum);
	if (soap_out_PointerTons4__DataFormatEnum(soap, tag?tag:"ns4:DataFormatEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__DataFormatEnum ** SOAP_FMAC4 soap_get_PointerTons4__DataFormatEnum(struct soap *soap, enum ns4__DataFormatEnum **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__DataFormatEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SDKResponse(struct soap *soap, struct ns4__SDKResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SDKResponse))
		soap_serialize_ns4__SDKResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SDKResponse(struct soap *soap, const char *tag, int id, struct ns4__SDKResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SDKResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SDKResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SDKResponse ** SOAP_FMAC4 soap_in_PointerTons4__SDKResponse(struct soap *soap, const char *tag, struct ns4__SDKResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SDKResponse **)soap_malloc(soap, sizeof(struct ns4__SDKResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SDKResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SDKResponse, sizeof(struct ns4__SDKResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SDKResponse(struct soap *soap, struct ns4__SDKResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SDKResponse);
	if (soap_out_PointerTons4__SDKResponse(soap, tag?tag:"ns4:SDKResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKResponse ** SOAP_FMAC4 soap_get_PointerTons4__SDKResponse(struct soap *soap, struct ns4__SDKResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SDKResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__SDKRequest(struct soap *soap, struct ns4__SDKRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__SDKRequest))
		soap_serialize_ns4__SDKRequest(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__SDKRequest(struct soap *soap, const char *tag, int id, struct ns4__SDKRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__SDKRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__SDKRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns4__SDKRequest ** SOAP_FMAC4 soap_in_PointerTons4__SDKRequest(struct soap *soap, const char *tag, struct ns4__SDKRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns4__SDKRequest **)soap_malloc(soap, sizeof(struct ns4__SDKRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__SDKRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns4__SDKRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__SDKRequest, sizeof(struct ns4__SDKRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__SDKRequest(struct soap *soap, struct ns4__SDKRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__SDKRequest);
	if (soap_out_PointerTons4__SDKRequest(soap, tag?tag:"ns4:SDKRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SDKRequest ** SOAP_FMAC4 soap_get_PointerTons4__SDKRequest(struct soap *soap, struct ns4__SDKRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__SDKRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__guid(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns3__guid);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__guid(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__guid);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns3__guid(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__guid, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__guid(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__guid);
	if (soap_out_ns3__guid(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__guid(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__duration(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns3__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns3__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns3__duration(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ns3__duration, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__duration);
	if (soap_out_ns3__duration(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns3__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__duration);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__duration, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__decimal);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__IDREF(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__IDREF);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__IDREF);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__IDREF(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__IDREF, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	if (soap_out_xsd__IDREF(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__ID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__ID);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__ID, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
